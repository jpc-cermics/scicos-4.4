function [txt]=get_blk4_code(name)
//Copyright (c) 1989-2010 Metalau project INRIA
//
//@@ get_blk4_code : extract code of scicos blocks
//                   of type 4 & 10004
//
// Input : name : name of a scicos computational function
//                of type 4 or 10004
//
// Output : txt : the output code

  txt=[];

  select name
      case 'backlash' then
        txt = [""
               "#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "void backlash(scicos_block *block,int flag)"
               "{ "
               "  void **_work=GetPtrWorkPtrs(block);"
               "  double *_rpar=GetRparPtrs(block);"
               "  double *_g=GetGPtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double* rw,t;"
               "  if (flag == 4){/* the workspace is used to store previous values */"
               "    if ((*_work=         scicos_malloc(sizeof(double)* 4))== NULL ) {"
               "      set_block_error(-16);"
               "      return;"
               "    }"
               "    rw=*_work; "
               "    t=get_scicos_time();"
               "    rw[0]=t;"
               "    rw[1]=t;"
               "    rw[2]=_rpar[0];"
               "    rw[3]=_rpar[0];"
               "  }else  if (flag == 5){"
               "    scicos_free(*_work);"
               "  }else  if (flag == 1) {"
               "    rw=*_work;"
               "    t=get_scicos_time();"
               "    if(t>rw[1]) {"
               "      rw[0]=rw[1];"
               "      rw[2]=rw[3];"
               "    }"
               "    rw[1]=t;"
               "    if(_u1[0]>rw[2]+_rpar[1]/2){"
               "      rw[3]=_u1[0]-_rpar[1]/2;"
               "    } else if (_u1[0]<rw[2]-_rpar[1]/2){"
               "      rw[3]=_u1[0]+_rpar[1]/2;"
               "    } else {"
               "      rw[3]=rw[2];"
               "    }"
               "    _y1[0]=rw[3];"
               "  }  else if (flag == 9) {"
               "    rw=*_work;"
               "    t=get_scicos_time();"
               "    if(t>rw[1]){"
               "      _g[0] = _u1[0]-_rpar[1]/2-rw[3];"
               "      _g[1] = _u1[0]+_rpar[1]/2-rw[3];"
               "    }else{"
               "      _g[0] = _u1[0]-_rpar[1]/2-rw[2];"
               "      _g[1] = _u1[0]+_rpar[1]/2-rw[2];"
               "    }"
               "  } "
               "}"]

      case 'bit_clear_32' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void bit_clear_32(scicos_block *block,int flag)"
               "{"
               "  int n,m,i;"
               "  long *opar;"
               "  long *u,*y;"
               "  opar=Getint32OparPtrs(block,1);"
               "  u=Getint32InPortPtrs(block,1);"
               "  y=Getint32OutPortPtrs(block,1);"
               "  m=GetInPortRows(block,1);"
               "  n=GetInPortCols(block,1);"
               "  for (i=0;i<m*n;i++) *(y+i)=((*(u+i))&(*opar));"
               "}"]

      case 'bit_set_32' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void bit_set_32(scicos_block *block,int flag)"
               "{"
               "  int n,m,i;"
               "  long *opar;"
               "  long *u,*y;"
               "  opar=Getint32OparPtrs(block,1);"
               "  u=Getint32InPortPtrs(block,1);"
               "  y=Getint32OutPortPtrs(block,1);"
               "  n=GetInPortCols(block,1);"
               "  m=GetInPortRows(block,1);"
               "  for (i=0;i<m*n;i++) *(y+i)=((*(u+i))|(*opar));"
               "}"]

      case 'bounce_ball' then
        txt = [""
               "#include <math.h>"
               "#include ""machine.h"""
               "#include ""scicos_block4.h"""
               ""
               "void "
               "bounce_ball(scicos_block *block,int flag)"
               "{"
               "  double *_rpar=GetRparPtrs(block);"
               "  int _nx=GetNstate(block);"
               "  double *_xd=GetDerState(block);"
               "  double *_x=GetState(block);"
               "  int *_ipar=GetIparPtrs(block);"
               "  int *_jroot=GetJrootPtrs(block);"
               "  int _ng=GetNg(block);"
               "  double *_g=GetGPtrs(block);"
               "  int _nevprt=GetNevIn(block);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double *_y2=GetRealOutPortPtrs(block,2);"
               ""
               "     int nevprt,nx,*ipar;"
               "     double *x,*xd,*rpar;"
               "     double *g;"
               "     int ng;"
               "     int *jroot;"
               "     "
               "     "
               "  int i1;"
               "  double d1, d2, d3;"
               "  "
               "  static double a, b, c;"
               "  static int i, j, k, n;"
               "  static double s1, s2, s3, s4, xsi,*y1,*y2;"
               "  "
               "  /*     Scicos block simulator */"
               "  /*     bouncing ball */"
               "  /*     rpar(i): mass of ball i */"
               "  /*     rpar(i+n): radius of ball i */"
               "  /*     rpar(2n+1:2n+4); [xmin,xmax,ymin,ymax] */"
               "  /*     x: [x1,x1'',y1,y1'',x2,x2'',y2,y2'',...,yn''] */"
               "  /*     n:number of ball=ny1=ny2 */"
               "  /*     y1: x-coord des balles */"
               "  /*     y2: y-coord des balles */"
               "  /*     ipar: storage de taille [nx(n-1)/2=ng]*2 */"
               "  nevprt=_nevprt;"
               "  nx=_nx;"
               "  ipar=_ipar;"
               "  x=_x;"
               "  xd=_xd;"
               "  rpar=_rpar;"
               ""
               "  g=_g;"
               "  ng=_ng;"
               "  jroot=_jroot;"
               "  /* Parameter adjustments to index vectors as in Scilab (fortran)*/"
               "  --g;"
               "  --ipar;"
               "  --rpar;"
               "  --x;"
               "  --xd;"
               "  y1=_y1;"
               "  y2=_y2;"
               "  --y2;"
               "  --y1;"
               "  --jroot;"
               "  "
               "  n = GetOutPortRows(block,1);"
               "  if (flag == 0) {"
               "    c = rpar[(n << 1) + 6];"
               "    i1 = n;"
               "    for (i = 1; i <= i1; ++i) {"
               "      xd[((i - 1) << 2) + 1] = x[((i - 1) << 2) + 2];"
               "      xd[((i - 1) << 2) + 3] = x[((i - 1) << 2) + 4];"
               "      xd[((i - 1) << 2) + 2] = -c * x[((i - 1) << 2) + 2];"
               "      xd[((i - 1) << 2) + 4] = -rpar[(n << 1) + 5] ;"
               "    }"
               "    "
               "  } else if (flag == 1) {"
               "    i1 = n;"
               "    for (i = 1; i <= i1; ++i) {"
               "      y1[i] = x[((i - 1) << 2) + 1];"
               "      y2[i] = x[((i - 1) << 2) + 3];"
               "    }"
               "  } else if (flag == 9) {"
               "    i1 = ng - (n << 2);"
               "    for (k = 1; k <= i1; ++k) {"
               "      i = ipar[((k - 1) << 1) + 1];"
               "      j = ipar[((k - 1) << 1) + 2];"
               "      d1 = x[((i - 1) << 2) + 1] - x[((j - 1) << 2) + 1];"
               "      d2 = x[((i - 1) << 2) + 3] - x[((j - 1) << 2) + 3];"
               "      d3 = rpar[i + n] + rpar[j + n];"
               "      g[k] = d1 * d1 + d2 * d2 - d3 * d3;"
               "    }"
               "    k = ng - (n << 2) + 1;"
               "    i1 = n;"
               "    for (i = 1; i <= i1; ++i) {"
               "      g[k] = x[((i - 1) << 2) + 3] - rpar[i + n] - rpar[(n << 1) + 3];"
               "      ++k;"
               "      g[k] = rpar[(n << 1) + 4] - x[((i - 1) << 2) + 3] - rpar[i + n];"
               "      ++k;"
               "      g[k] = x[((i - 1) << 2) + 1] - rpar[(n << 1) + 1] - rpar[i + n];"
               "      ++k;"
               "      g[k] = rpar[(n << 1) + 2] - rpar[i + n] - x[((i - 1) << 2) + 1];"
               "      ++k;"
               "    }"
               "    "
               "  } else if (flag == 2 && nevprt < 0) {"
               "    i1 = ng - (n << 2);"
               "    for (k = 1; k <= i1; ++k) {"
               "      if (jroot[k] < 0) {"
               "        i = ipar[((k - 1) << 1) + 1];"
               "        j = ipar[((k - 1) << 1) + 2];"
               "        s1 = x[((j - 1) << 2) + 1] - x[((i - 1) << 2) + 1];"
               "        s2 = -rpar[i] * s1 / rpar[j];"
               "        s3 = x[((j - 1) << 2) + 3] - x[((i - 1) << 2) + 3];"
               "        s4 = -rpar[i] * s3 / rpar[j];"
               "        a = rpar[i] * (s1 * s1 + s3 * s3) + rpar[j] * (s2 * s2 + s4 "
               "                                                       * s4);"
               "        b = rpar[i] * (s1 * x[((i - 1) << 2) + 2] + s3 * x[((i - 1 )"
               "                                                          << 2) + 4]) + rpar[j] * (s2 * x[((j - 1) << 2) + 2] + "
               "                                                                                   s4 * x[((j - 1) << 2) + 4]);"
               "        xsi = -(b * 2. / a);"
               "        x[((i - 1) << 2) + 2] += s1 * xsi;"
               "        x[((j - 1) << 2) + 2] += s2 * xsi;"
               "        x[((i - 1) << 2) + 4] += s3 * xsi;"
               "        x[((j - 1) << 2) + 4] += s4 * xsi;"
               "      }"
               "    }"
               "    k = ng - (n << 2) + 1;"
               "    i1 = n;"
               "    for (i = 1; i <= i1; ++i) {"
               "      if (jroot[k] < 0) {"
               "        x[((i - 1) << 2) + 4] = -x[((i - 1) << 2) + 4];"
               "      }"
               "      ++k;"
               "      if (jroot[k] < 0) {"
               "        x[((i - 1) << 2) + 4] = -x[((i - 1) << 2) + 4];"
               "      }"
               "      ++k;"
               "      if (jroot[k] < 0) {"
               "        x[((i - 1) << 2) + 2] = -x[((i - 1) << 2) + 2];"
               "      }"
               "      ++k;"
               "      if (jroot[k] < 0) {"
               "        x[((i - 1) << 2) + 2] = -x[((i - 1) << 2) + 2];"
               "      }"
               "      ++k;"
               "    }"
               "  }"
               "} "]

      case 'bouncexy' then
        txt = ["/**"
               "   \file bouncexy.c"
               "   \author Benoit Bayol"
               "   \version 1.0"
               "   \date September 2006 - January 2007"
               "   \brief BOUNCEXY has to be used with bounce_ball block"
               "   \see BOUNCEXY.sci in macros/scicos_blocks/Misc/"
               "*/"
               ""
               "#include ""scoMemoryScope.h"""
               "#include ""scoWindowScope.h"""
               "#include ""scoMisc.h"""
               "#include ""scoGetProperty.h"""
               "#include ""scoSetProperty.h"""
               "#include ""scicos_block4.h"""
               ""
               "/** \fn bouncexy_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "    \brief Function to draw or redraw the window"
               "*/"
               "void bouncexy_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "{"
               "  scoGraphicalObject pAxes;"
               "  scoGraphicalObject pTemp;"
               "  double * z;"
               "  double *rpar;"
               "  int *ipar, nipar;  "
               "  int i,j;"
               "  int dimension;"
               "  double ymin, ymax, xmin, xmax;"
               "  int win;"
               "  int number_of_subwin;"
               "  int number_of_curves_by_subwin;"
               "  int * colors;"
               "  int imode;"
               "  double * size_balls;"
               "  double radius_max;"
               ""
               "  /*Retrieving Parameters*/"
               "  rpar = GetRparPtrs(block);"
               "  ipar = GetIparPtrs(block);"
               "  nipar = GetNipar(block);"
               "  win = ipar[0];"
               "  if (win == -1)"
               "    {"
               "      win = 20000 + get_block_number() ; "
               "    }"
               "  dimension = 2;"
               "  imode = ipar[1];"
               "  number_of_curves_by_subwin = GetInPortRows(block,1);"
               "  radius_max = 0;"
               "  size_balls = (double*)scicos_malloc(number_of_curves_by_subwin*sizeof(double));"
               "  z = GetDstate(block);"
               "  for(i = 0 ; i < number_of_curves_by_subwin ; i++)"
               "    {"
               "      size_balls[i] = z[6*i+2];"
               "      if(radius_max < size_balls[i])"
               "        {"
               "          radius_max = size_balls[i];"
               "        }"
               "    }"
               "  number_of_subwin = 1;"
               "  xmin = rpar[0];"
               "  xmax = rpar[1];"
               "  ymin = rpar[2];"
               "  ymax = rpar[3];"
               "  colors = (int*)scicos_malloc(number_of_curves_by_subwin*sizeof(int));"
               "  for(i = 0 ; i < number_of_curves_by_subwin ; i++)"
               "    {"
               "      colors[i] = ipar[i+2];"
               "    }"
               "  if(firstdraw == 1)"
               "    {"
               "      /*Allocating memory*/"
               "      scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, &number_of_curves_by_subwin);"
               "    }"
               "  /*Creating the Scope*/"
               "  scoInitOfWindow(*pScopeMemory, dimension, win, NULL, NULL, &xmin, &xmax, &ymin, &ymax, NULL, NULL);"
               "  if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "    {"
               "  pTemp = scoGetPointerScopeWindow(*pScopeMemory);"
               "  pAxes = scoGetPointerAxes(*pScopeMemory,0);"
               ""
               "  pSUBWIN_FEATURE(pAxes)->isoview = TRUE;"
               ""
               "  (pSUBWIN_FEATURE(pAxes)->axes).axes_visible[0] = FALSE;"
               "  (pSUBWIN_FEATURE(pAxes)->axes).axes_visible[1] = FALSE;"
               ""
               "  sciSetIsBoxed(pAxes, FALSE);"
               ""
               "  pFIGURE_FEATURE(pTemp)->pixmap = 1;"
               "  pFIGURE_FEATURE(pTemp)->wshow = 1;"
               ""
               "  for(j = 0 ; j < number_of_curves_by_subwin ; j++)"
               "    {"
               "      scoAddSphereForShortDraw(*pScopeMemory, 0, j, size_balls[j], colors[j]);"
               "    }"
               "  scoAddRectangleForLongDraw(*pScopeMemory,0,0,xmin,(ymax-fabs(ymin)),fabs(xmax-xmin),fabs(ymax-ymin));"
               "  sciDrawObj(scoGetPointerLongDraw(*pScopeMemory,0,0));"
               "    }"
               "  scicos_free(colors);"
               "  scicos_free(size_balls);"
               ""
               "}"
               ""
               "/** \fn void bouncexy(scicos_block * block,int flag)"
               "    \brief the computational function"
               "    \param block A pointer to a scicos_block"
               "    \param flag An integer which indicates the state of the block (init, update, ending)"
               "*/"
               "void bouncexy(scicos_block * block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  ScopeMemory * pScopeMemory;"
               "  scoGraphicalObject pShortDraw;"
               "  scoGraphicalObject pLongDraw;"
               "  double * z;"
               "  double t;"
               "  int i;"
               "  double * u1, *u2;"
               "  double * size_balls;"
               "  int **user_data_ptr,*size_ptr;"
               ""
               "  switch(flag)"
               "  {"
               "   case Initialization:"
               "   {"
               "     bouncexy_draw(block,&pScopeMemory,1);"
               "     break;"
               "   }"
               ""
               "   case StateUpdate:"
               "   {"
               "     /*Retreiving Scope in the _work*/"
               "     scoRetrieveScopeMemory(_work,&pScopeMemory);"
               "     if(scoGetScopeActivation(pScopeMemory) == 1) {"
               "       t = get_scicos_time();"
               "       /*If window has been destroyed we recreate it*/"
               "       if(scoGetPointerScopeWindow(pScopeMemory) == NULL) {"
               "         bouncexy_draw(block,&pScopeMemory,0);"
               "       }"
               ""
               "       //Cannot be factorized depends of the scope"
               "       size_balls = (double*)scicos_malloc(scoGetNumberOfCurvesBySubwin(pScopeMemory,0)*sizeof(double));"
               "       z = GetDstate(block);"
               "       for(i = 0 ; i < scoGetNumberOfCurvesBySubwin(pScopeMemory,0) ; i++) {"
               "         size_balls[i] = z[6*i+2];"
               "       }"
               "       u1 = GetRealInPortPtrs(block,1);"
               "       u2 = GetRealInPortPtrs(block,2);"
               "       for (i = 0 ; i < scoGetNumberOfCurvesBySubwin(pScopeMemory,0) ; i++) {"
               "         pShortDraw  = scoGetPointerShortDraw(pScopeMemory,0,i);"
               "         pLongDraw  = scoGetPointerLongDraw(pScopeMemory,0,i);"
               "         pARC_FEATURE(pShortDraw)->x = u1[i]-size_balls[i]/2;"
               "         pARC_FEATURE(pShortDraw)->y = u2[i]+size_balls[i]/2;"
               "       }"
               ""
               "       sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "       if(pFIGURE_FEATURE(scoGetPointerScopeWindow(pScopeMemory))->pixmap == 1) {"
               "         C2F(dr)(""xset"",""wshow"",PI0,PI0,PI0,PI0,PI0,PI0,PD0,PD0,PD0,PD0,0L,0L);"
               "         sciDrawObj(scoGetPointerScopeWindow(pScopeMemory));"
               "       }"
               "       else {"
               "         sciDrawObj(scoGetPointerScopeWindow(pScopeMemory));"
               "       }"
               "       scicos_free(size_balls);"
               "     }"
               "     break;"
               "   }"
               ""
               "   case Ending:"
               "   {"
               "     scoRetrieveScopeMemory(_work, &pScopeMemory);"
               "     if(scoGetScopeActivation(pScopeMemory) == 1) {"
               "       if(scoGetPointerScopeWindow(pScopeMemory) != NULL) {"
               "         sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "         pShortDraw = sciGetCurrentFigure();"
               "         sciGetPointerToUserData (pShortDraw,&user_data_ptr, &size_ptr);"
               "         FREE(*user_data_ptr);"
               "         *user_data_ptr=NULL;"
               "         *size_ptr = 0;"
               "       }"
               "     }"
               "     scoFreeScopeMemory(_work, &pScopeMemory);"
               "     break;"
               "   }"
               "  }"
               "}"]

      case 'canimxy' then
        txt = ["/**"
               "   \file canimxy.c"
               "   \author Benoit Bayol"
               "   \version 1.0"
               "   \date September 2006 - January 2007"
               "   \brief CANIMXY is a scope in 2D which draw its input as a XY scope, there is animation."
               "   \see CANIMXY.sci in macros/scicos_blocks/Sinks/"
               "*/"
               ""
               "#include ""scoMemoryScope.h"""
               "#include ""scoWindowScope.h"""
               "#include ""scoMisc.h"""
               "#include ""scoGetProperty.h"""
               "#include ""scoSetProperty.h"""
               "#include ""scicos_block4.h"""
               ""
               "/** \fn canimxy_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "    \brief Function to draw or redraw the window"
               "*/"
               "void canimxy_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "{"
               "  /* Declarations*/"
               "  int i;"
               "  int gomme_color; //As usual"
               "  int * ipar; //Integer Parameters"
               "  int color_flag; //Flag on Color"
               "  int color[2];"
               "  int line_size;"
               "  int animed;"
               "  int win; //Windows ID : To give a name to the window"
               "  int buffer_size; //Buffer Size"
               "  int win_pos[2]; //Position of the Window"
               "  int win_dim[2]; //Dimension of the Window"
               "  int nipar;"
               "  double * rpar; //Reals parameters"
               "  double xmin, xmax, ymin, ymax; //Ymin and Ymax are vectors here"
               "  scoGraphicalObject Pinceau; //Pointer to each polyline of each axes"
               "  scoGraphicalObject Gomme; //Pointer to each polyline of each axes"
               "  scoGraphicalObject Trait; //Pointer to each trache of each axes"
               "  int number_of_subwin;"
               "  int number_of_curves_by_subwin;"
               "  int dimension = 2;"
               "  int nbr_curves;"
               "  char *label;"
               ""
               "  /*Retrieving Parameters*/"
               "  ipar = GetIparPtrs(block);"
               "  nipar = GetNipar(block);"
               "  rpar = GetRparPtrs(block);"
               "  win = ipar[0];"
               "  color_flag = ipar[1];"
               "  buffer_size = ipar[2];"
               "  color[0] = ipar[3];"
               "  color[1] = ipar[3];"
               "  line_size = ipar[4];"
               "  animed = ipar[5];"
               "  win_pos[0] = ipar[6];"
               "  win_pos[1] = ipar[7];"
               "  win_dim[0] = ipar[8];"
               "  win_dim[1] = ipar[9];"
               "  nbr_curves = ipar[10];"
               "  xmin = rpar[0];"
               "  xmax = rpar[1];"
               "  ymin = rpar[2];"
               "  ymax = rpar[3];"
               "  label = GetLabelPtrs(block);"
               "  number_of_subwin = 1;"
               ""
               "  /* If only one element to draw*/"
               "  if (buffer_size == 1)"
               "    {"
               "      number_of_curves_by_subwin = nbr_curves;"
               "      if(firstdraw == 1)"
               "        {"
               "          scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, &number_of_curves_by_subwin);"
               "          scoSetShortDrawSize(*pScopeMemory,0,1);"
               "          scoSetLongDrawSize(*pScopeMemory,0,0);"
               "        }"
               "      scoInitOfWindow(*pScopeMemory, dimension, win, win_pos, win_dim, &xmin, &xmax, &ymin, &ymax, NULL, NULL);"
               "      if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "        {"
               ""
               "          pFIGURE_FEATURE(scoGetPointerScopeWindow(*pScopeMemory))->pixmap = 1;"
               "          pFIGURE_FEATURE(scoGetPointerScopeWindow(*pScopeMemory))->wshow = 1;"
               ""
               ""
               "          for(i = 0 ; i < scoGetNumberOfCurvesBySubwin(*pScopeMemory, 0) ; i++)"
               "            {"
               "              scoAddPolylineForShortDraw(*pScopeMemory,0,i,color[0]);"
               "              Pinceau = scoGetPointerShortDraw(*pScopeMemory,0,i);"
               "              pPOLYLINE_FEATURE(Pinceau)->n1 = 1;"
               "              sciSetMarkSize(Pinceau, line_size);"
               ""
               "            }"
               "        }"
               "    }"
               "  /*else if 2 or more elements*/"
               "  else"
               "    {"
               "      number_of_curves_by_subwin = 2*nbr_curves; //it is a trick to recognize the type of scope, not sure it is a good way because normally a curve is the combination of a short and a longdraw"
               "      if(firstdraw == 1)"
               "        {"
               "          scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, &number_of_curves_by_subwin);"
               "        }"
               ""
               "      scoInitOfWindow(*pScopeMemory, dimension, win, win_pos, win_dim, &xmin, &xmax, &ymin, &ymax, NULL, NULL);"
               "      if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "        {"
               "          gomme_color = sciGetBackground(scoGetPointerAxes(*pScopeMemory,0));"
               "          //sciSetIsBoxed(scoGetPointerAxes(*pScopeMemory,0),FALSE);"
               "          /*if mark style*/"
               "          if(color[0] <= 0)"
               "            {"
               "              if(firstdraw == 1)"
               "                {"
               "                  scoSetShortDrawSize(*pScopeMemory,0,1);"
               "                  scoSetLongDrawSize(*pScopeMemory,0,buffer_size-1);"
               "                }"
               "              for(i = 0 ; i < nbr_curves ; i++)"
               "                {"
               "                  //because of color[0] is negative it will add a black mark with style number color[0]"
               "                  scoAddPolylineForShortDraw(*pScopeMemory,0,i,color[0]);"
               "                  scoAddPolylineForShortDraw(*pScopeMemory,0,i+nbr_curves,color[0]); //same type of mark and black for the rubber"
               "                  scoAddPolylineForLongDraw(*pScopeMemory,0,i,color[0]);"
               "                    "
               "                  Pinceau = scoGetPointerShortDraw(*pScopeMemory,0,i);"
               "                  Gomme = scoGetPointerShortDraw(*pScopeMemory,0,i+nbr_curves);"
               "                  Trait = scoGetPointerLongDraw(*pScopeMemory,0,i);"
               "                    "
               "                  pPOLYLINE_FEATURE(Pinceau)->n1 = 1;"
               "                  pPOLYLINE_FEATURE(Gomme)->n1 = 1;"
               "                  sciSetMarkForeground(Gomme, gomme_color); //here the rubber becomes colored like the background of the axes"
               "                  pPOLYLINE_FEATURE(Trait)->n1 = buffer_size-1;"
               ""
               "                  sciSetMarkSize(Pinceau, line_size);"
               "                  sciSetMarkSize(Gomme, line_size);"
               "                  sciSetMarkSize(Trait, line_size);"
               "                }"
               "            }"
               "          /*if line style*/"
               "          else"
               "            {"
               "              if(firstdraw == 1)"
               "                {"
               "                  scoSetShortDrawSize(*pScopeMemory,0,2);"
               "                  scoSetLongDrawSize(*pScopeMemory,0,buffer_size-1);"
               "                }               "
               "              for(i = 0 ; i < nbr_curves ; i++)"
               "                {"
               "                  scoAddPolylineForShortDraw(*pScopeMemory,0,i,color[0]);"
               "                  scoAddPolylineForShortDraw(*pScopeMemory,0,i+nbr_curves,gomme_color);"
               "                  scoAddPolylineForLongDraw(*pScopeMemory,0,i,color[0]);"
               "                    "
               "                  Pinceau = scoGetPointerShortDraw(*pScopeMemory,0,i);"
               "                  Gomme = scoGetPointerShortDraw(*pScopeMemory,0,i+nbr_curves);"
               "                  Trait = scoGetPointerLongDraw(*pScopeMemory,0,i);"
               "                    "
               "                  pPOLYLINE_FEATURE(Pinceau)->n1 = 2;"
               "                  pPOLYLINE_FEATURE(Gomme)->n1 = 2;"
               "                  pPOLYLINE_FEATURE(Trait)->n1 = buffer_size-1;"
               ""
               "                  sciSetLineWidth(Pinceau, line_size);"
               "                  sciSetLineWidth(Gomme, line_size);"
               "                  sciSetLineWidth(Trait, line_size);"
               "                }"
               "            }"
               "        }"
               "    }"
               "  if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "    {"
               "      scoAddTitlesScope(*pScopeMemory,label,""x"",""y"",NULL);"
               "    }"
               "}"
               ""
               "/** \fn void canimxy(scicos_block * block, int flag)"
               "    \brief the computational function"
               "    \param block A pointer to a scicos_block"
               "    \param flag An integer which indicates the state of the block (init, update, ending)"
               "*/"
               "void canimxy(scicos_block * block, int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  /*Declarations*/"
               "  ScopeMemory * pScopeMemory;"
               "  double *u1,*u2;"
               "  scoGraphicalObject pShortDraw;"
               "  int **user_data_ptr,*size_ptr;"
               "  /* State Machine Control */"
               "  switch(flag)"
               "    {"
               "    case Initialization:"
               "      { "
               "        canimxy_draw(block,&pScopeMemory,1);"
               "        break; //Break of the switch condition don t forget it"
               "      } //End of Initialization"
               ""
               "    case StateUpdate:"
               "      {"
               "        scoRetrieveScopeMemory(_work,&pScopeMemory);"
               "        if (scoGetPointerScopeWindow(pScopeMemory) == NULL) return;"
               "        if(scoGetScopeActivation(pScopeMemory) == 1)"
               "          {"
               ""
               "            /* Charging Elements */"
               ""
               "            /*Retrieve Elements*/"
               "            u1 = GetRealInPortPtrs(block,1);"
               "            u2 = GetRealInPortPtrs(block,2);"
               ""
               "            scoDrawScopeAnimXYStyle(pScopeMemory,u1,u2,NULL);"
               "          }"
               "        break; //Break of the switch don t forget it !"
               "      }//End of stateupdate"
               "      "
               "      //This case is activated when the simulation is done or when we close scicos"
               "    case Ending:"
               "      {"
               "        scoRetrieveScopeMemory(_work, &pScopeMemory);"
               "        if(scoGetScopeActivation(pScopeMemory) == 1) {"
               "          if(scoGetPointerScopeWindow(pScopeMemory) != NULL) {"
               "            sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "            pShortDraw = sciGetCurrentFigure();"
               "            sciGetPointerToUserData (pShortDraw,&user_data_ptr, &size_ptr);"
               "            FREE(*user_data_ptr);"
               "            *user_data_ptr=NULL;"
               "            *size_ptr = 0;"
               "          }"
               "        }"
               "        scoFreeScopeMemory(_work, &pScopeMemory);"
               "        break; //Break of the switch"
               "      }"
               "      //free the memory which is allocated at each turn by some variables"
               " "
               "    }"
               "}"]

      case 'canimxy3d' then
        txt = ["/**"
               "   \file canimxy3d.c"
               "   \author Benoit Bayol"
               "   \version 1.0"
               "   \date September 2006 - January 2007"
               "   \brief CANIMXY3D is a scope in 3D which draw its input as a XY scope, there is animation."
               "   \see CANIMXY3D.sci in macros/scicos_blocks/Sinks/"
               "*/"
               ""
               "#include ""scoMemoryScope.h"""
               "#include ""scoWindowScope.h"""
               "#include ""scoMisc.h"""
               "#include ""scoGetProperty.h"""
               "#include ""scoSetProperty.h"""
               "#include ""scicos_block4.h"""
               ""
               "/** \fn canimxy3d_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "    \brief Function to draw or redraw the window"
               "*/"
               "void canimxy3d_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "{"
               "  int i; //As usual"
               "  int * ipar; //Integer Parameters"
               "  int color_number; //Flag on Color"
               "  int * color;"
               "  int * line_size;"
               "  int nbr_curves;"
               "  int animed;"
               "  int win; //Windows ID : To give a name to the window"
               "  int buffer_size; //Buffer Size"
               "  int win_pos[2]; //Position of the Window"
               "  int win_dim[2]; //Dimension of the Window"
               "  int nipar;"
               "  double * rpar; //Reals parameters"
               "  double xmin, xmax, ymin, ymax, zmin, zmax,alpha,theta; //Ymin and Ymax are vectors here"
               "  scoGraphicalObject Pinceau; //Pointer to each polyline of each axes"
               "  scoGraphicalObject Gomme; //Pointer to each polyline of each axes"
               "  scoGraphicalObject Trait; //Pointer to each trache of each axes"
               "  int number_of_subwin;"
               "  int number_of_curves_by_subwin;"
               "  int dimension = 3;"
               "  int gomme_color;"
               "  int size=0;"
               "  char *label;"
               ""
               "  /*Retrieving Parameters*/"
               "  ipar = GetIparPtrs(block);"
               "  nipar = GetNipar(block);"
               "  rpar = GetRparPtrs(block);"
               "  win = ipar[0];"
               "  color_number = ipar[1];"
               "  buffer_size = ipar[2];"
               "  label = GetLabelPtrs(block);"
               ""
               "  color = (int*)scicos_malloc(color_number*sizeof(int));"
               "  line_size = (int*)scicos_malloc(color_number*sizeof(int));"
               "  for(i = 0 ; i < color_number ; i++)"
               "    {"
               "      color[i] = ipar[i+3];"
               "      line_size[i] = ipar[i+3+color_number];"
               "    }"
               "  size = 2*color_number;"
               "  animed = ipar[size+3];"
               "  win_pos[0] = ipar[size+4];"
               "  win_pos[1] = ipar[size+5];"
               "  win_dim[0] = ipar[size+6];"
               "  win_dim[1] = ipar[size+7];"
               "  xmin = rpar[0];"
               "  xmax = rpar[1];"
               "  ymin = rpar[2];"
               "  ymax = rpar[3];"
               "  zmin = rpar[4];"
               "  zmax = rpar[5];"
               "  alpha = rpar[6];"
               "  theta = rpar[7];"
               "  number_of_subwin = 1;"
               "  nbr_curves = ipar[size+8];"
               ""
               ""
               "  /* If only one element to draw*/"
               "  if (buffer_size == 1)"
               "    {"
               "      number_of_curves_by_subwin = nbr_curves;"
               "      if(firstdraw == 1)"
               "        {"
               "          scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, &number_of_curves_by_subwin);"
               "          scoSetShortDrawSize(*pScopeMemory,0,1);"
               "          scoSetLongDrawSize(*pScopeMemory,0,0);"
               "        }"
               ""
               "      scoInitOfWindow(*pScopeMemory, dimension, win, win_pos, win_dim, &xmin, &xmax, &ymin, &ymax, &zmin, &zmax);"
               "      if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "        { "
               "          pFIGURE_FEATURE(scoGetPointerScopeWindow(*pScopeMemory))->pixmap = 1;"
               "          pFIGURE_FEATURE(scoGetPointerScopeWindow(*pScopeMemory))->wshow = 1;"
               ""
               "          for(i = 0 ; i < scoGetNumberOfCurvesBySubwin(*pScopeMemory, 0) ; i++)"
               "            {"
               "              scoAddPolylineForShortDraw(*pScopeMemory,0,i,color[i]);"
               "              Pinceau = scoGetPointerShortDraw(*pScopeMemory,0,i);"
               ""
               "              sciSetMarkSize(Pinceau, line_size[i]);"
               ""
               "              pPOLYLINE_FEATURE(Pinceau)->n1 = 1;"
               "            }"
               "        }"
               "    }"
               "  /*else if 2 or more elements*/"
               "  else"
               "    {"
               "      number_of_curves_by_subwin = 2*nbr_curves; //it is a trick to recognize the type of scope, not sure it is a good way because normally a curve is the combination of a short and a longdraw"
               "      if(firstdraw == 1)"
               "        {"
               "          scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, &number_of_curves_by_subwin);"
               "        }"
               "      scoInitOfWindow(*pScopeMemory, dimension, win, win_pos, win_dim, &xmin, &xmax, &ymin, &ymax, &zmin, &zmax);"
               "      if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "        {"
               "          gomme_color = sciGetBackground(scoGetPointerAxes(*pScopeMemory,0));"
               ""
               "          if(firstdraw == 1) {"
               "            scoSetShortDrawSize(*pScopeMemory,0,2);"
               "            scoSetLongDrawSize(*pScopeMemory,0,buffer_size);"
               "          }"
               ""
               "          for(i = 0 ; i < nbr_curves ; i++) {"
               "            /*if mark style*/"
               "            if (color[i]<=0) {"
               "              //because of color[0] is negative it will add a black mark with style number color[0]"
               "              scoAddPolylineForShortDraw(*pScopeMemory,0,i,color[i]);"
               "              scoAddPolylineForShortDraw(*pScopeMemory,0,i+nbr_curves,color[i]); //same type of mark and black for the rubber"
               "              scoAddPolylineForLongDraw(*pScopeMemory,0,i,color[i]);"
               ""
               "              Pinceau = scoGetPointerShortDraw(*pScopeMemory,0,i);"
               "              Gomme = scoGetPointerShortDraw(*pScopeMemory,0,i+nbr_curves);"
               "              Trait = scoGetPointerLongDraw(*pScopeMemory,0,i);"
               ""
               "              sciSetMarkSize(Pinceau, line_size[i]);"
               "              sciSetMarkSize(Gomme, line_size[i]);"
               "              sciSetMarkSize(Trait, line_size[i]);"
               ""
               "              pPOLYLINE_FEATURE(Pinceau)->n1 = 1;"
               "              pPOLYLINE_FEATURE(Gomme)->n1 = 1;"
               "              sciSetMarkForeground(Gomme, gomme_color); //here the rubber becomes colored like the background of the axes"
               "              pPOLYLINE_FEATURE(Trait)->n1 = buffer_size-1;"
               "            }"
               "            /*if line style*/"
               "            else {"
               "              scoAddPolylineForShortDraw(*pScopeMemory,0,i,color[i]);"
               "              scoAddPolylineForShortDraw(*pScopeMemory,0,i+nbr_curves,gomme_color);"
               "              scoAddPolylineForLongDraw(*pScopeMemory,0,i,color[i]);"
               ""
               "              Pinceau = scoGetPointerShortDraw(*pScopeMemory,0,i);"
               "              Gomme = scoGetPointerShortDraw(*pScopeMemory,0,i+nbr_curves);"
               "              Trait = scoGetPointerLongDraw(*pScopeMemory,0,i);"
               ""
               "              sciSetLineWidth(Pinceau, line_size[i]);"
               "              sciSetLineWidth(Gomme, line_size[i]);"
               "              sciSetLineWidth(Trait, line_size[i]);"
               ""
               "              pPOLYLINE_FEATURE(Pinceau)->n1 = 2;"
               "              pPOLYLINE_FEATURE(Gomme)->n1 = 2;"
               "              pPOLYLINE_FEATURE(Trait)->n1 = buffer_size;"
               "            }"
               "          }"
               ""
               "        }"
               "    }"
               "  if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "    {"
               "      pSUBWIN_FEATURE(scoGetPointerAxes(*pScopeMemory,0))->alpha = alpha;"
               "      pSUBWIN_FEATURE(scoGetPointerAxes(*pScopeMemory,0))->theta = theta;"
               ""
               "      scoAddTitlesScope(*pScopeMemory,label,""x"",""y"",""z"");"
               "    }"
               "  scicos_free(color);"
               "  scicos_free(line_size);"
               "}"
               "/** \fn void canimxy3d(scicos_block * block, int flag)"
               "    \brief the computational function"
               "    \param block A pointer to a scicos_block"
               "    \param flag An integer which indicates the state of the block (init, update, ending)"
               "*/"
               "void canimxy3d(scicos_block * block, int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  /* Declarations*/"
               "  double *u1,*u2,*u3;"
               "  ScopeMemory * pScopeMemory;"
               "  scoGraphicalObject pShortDraw;"
               "  int **user_data_ptr,*size_ptr;"
               ""
               "  /* State Machine Control */"
               "  switch(flag)"
               "    {"
               "    case Initialization:"
               "      { "
               "        "
               "        canimxy3d_draw(block,&pScopeMemory,1);"
               "        break; //Break of the switch condition don t forget it"
               "      } //End of Initialization"
               ""
               "    case StateUpdate:"
               "      {"
               "        scoRetrieveScopeMemory(_work,&pScopeMemory);"
               "        if (scoGetPointerScopeWindow(pScopeMemory) == NULL) return;"
               "        if(scoGetScopeActivation(pScopeMemory) == 1)"
               "          {"
               "            /* Charging Elements */"
               ""
               "        /*Retrieve Elements*/"
               "        u1 = GetRealInPortPtrs(block,1);"
               "        u2 = GetRealInPortPtrs(block,2);"
               "        u3 = GetRealInPortPtrs(block,3);"
               ""
               "        scoDrawScopeAnimXYStyle(pScopeMemory,u1,u2,u3);"
               "          }"
               "        break; //Break of the switch don t forget it !"
               "      }//End of stateupdate"
               "      "
               "      //This case is activated when the simulation is done or when we close scicos"
               "    case Ending:"
               "      {"
               "        scoRetrieveScopeMemory(_work, &pScopeMemory);"
               "        if(scoGetScopeActivation(pScopeMemory) == 1) {"
               "          if(scoGetPointerScopeWindow(pScopeMemory) != NULL) {"
               "            sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "            pShortDraw = sciGetCurrentFigure();"
               "            sciGetPointerToUserData (pShortDraw,&user_data_ptr, &size_ptr);"
               "            FREE(*user_data_ptr);"
               "            *user_data_ptr=NULL;"
               "            *size_ptr = 0;"
               "          }"
               "        }"
               "        scoFreeScopeMemory(_work, &pScopeMemory);"
               "        break; //Break of the switch"
               "      }"
               "      //free the memory which is allocated at each turn by some variables"
               " "
               "    }"
               "}"]

      case 'cevscpe' then
        txt = ["/**"
               "   \file cevscpe.c"
               "   \author Benoit Bayol"
               "   \version 1.0"
               "   \date September 2006 - January 2007"
               "   \brief CEVSCPE is a scope that indicates when the clocks is activated"
               "   \see CEVENTSCOPE.sci in macros/scicos_blocks/Sinks/"
               "*/"
               ""
               "#include ""scoMemoryScope.h"""
               "#include ""scoWindowScope.h"""
               "#include ""scoMisc.h"""
               "#include ""scoGetProperty.h"""
               "#include ""scoSetProperty.h"""
               "#include ""scicos_block4.h"""
               ""
               "/** \fn cscopxy_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "    \brief Function to draw or redraw the window"
               "*/"
               "void cevscpe_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "{"
               "  /* Declarations */"
               ""
               "  int nipar; //Number of elements in ipar vector"
               "  int i; //As usual"
               "  int * ipar;"
               "  double * rpar; //Integer Parameter"
               "  int nbr_colors; //Number of colors and lines IS ALSO number of channels"
               "  int win; //To give a name to the window"
               "  int color_flag; //0/1 color flag -- NOT USED"
               "  int  * colors; //Begin at ipar[2] and has a measure of 8 max"
               "  int dimension = 2;"
               "  double period; //Refresh Period of the scope is a vector here"
               "  int number_of_subwin;"
               "  int number_of_curves_by_subwin;"
               "  double xmin, xmax, ymin, ymax;"
               "  int win_pos[2], win_dim[2];"
               "  char *label;"
               ""
               "  /* Initialization */"
               "  ipar =  GetIparPtrs(block);"
               "  win = ipar[0];"
               "  color_flag = ipar[1]; /*not used*/"
               "  rpar = GetRparPtrs(block);"
               "  period = rpar[0];"
               "  nipar = GetNipar(block);"
               "  label = GetLabelPtrs(block);"
               "  nbr_colors = nipar-6;"
               "  colors=(int*)scicos_malloc(nbr_colors*sizeof(int));"
               "  for( i = 2 ; i < nbr_colors+2 ; i++)"
               "    {"
               "      colors[i-2] = ipar[i];"
               "    }"
               ""
               "  number_of_subwin = 1;"
               "  number_of_curves_by_subwin = nbr_colors;"
               ""
               "  ymin = 0;"
               "  ymax = 1;"
               ""
               "  win_pos[0] = ipar[(nipar-1) - 3];"
               "  win_pos[1] = ipar[(nipar-1) - 2];"
               "  win_dim[0] = ipar[(nipar-1) - 1];"
               "  win_dim[1] = ipar[nipar-1];"
               ""
               "  if(firstdraw == 1)"
               "    {"
               "      scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, &number_of_curves_by_subwin);"
               "      scoSetLongDrawSize(*pScopeMemory,0,5000);"
               "      scoSetShortDrawSize(*pScopeMemory,0,1);"
               "      scoSetPeriod(*pScopeMemory,0,period);"
               "    }"
               ""
               "  xmin = period*scoGetPeriodCounter(*pScopeMemory,0);"
               "  xmax = period*(scoGetPeriodCounter(*pScopeMemory,0)+1);"
               ""
               "  scoInitOfWindow(*pScopeMemory, dimension, win, win_pos, win_dim, &xmin, &xmax, &ymin, &ymax, NULL, NULL);"
               "  if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "    {"
               "      scoAddTitlesScope(*pScopeMemory,label,""t"",""y"",NULL);"
               "      scoAddCoupleOfSegments(*pScopeMemory,colors);"
               "    }"
               "  scicos_free(colors);"
               "}"
               ""
               "/** \fn void cevscpe(scicos_block * block, int flag)"
               "    \brief the computational function"
               "    \param block A pointer to a scicos_block"
               "    \param flag An integer which indicates the state of the block (init, update, ending)"
               "*/"
               "void cevscpe(scicos_block * block, int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  ScopeMemory * pScopeMemory;"
               "  int nbseg = 0;"
               "  int tab[20];"
               "  scoGraphicalObject pShortDraw;"
               "  int i;"
               "  double t;"
               "  int **user_data_ptr,*size_ptr;"
               ""
               "  switch(flag)"
               "    {"
               "    case Initialization:"
               "      {"
               "        cevscpe_draw(block,&pScopeMemory,1);"
               "        break;"
               "      }"
               ""
               "    case StateUpdate:"
               "      {"
               ""
               "        /* Charging elements */"
               "        scoRetrieveScopeMemory(_work,&pScopeMemory);"
               "        if(scoGetPointerScopeWindow(pScopeMemory) == NULL) return;"
               "        if(scoGetScopeActivation(pScopeMemory) == 1)"
               "          {"
               "            t = get_scicos_time();"
               ""
               "            scoRefreshDataBoundsX(pScopeMemory,t);"
               "        "
               "            /*Not Factorize*/"
               ""
               "            for(i = 0 ; i < scoGetNumberOfCurvesBySubwin(pScopeMemory,0) ; i++)"
               "              {"
               "                if((GetNevIn(block)&(1<<i))==(1<<i))"
               "                  {"
               "                    tab[nbseg]=i;"
               "                    nbseg++;"
               "                  }"
               "              }"
               ""
               "            for(i = 0 ; i < nbseg ; i++)"
               "              {"
               "                pShortDraw = scoGetPointerShortDraw(pScopeMemory,0,tab[i]);"
               "                pSEGS_FEATURE(pShortDraw)->vx[0] = t;"
               "                pSEGS_FEATURE(pShortDraw)->vx[1] = t;"
               "                pSEGS_FEATURE(pShortDraw)->vy[0] = i*0.8/nbseg;"
               "                pSEGS_FEATURE(pShortDraw)->vy[1] = (i+1)*0.8/nbseg;"
               "                pSEGS_FEATURE(pShortDraw)->Nbr1 = 2;"
               "                pSEGS_FEATURE(pShortDraw)->Nbr2 = 2;"
               "              }"
               "            /*End of Not Factorize*/"
               "            scoDrawScopeAmplitudeTimeStyle(pScopeMemory,t);"
               "          }"
               "        break;"
               "      }"
               ""
               "    case Ending:"
               "      {"
               "        scoRetrieveScopeMemory(_work, &pScopeMemory);"
               "        if(scoGetScopeActivation(pScopeMemory) == 1) {"
               "          if(scoGetPointerScopeWindow(pScopeMemory) != NULL) {"
               "            sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "            pShortDraw = sciGetCurrentFigure();"
               "            sciGetPointerToUserData (pShortDraw,&user_data_ptr, &size_ptr);"
               "            FREE(*user_data_ptr);"
               "            *user_data_ptr=NULL;"
               "            *size_ptr = 0;"
               "            scoDelCoupleOfSegments(pScopeMemory);"
               "          }"
               "        }"
               "        scoFreeScopeMemory(_work,&pScopeMemory);"
               "        break;"
               "      }"
               "    }"
               "}"]

      case 'cfscope' then
        txt = ["/**"
               "   \file cfscope.c"
               "   \author Benoit Bayol"
               "   \version 1.0"
               "   \date September 2006 - January 2007"
               "   \brief CFSCOPE This scope has no input port because it displays the values on the designated link"
               "   \see CFSCOPE.sci in macros/scicos_blocks/Sinks/"
               "*/"
               ""
               "#include ""scoMemoryScope.h"""
               "#include ""scoWindowScope.h"""
               "#include ""scoMisc.h"""
               "#include ""scoGetProperty.h"""
               "#include ""scoSetProperty.h"""
               "#include ""scicos_block4.h"""
               ""
               "/** \fn cfscope_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "    \brief Function to draw or redraw the window"
               "*/"
               "void cfscope_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "{"
               ""
               "  double *rpar;"
               "  int *ipar, nipar;   "
               ""
               "  double period;"
               "  int i;"
               "  int dimension;"
               "  double ymin, ymax, xmin, xmax;"
               "  int buffer_size;"
               "  int win_pos[2];"
               "  int win_dim[2];"
               "  int win;"
               "  int number_of_subwin;"
               "  int number_of_curves_by_subwin;"
               "  double dt;"
               "  int nbr_of_curves;"
               "  int color_flag;"
               "  int * colors;"
               "  char *label;"
               ""
               "  /*Retrieving Parameters*/"
               "  rpar = GetRparPtrs(block);"
               "  ipar = GetIparPtrs(block);"
               "  nipar = GetNipar(block);"
               "  win = ipar[0];"
               "  color_flag = ipar[1];"
               "  buffer_size = ipar[2];"
               "  dt = rpar[0];"
               "  period = rpar[3];"
               "  ymin  = rpar[1];"
               "  ymax = rpar[2];"
               "  label = GetLabelPtrs(block);"
               ""
               "  dimension = 2;"
               "  win_pos[0] = ipar[11];"
               "  win_pos[1] = ipar[12];"
               "  win_dim[0] = ipar[13];"
               "  win_dim[1] = ipar[14];"
               "  number_of_curves_by_subwin = ipar[15]; //Here is not really what we will see i.e. if you give [2:9] there is 8 curves but in the kalman filter demo you will only see 6 curves (and 8 in the figure handle description) because only 6 are really existing."
               "  nbr_of_curves = number_of_curves_by_subwin;"
               "  number_of_subwin = 1;"
               ""
               "  colors=(int*)scicos_malloc(8*sizeof(int));"
               "  for( i = 3 ; i < 10 ; i++)"
               "    {"
               "      colors[i-3] = ipar[i];"
               "    }"
               ""
               "  /*Allocating memory*/"
               "  if(firstdraw == 1)"
               "    {"
               "      scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, &number_of_curves_by_subwin);"
               "      /*Must be placed before adding polyline or other elements*/"
               "      scoSetLongDrawSize(*pScopeMemory, 0, 5000);"
               "      scoSetShortDrawSize(*pScopeMemory,0,buffer_size);"
               "      scoSetPeriod(*pScopeMemory,0,period);"
               "    }"
               ""
               "  xmin = period*scoGetPeriodCounter(*pScopeMemory,0);"
               "  xmax = period*(scoGetPeriodCounter(*pScopeMemory,0)+1);"
               ""
               "  /*Creating the Scope*/"
               "  scoInitOfWindow(*pScopeMemory, dimension, win, win_pos, win_dim, &xmin, &xmax, &ymin, &ymax, NULL, NULL);"
               "  if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "    {"
               "      scoAddTitlesScope(*pScopeMemory,label,""t"",""y"",NULL);"
               "      "
               "  /*Add a couple of polyline : one for the shortdraw and one for the longdraw*/"
               "      scoAddCoupleOfPolylines(*pScopeMemory,colors);"
               "      scicos_free(colors);"
               "    }"
               "}"
               ""
               "extern int C2F(getouttb)();"
               "/** \fn void cfscope(scicos_block * block,int flag)"
               "    \brief the computational function"
               "    \param block A pointer to a scicos_block"
               "    \param flag An integer which indicates the state of the block (init, update, ending)"
               "*/"
               "void cfscope(scicos_block * block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  ScopeMemory * pScopeMemory;"
               "  scoGraphicalObject pShortDraw;"
               "  double * sortie;"
               "  int  *  index_of_view;"
               "  double t;"
               "  int nbr_of_curves;"
               "  int *ipar;"
               "  int i,j;"
               "  int NbrPtsShort;"
               "  int **user_data_ptr,*size_ptr;"
               ""
               "  switch(flag)"
               "    {"
               "    case Initialization:"
               "      {"
               "        /*Retrieving Parameters*/"
               "        cfscope_draw(block,&pScopeMemory,1);"
               "        break;"
               "      }"
               "    case StateUpdate:"
               "      { "
               "        "
               ""
               "        /*Retreiving Scope in the _work*/"
               "        scoRetrieveScopeMemory(_work,&pScopeMemory);"
               "        if(scoGetPointerScopeWindow(pScopeMemory) == NULL) return;"
               "        if(scoGetScopeActivation(pScopeMemory) == 1)"
               "          {"
               "            t = get_scicos_time();"
               "            /* If window has been destroyed we recreate it */"
               ""
               "        /*Maybe we are in the end of axes so we have to draw new ones */"
               "        scoRefreshDataBoundsX(pScopeMemory,t);"
               ""
               "        //Cannot be factorized depends of the scope"
               "        nbr_of_curves = scoGetNumberOfCurvesBySubwin(pScopeMemory,0);"
               ""
               "        ipar = GetIparPtrs(block);"
               "        sortie = (double*)scicos_malloc(nbr_of_curves*sizeof(double));"
               "        index_of_view =(int*)scicos_malloc(nbr_of_curves*sizeof(int));"
               "        for(i = 16 ; i < 16+nbr_of_curves ; i++)"
               "          {"
               "            index_of_view[i-16] = ipar[i];"
               "          }"
               ""
               "        C2F(getouttb)(&nbr_of_curves,index_of_view,sortie);"
               "        for(i = 0; i < scoGetNumberOfSubwin(pScopeMemory) ; i++)"
               "          {"
               "            for (j = 0; j < nbr_of_curves ; j++)"
               "              {"
               "                pShortDraw = scoGetPointerShortDraw(pScopeMemory,i,j);"
               "                NbrPtsShort = pPOLYLINE_FEATURE(pShortDraw)->n1;"
               "                pPOLYLINE_FEATURE(pShortDraw)->pvx[NbrPtsShort] = t;         // get time "
               "                pPOLYLINE_FEATURE(pShortDraw)->pvy[NbrPtsShort] = sortie[j]; // get value"
               "                pPOLYLINE_FEATURE(pShortDraw)->n1++;"
               "              }"
               "          }"
               "        //End of cannot"
               "        /*Main drawing function*/"
               "        scoDrawScopeAmplitudeTimeStyle(pScopeMemory, t);"
               "        "
               "        scicos_free(sortie);"
               "        scicos_free(index_of_view);"
               "          }"
               "        break;"
               "      }"
               "    case Ending:"
               "      {"
               "        scoRetrieveScopeMemory(_work, &pScopeMemory);"
               "        if(scoGetScopeActivation(pScopeMemory) == 1) {"
               "          if(scoGetPointerScopeWindow(pScopeMemory) != NULL) {"
               "            sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "            pShortDraw = sciGetCurrentFigure();"
               "            sciGetPointerToUserData (pShortDraw,&user_data_ptr, &size_ptr);"
               "            FREE(*user_data_ptr);"
               "            *user_data_ptr=NULL;"
               "            *size_ptr = 0;"
               "            scoDelCoupleOfSegments(pScopeMemory);"
               "          }"
               "        }"
               "        scoFreeScopeMemory(_work, &pScopeMemory);"
               "        break;  "
               "      }"
               "    }"
               "}"]

      case 'cmat3d' then
        txt = ["/**"
               "   \file cmat3d.c"
               "   \author Benoit Bayol"
               "   \version 1.0"
               "   \date September 2006 - January 2007"
               "   \brief CMAT3D is a scope which connect a matrix to a plot3d. Values of the matrix are the values at the nodes."
               "   \see CMAT3D.sci in macros/scicos_blocks/Sinks/"
               "*/"
               ""
               "#include ""scoMemoryScope.h"""
               "#include ""scoWindowScope.h"""
               "#include ""scoMisc.h"""
               "#include ""scoGetProperty.h"""
               "#include ""scoSetProperty.h"""
               "#include ""scicos_block4.h"""
               ""
               "/** \fn cmat3d_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "    \brief Function to draw or redraw the window"
               "*/"
               "void cmat3d_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "{"
               "  /*Declarations*/"
               "  int i; //As usual"
               "  int * ipar; //Integer Parameters"
               "  int win_pos[2]; //Position of the Window"
               "  int win_dim[2]; //Dimension of the Window"
               "  int dimension = 3;"
               "  double * rpar; //Reals parameters"
               "  double  ymin, ymax; //Ymin and Ymax are vectors here"
               "  double  xmin, xmax;"
               "  double zmin, zmax;"
               "  int number_of_curves_by_subwin;"
               "  int number_of_subwin;"
               "  double * mat;"
               "  int size_mat;"
               "  int size_in_x;"
               "  int size_in_y;"
               "  char *label;"
               "  scoGraphicalObject pShortDraw;"
               ""
               "  /*Retrieve parameters from the scicos_model() which has been created thanks to the interfacing function*/"
               "  rpar = GetRparPtrs(block);"
               "  ipar = GetIparPtrs(block);"
               ""
               "  number_of_subwin = 1;"
               ""
               "  win_pos[0] = -1;"
               "  win_pos[1] = -1;"
               "  win_dim[0] = -1;"
               "  win_dim[1] = -1;"
               ""
               "  size_mat = ipar[2];"
               "  mat = (double*)scicos_malloc(size_mat*sizeof(double));"
               "  for(i = 0 ; i < size_mat ; i++)"
               "    {"
               "      mat[i] = rpar[i];"
               "    }"
               "  size_in_x = GetInPortSize(block,1,1);"
               "  size_in_y = GetInPortSize(block,1,2);"
               "  if(ipar[3] == 1)"
               "    {"
               "      xmax = size_in_x;"
               "      xmin = 0;"
               "      ymax = size_in_y;"
               "      ymin = 0;"
               "    }"
               "  else"
               "    {"
               "      xmin = rpar[size_mat];"
               "      xmax = rpar[size_mat+1];"
               "      ymin = rpar[size_mat+2];"
               "      ymax = rpar[size_mat+3];"
               "    }"
               ""
               "  zmin = ipar[0];"
               "  zmax = ipar[1];"
               "  number_of_curves_by_subwin = 1;"
               "  label = GetLabelPtrs(block);"
               ""
               "  /*Allocating memory for scope only if the window has to be created and not redraw*/"
               "  if(firstdraw == 1)"
               "    {"
               "      scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, &number_of_curves_by_subwin);"
               "    }"
               ""
               "  /*Creating the Scope with axes*/"
               "  scoInitOfWindow(*pScopeMemory, dimension, -1, win_pos, win_dim, &xmin, &xmax, &ymin, &ymax, &zmin, &zmax);"
               "  if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "    {"
               "      /*Here we put the special window feature like pixmap or text title"
               "        Dont forget that the function scoAddTitleScope redraws the window at end so it would be a good idea to put it at the end*/"
               "      pFIGURE_FEATURE(scoGetPointerScopeWindow(*pScopeMemory))->pixmap = 1;"
               "      pFIGURE_FEATURE(scoGetPointerScopeWindow(*pScopeMemory))->wshow = 1;"
               ""
               "      sciSetColormap(scoGetPointerScopeWindow(*pScopeMemory), mat , size_mat/3, 3);"
               ""
               "      pSUBWIN_FEATURE(scoGetPointerAxes(*pScopeMemory,0))->alpha = 50;"
               "      pSUBWIN_FEATURE(scoGetPointerAxes(*pScopeMemory,0))->theta = 280;"
               "  "
               "      /*Adding graphic elements like plot3d or polyline and so*/"
               "      if(ipar[3] == 1)"
               "        {"
               "          scoAddPlot3dForShortDraw(*pScopeMemory,0,0,GetInPortSize(block,1,1),GetInPortSize(block,1,2));"
               "        }"
               "      else"
               "        {"
               "          double h_x,h_y;"
               "          scoAddPlot3dForShortDraw(*pScopeMemory,0,0,GetInPortSize(block,1,1),GetInPortSize(block,1,2));"
               "          pShortDraw = scoGetPointerShortDraw(*pScopeMemory,0,0);"
               "          h_x = fabs((xmax-xmin)/(GetInPortSize(block,1,1)-1));"
               "          h_y = fabs((ymax-ymin)/(GetInPortSize(block,1,2)-1));"
               "      "
               "          for(i = 0 ; i < size_in_x ; i++)"
               "            {"
               "              pSURFACE_FEATURE(pShortDraw)->pvecx[i] = xmin + i*h_x;"
               "            } "
               "          for(i = 0 ; i < size_in_y ; i++)"
               "            {"
               "              pSURFACE_FEATURE(pShortDraw)->pvecy[i] = ymin + i*h_y;"
               "            } "
               "        }"
               "      scoAddTitlesScope(*pScopeMemory,label,""x"",""y"",""z"");"
               "    }"
               "  /*Dont forget to free your scicos_malloc or MALLOC*/"
               "  scicos_free(mat);"
               ""
               "}"
               ""
               "/** \fn void cmat3d(scicos_block * block, int flag)"
               "    \brief the computational function"
               "    \param block A pointer to a scicos_block"
               "    \param flag An integer which indicates the state of the block (init, update, ending)"
               "*/"
               "void cmat3d(scicos_block * block, int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  /* Declarations */"
               "  ScopeMemory * pScopeMemory;"
               "  scoGraphicalObject pShortDraw;"
               "  double * u1;"
               "  int i,j;"
               "  int dim_i, dim_j;"
               "  int **user_data_ptr,*size_ptr;"
               " "
               "  /* State Machine Control */"
               "  switch(flag)"
               "    {"
               "      /*Flag 4*/"
               "    case Initialization:"
               "      {"
               "        /*We create the window for the first time, so 1 is in parameters*/"
               "        cmat3d_draw(block,&pScopeMemory,1);"
               "        break; //dont forget the break"
               "      }"
               "      /*Flag 2*/"
               "    case StateUpdate:"
               "      {"
               "        /*Retreiving Scope in the _work*/"
               "        scoRetrieveScopeMemory(_work,&pScopeMemory);"
               "        if(scoGetPointerScopeWindow(pScopeMemory) == NULL) return;"
               "        if(scoGetScopeActivation(pScopeMemory) == 1)"
               "          {"
               ""
               ""
               "            /*Here some allocations and calcul wich are necessary*/"
               "            pShortDraw = scoGetPointerShortDraw(pScopeMemory,0,0);"
               ""
               "            u1 = GetInPortPtrs(block,1);"
               "            dim_i = GetInPortRows(block,1);"
               "            dim_j = GetInPortCols(block,1);"
               ""
               "            for(i = 0 ; i < dim_i ; i++)"
               "              {"
               "            "
               "                for(j = 0; j < dim_j ; j++)"
               "                  {"
               "                    pSURFACE_FEATURE(pShortDraw)->pvecz[j+i*dim_j] = u1[j+dim_j*i];"
               "                  }"
               "              }"
               "        "
               "            /*Here is the draw instructions*/"
               "            sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "            if(pFIGURE_FEATURE(scoGetPointerScopeWindow(pScopeMemory))->pixmap == 1)"
               "              {"
               "                C2F(dr)(""xset"",""wshow"",PI0,PI0,PI0,PI0,PI0,PI0,PD0,PD0,PD0,PD0,0L,0L);"
               "              }"
               "            sciDrawObj(scoGetPointerScopeWindow(pScopeMemory));"
               "          }"
               "        break; //dont forget the break"
               "      }"
               "      /*Flag 5*/"
               "    case Ending:"
               "      {"
               "        /*Retrieve Memory*/"
               "        scoRetrieveScopeMemory(_work, &pScopeMemory);"
               "        if(scoGetScopeActivation(pScopeMemory) == 1) {"
               "          if(scoGetPointerScopeWindow(pScopeMemory) != NULL) {"
               "            sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "            pShortDraw = sciGetCurrentFigure();"
               "            sciGetPointerToUserData (pShortDraw,&user_data_ptr, &size_ptr);"
               "            FREE(*user_data_ptr);"
               "            *user_data_ptr=NULL;"
               "            *size_ptr = 0;"
               "          }"
               "        }"
               "        /*Here we can add specific instructions to be sure that we have stick short and longdraw if we need it. Cscope for example stick the last short to the long to have one curve to move*/"
               "        scoFreeScopeMemory(_work, &pScopeMemory);"
               "        break;"
               "      }"
               "    }"
               "}"]

      case 'cmatview' then
        txt = ["/**"
               "   \file cmatview.c"
               "   \author Benoit Bayol"
               "   \version 1.0"
               "   \date September 2006 - January 2007"
               "   \brief CMATVIEW is a scope that connects a matrix to a grayplot. The values of the matrix are the values at the nodes"
               "  \see CMATVIEW.sci in macros/scicos_blocks/Sinks/"
               "*/"
               ""
               "#include ""scoMemoryScope.h"""
               "#include ""scoWindowScope.h"""
               "#include ""scoMisc.h"""
               "#include ""scoGetProperty.h"""
               "#include ""scoSetProperty.h"""
               "#include ""scicos_block4.h"""
               "#include <math.h>"
               "#include <stdlib.h>"
               ""
               "/** \fn cmatview_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "    \brief Function to draw or redraw the window"
               "*/"
               "void cmatview_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "{"
               "  int i; //As usual"
               "  int * ipar; //Integer Parameters"
               "  int win_pos[2]; //Position of the Window"
               "  int win_dim[2]; //Dimension of the Window"
               "  int dimension = 2;"
               "  double * rpar; //Reals parameters"
               "  double  ymin, ymax; //Ymin and Ymax are vectors here"
               "  double  xmin, xmax;"
               "  int number_of_curves_by_subwin;"
               "  int number_of_subwin;"
               "  double * mat;"
               "  int size_mat;"
               "  char *label;"
               ""
               "  /*Retrieving Parameters*/"
               "  rpar = GetRparPtrs(block);"
               "  ipar = GetIparPtrs(block);"
               "  number_of_subwin = 1;"
               "  win_pos[0] = -1;"
               "  win_pos[1] = -1;"
               "  win_dim[0] = -1;"
               "  win_dim[1] = -1;"
               ""
               "  size_mat = ipar[2];"
               "  mat = (double*)scicos_malloc(size_mat*sizeof(double));"
               "  for(i = 0 ; i < size_mat ; i++)"
               "    {"
               "      mat[i] = rpar[i+2];"
               "    }"
               "  xmax = GetInPortSize(block,1,1);"
               "  xmin = 0;"
               "  ymax = GetInPortSize(block,1,2);"
               "  ymin = 0;"
               ""
               "  number_of_curves_by_subwin = 1;"
               "  label = GetLabelPtrs(block);"
               ""
               "  /*Allocating memory*/"
               ""
               "  if(firstdraw == 1)"
               "    {"
               "      scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, &number_of_curves_by_subwin);"
               "    }"
               ""
               "  /*Creating the Scope*/"
               "  scoInitOfWindow(*pScopeMemory, dimension, -1, win_pos, win_dim, &xmin, &xmax, &ymin, &ymax, NULL, NULL);"
               "  if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "    {"
               "      sciSetColormap(scoGetPointerScopeWindow(*pScopeMemory), mat , size_mat/3, 3);"
               "      scoAddTitlesScope(*pScopeMemory,label,""x"",""y"",NULL);"
               "      scoAddGrayplotForShortDraw(*pScopeMemory,0,0,GetInPortSize(block,1,1),GetInPortSize(block,1,2));"
               "    }"
               "  scicos_free(mat);"
               ""
               "}"
               ""
               "/** \fn void cmatview(scicos_block * block, int flag)"
               "    \brief the computational function"
               "    \param block A pointer to a scicos_block"
               "    \param flag An integer which indicates the state of the block (init, update, ending)"
               "*/"
               "void cmatview(scicos_block * block, int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  /* Declarations */"
               "  ScopeMemory * pScopeMemory;"
               "  scoGraphicalObject pShortDraw;"
               "  double * u1;"
               "  double alpha,beta;"
               "  int i,j;"
               "  double * rpar;"
               "  int dim_i, dim_j;"
               "  int **user_data_ptr,*size_ptr;"
               "  /* Initializations and Allocations*/"
               "  //Allocations are done here because there are dependent of some values presents below"
               " "
               "  /* State Machine Control */"
               "  switch(flag)"
               "    {"
               "    case Initialization:"
               "      {"
               "        cmatview_draw(block,&pScopeMemory,1);"
               "        break;"
               "      }"
               "    case StateUpdate:"
               "      {"
               "        /*Retreiving Scope in the _work*/"
               "        scoRetrieveScopeMemory(_work,&pScopeMemory);"
               "        if(scoGetPointerScopeWindow(pScopeMemory) == NULL) return;"
               "        if(scoGetScopeActivation(pScopeMemory) == 1)"
               "          {   "
               "            pShortDraw = scoGetPointerShortDraw(pScopeMemory,0,0);"
               "            rpar = GetRparPtrs(block);"
               "            alpha = rpar[0];"
               "            beta = rpar[1];"
               "            u1 = GetInPortPtrs(block,1);"
               "            "
               "            dim_i = GetInPortRows(block,1);"
               "            dim_j = GetInPortCols(block,1);"
               "            "
               "            for(i = 0 ; i < dim_i ; i++)"
               "              {"
               "                for(j = 0; j < dim_j ; j++)"
               "                  {"
               "                    pGRAYPLOT_FEATURE(pShortDraw)->pvecz[i*dim_j+j] = floor(alpha*u1[j+i*dim_j]+beta);"
               "                  }"
               "              }"
               "            sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "            if(pFIGURE_FEATURE(scoGetPointerScopeWindow(pScopeMemory))->pixmap == 1)"
               "              {"
               "            C2F(dr)(""xset"",""wshow"",PI0,PI0,PI0,PI0,PI0,PI0,PD0,PD0,PD0,PD0,0L,0L);"
               "              }"
               "            sciDrawObj(scoGetPointerShortDraw(pScopeMemory,0,0));"
               "          }"
               "        break;"
               "      }//End of stateupdate"
               "    case Ending:"
               "      {"
               "        scoRetrieveScopeMemory(_work, &pScopeMemory);"
               "        if(scoGetScopeActivation(pScopeMemory) == 1) {"
               "          if(scoGetPointerScopeWindow(pScopeMemory) != NULL) {"
               "            sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "            pShortDraw = sciGetCurrentFigure();"
               "            sciGetPointerToUserData (pShortDraw,&user_data_ptr, &size_ptr);"
               "            FREE(*user_data_ptr);"
               "            *user_data_ptr=NULL;"
               "            *size_ptr = 0;"
               "          }"
               "        }"
               "        scoFreeScopeMemory(_work, &pScopeMemory);"
               "        break;"
               "      }"
               "    }"
               "}"]

      case 'cmscope' then
        txt = ["/**"
               "   \file cmscope.c"
               "   \author Benoit Bayol"
               "   \version 1.0"
               "   \date September 2006 - January 2007"
               "   \brief CMSCOPE is a typical scope which links its input to the simulation time"
               "   \see CMSCOPE.sci in macros/scicos_blocks/Sinks/"
               "*/"
               ""
               "#include ""scoMemoryScope.h"""
               "#include ""scoWindowScope.h"""
               "#include ""scoMisc.h"""
               "#include ""scoGetProperty.h"""
               "#include ""scoSetProperty.h"""
               "#include ""scicos_block4.h"""
               ""
               "/** \fn cmscope_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "    \brief Function to draw or redraw the window"
               "*/"
               "void cmscope_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "{"
               "  int i; //As usual"
               "  int * ipar; //Integer Parameters"
               "  int * colors; //Colors"
               "  int win; //Windows ID : To give a name to the window"
               "  int buffer_size; //Buffer Size"
               "  int win_pos[2]; //Position of the Window"
               "  int win_dim[2]; //Dimension of the Window"
               "  int inherited_events;"
               "  int nipar;"
               "  int dimension = 2;"
               "  double * rpar; //Reals parameters"
               "  double dt; //Time++"
               "  double * period; //Refresh Period of the scope is a vector here"
               "  double * ymin,* ymax; //Ymin and Ymax are vectors here"
               "  double * xmin, *xmax;"
               "  int nbr_period;"
               "  int * number_of_curves_by_subwin;"
               "  int number_of_subwin;"
               "  int nbr_total_curves;"
               "  char *label;"
               ""
               "  /*Retrieving Parameters*/"
               "  rpar = GetRparPtrs(block);"
               "  ipar = GetIparPtrs(block);"
               "  nipar = GetNipar(block);"
               "  win = ipar[0];"
               "  number_of_subwin = ipar[1];"
               "  buffer_size = ipar[2];"
               "  win_pos[0] = ipar[3];"
               "  win_pos[1] = ipar[4];"
               "  win_dim[0] = ipar[5];"
               "  win_dim[1] = ipar[6];"
               "  label = GetLabelPtrs(block);"
               "  nbr_total_curves = 0;"
               "  //Don''t forget malloc for ''type *''"
               "  number_of_curves_by_subwin = (int*)scicos_malloc(number_of_subwin*sizeof(int));"
               "  for (i = 7; i < 7+number_of_subwin ; i++)"
               "    {"
               "      number_of_curves_by_subwin[i-7] = ipar[i];"
               "      nbr_total_curves = nbr_total_curves + ipar[i];"
               "    }"
               "  colors = (int*)scicos_malloc(nbr_total_curves*sizeof(int));"
               "  for(i = 0; i < nbr_total_curves ; i++)"
               "    {"
               "      colors[i] = ipar[i+7+number_of_subwin];"
               "    }"
               "  inherited_events = ipar[7+number_of_subwin+number_of_subwin];"
               ""
               "  dt = rpar[0];"
               ""
               "  nbr_period = 0;"
               "  period = (double*)scicos_malloc(number_of_subwin*sizeof(double));"
               "  for (i = 0 ; i < number_of_subwin ; i++)"
               "    {"
               "      period[i] = rpar[i+1];"
               "      nbr_period++; "
               "    }"
               "  ymin = (double*)scicos_malloc(number_of_subwin*sizeof(double));"
               "  ymax = (double*)scicos_malloc(number_of_subwin*sizeof(double));"
               "  for (i = 0 ; i < number_of_subwin ; i++)"
               "    {"
               "      ymin[i] = rpar[2*i+nbr_period+1];"
               "      ymax[i] = rpar[2*i+nbr_period+2];"
               "    }"
               ""
               "  /*Allocating memory*/"
               "  if(firstdraw == 1)"
               "    {"
               ""
               "      scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, number_of_curves_by_subwin);"
               "      for(i = 0 ; i < number_of_subwin ; i++)"
               "        {"
               "          scoSetLongDrawSize(*pScopeMemory, i, 5000);"
               "          scoSetShortDrawSize(*pScopeMemory,i,buffer_size);"
               "          scoSetPeriod(*pScopeMemory,i,period[i]);"
               "        }    "
               "    }"
               ""
               "  /* Xmin and Xmax are calculated here because we need a variable which is only existing in the pScopeMemory. pScopeMemory is allocated just few lines before. Indeed in this TimeAmplitudeScope Xmin and Xmax have to change often. To be sure to redraw in the correct scale we have to calculate xmin and xmax thanks to the period_counter. If the window haven''t to be redraw (recreate)  it wouldn''t be necessary*/"
               "  xmin = (double*)scicos_malloc(number_of_subwin*sizeof(double));"
               "  xmax = (double*)scicos_malloc(number_of_subwin*sizeof(double));"
               "  for (i = 0 ; i < number_of_subwin ; i++)"
               "    {"
               "      xmin[i] = period[i]*(scoGetPeriodCounter(*pScopeMemory,i));"
               "      xmax[i] = period[i]*(scoGetPeriodCounter(*pScopeMemory,i)+1);"
               "    }"
               ""
               "  /*Creating the Scope*/"
               "  scoInitOfWindow(*pScopeMemory, dimension, win, win_pos, win_dim, xmin, xmax, ymin, ymax, NULL, NULL);"
               "  if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "    {"
               "      scoAddTitlesScope(*pScopeMemory,label,""t"",""y"",NULL);"
               ""
               "  /*Add a couple of polyline : one for the shortdraw and one for the longdraw*/"
               "  /*    scoAddPolylineLineStyle(*pScopeMemory,colors); */"
               "      scoAddCoupleOfPolylines(*pScopeMemory,colors);"
               "    }"
               "  scicos_free(number_of_curves_by_subwin);"
               "  scicos_free(colors);"
               "  scicos_free(period);"
               "  scicos_free(ymin);"
               "  scicos_free(ymax);"
               "  scicos_free(xmin);"
               "  scicos_free(xmax);"
               "}"
               ""
               "/** \fn void cmscope(scicos_block * block, int flag)"
               "    \brief the computational function"
               "    \param block A pointer to a scicos_block"
               "    \param flag An integer which indicates the state of the block (init, update, ending)"
               "*/"
               "void cmscope(scicos_block * block, int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  /* Declarations */"
               "  ScopeMemory * pScopeMemory;"
               "  int NbrPtsShort;"
               "  double * u1;"
               "  double t; //get_scicos_time()"
               "  scoGraphicalObject pShortDraw;"
               "  int i,j;"
               "  int **user_data_ptr,*size_ptr;"
               ""
               ""
               "  /* Initializations and Allocations*/"
               "  //Allocations are done here because there are dependent of some values presents below"
               " "
               "  /* State Machine Control */"
               "  switch(flag)"
               "    {"
               "    case Initialization:"
               "      {"
               "        cmscope_draw(block,&pScopeMemory,1);"
               "        break; //Break of the switch condition don t forget it"
               "      } //End of Initialization"
               "  "
               "    case StateUpdate:"
               "      {"
               "        /*Retreiving Scope in the _work*/"
               "        scoRetrieveScopeMemory(_work,&pScopeMemory);"
               "        if(scoGetPointerScopeWindow(pScopeMemory) == NULL) return;"
               "        if(scoGetScopeActivation(pScopeMemory) == 1)"
               "          {"
               "            /* Charging Elements */"
               "            t = get_scicos_time();"
               "            /* If window has been destroyed we recreate it */"
               "           "
               ""
               "            scoRefreshDataBoundsX(pScopeMemory,t);"
               ""
               "            //Here we are calculating the points in the polylines"
               "            for (i = 0 ; i < scoGetNumberOfSubwin(pScopeMemory) ; i++)"
               "              {"
               "                u1 = GetRealInPortPtrs(block,i+1);"
               "                pShortDraw = scoGetPointerShortDraw(pScopeMemory,i,0);"
               "                NbrPtsShort = pPOLYLINE_FEATURE(pShortDraw)->n1;"
               "                for (j = 0; j < scoGetNumberOfCurvesBySubwin(pScopeMemory,i) ; j++)"
               "                  {"
               "                    pShortDraw = scoGetPointerShortDraw(pScopeMemory,i,j);"
               "                    pPOLYLINE_FEATURE(pShortDraw)->pvx[NbrPtsShort] = t;"
               "                    pPOLYLINE_FEATURE(pShortDraw)->pvy[NbrPtsShort] = u1[j];"
               "                    pPOLYLINE_FEATURE(pShortDraw)->n1++;"
               "                  }"
               "              }"
               ""
               "            scoDrawScopeAmplitudeTimeStyle(pScopeMemory, t);"
               ""
               "            "
               "            //Break of the switch don t forget it !"
               "          }//End of stateupdate"
               "        break; "
               "        //This case is activated when the simulation is done or when we close scicos"
               "      }"
               "    case Ending:"
               "      {"
               "        scoRetrieveScopeMemory(_work, &pScopeMemory);"
               "        if(scoGetScopeActivation(pScopeMemory) == 1) {"
               "          if(scoGetPointerScopeWindow(pScopeMemory) != NULL) {"
               "            sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "            pShortDraw = sciGetCurrentFigure();"
               "            sciGetPointerToUserData (pShortDraw,&user_data_ptr, &size_ptr);"
               "            FREE(*user_data_ptr);"
               "            *user_data_ptr=NULL;"
               "            *size_ptr = 0;"
               "            scoDelCoupleOfPolylines(pScopeMemory);"
               "          }"
               "        }"
               "        scoFreeScopeMemory(_work, &pScopeMemory);"
               ""
               "        break;"
               "      }"
               "    }"
               "}"]

      case 'constraint_c' then
        txt = ["#include ""scicos_block4.h"""
               ""
               "/*     February 2008 */"
               "/*    Copyright INRIA"
               " *    Scicos block simulator"
               " */"
               ""
               "void constraint_c(scicos_block *block,int flag)"
               "{"
               "  double *_xd=GetDerState(block);"
               "  double *_x=GetState(block);"
               "  double *_res=GetResState(block);"
               "  int *_ipar=GetIparPtrs(block);"
               "  double *y,*y2,*u;"
               "  int i;"
               "  int* property=GetXpropPtrs(block);"
               "  int outsz0=GetOutPortRows(block,1);"
               "    switch(flag)"
               "      {"
               "      case 4  : {"
               "        for (i=0;i<outsz0;i++) property[i]=-1; /* xproperties*/"
               "        break;"
               "      }"
               ""
               "      case 7  : {"
               "        for (i=0;i<outsz0;i++){"
               "          property[i] = _ipar[i];"
               "        }"
               "        break;"
               "      }"
               ""
               "      case 0  : {/* the workspace is used to store discrete counter value */"
               "        u=GetRealInPortPtrs(block,1);   "
               "        for (i=0;i<outsz0;i++) _res[i]=u[i];    "
               "        break;"
               "      }"
               ""
               "      case 1  : { "
               "        y=GetRealOutPortPtrs(block,1);"
               "        for (i=0;i<outsz0;i++)  y[i]=_x[i];     "
               ""
               "        if (GetNout(block)==2) {"
               "          y2=GetRealOutPortPtrs(block,2);"
               "          for (i=0;i<outsz0;i++)  y2[i]=_xd[i];"
               "        }"
               "        break;  "
               "      }"
               ""
               "      default : break;"
               "      }"
               "}"]

      case 'convert' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "# include <math.h>"
               "# include <memory.h>"
               "extern int sciprint();"
               ""
               "void convert(scicos_block *block,int flag)"
               "{"
               " int m,n,i;"
               " int *ipar;"
               " double v,w,k;"
               " "
               " m=GetInPortRows(block,1);"
               " n=GetInPortCols(block,1);"
               " ipar=GetIparPtrs(block);"
               " "
               " if ((flag==1)|(flag==6))"
               "   {"
               "     switch (*ipar){"
               "     case 1:{ "
               "       void *u,*y;"
               "       int so;"
               "       so=GetSizeOfOut(block,1);"
               "       u=GetInPortPtrs(block,1);"
               "       y=GetOutPortPtrs(block,1);"
               "       memcpy(y,u,m*n*so);"
               "       break;}"
               "     case 2:{"
               "       double *u;"
               "       long *y;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getint32OutPortPtrs(block,1);"
               "       k=0xFFFFFFFF+1.0;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           if (fabs(w)>k/2-1)"
               "             {if (w>=0) w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "               else w=-(-(k/2)+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "             }"
               "           y[i]=(long)w;}"
               "       break;}"
               "     case 3:{"
               "       double *u;"
               "       short *y;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       k=0x10000;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           if (fabs(w)>k/2-1)"
               "             {if (w>=0) w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "               else w=-(-(k/2)+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "             }"
               "           y[i]=(short)w;}"
               "       break;}"
               "     case 4:{"
               "       double *u;"
               "       char *y;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k=0x100;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           if (fabs(w)>k/2-1)"
               "             {if (w>=0) w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "               else w=-(-(k/2)+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "             }"
               "           y[i]=(char)w;}"
               "       break;}"
               "     case 5:{"
               "       double *u;"
               "       unsigned long *y;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       k=0xFFFFFFFF+1.0;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           y[i]=(unsigned long)w;}"
               "       break;}"
               "     case 6:{"
               "       double *u;"
               "       unsigned short *y;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       k=0x10000;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           y[i]=(unsigned short)w;}"
               "       break;}"
               "     case 7:{"
               "       double *u;"
               "       unsigned char *y;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k=0x100;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           y[i]=(unsigned char)w;}"
               "       break;}"
               "     case 8:{"
               "       long *u;"
               "       double *y;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=GetRealOutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) y[i]=(double) u[i];"
               "       break;}"
               "     case 9:{"
               "       long *u;"
               "       short *y;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       k=0x10000;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           if (fabs(w)>k/2-1)"
               "             {if (w>=0) w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "               else w=-(-(k/2)+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "             }"
               "           y[i]=(short)w;}"
               "       break;}"
               "     case 10:{"
               "       long *u;"
               "       char *y;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k=0x100;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           if (fabs(w)>k/2-1)"
               "             {if (w>=0) w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "               else w=-(-(k/2)+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "             }"
               "           y[i]=(char)w;}"
               "       break;}"
               "     case 11:{"
               "       long *u;"
               "       unsigned short *y;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       k=0x10000;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           y[i]=(unsigned short)w;}"
               "       break;}"
               "     case 12:{"
               "       long *u;"
               "       unsigned char *y;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k=0x100;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           y[i]=(unsigned char)w;}"
               "       break;}"
               "     case 13:{"
               "       short *u;"
               "       double *y;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=GetRealOutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) y[i]=(double) u[i];"
               "       break;}"
               "     case 14:{"
               "       short *u;"
               "       long *y;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=Getint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {y[i]=(long)u[i];}"
               "       break;}"
               "     case 15:{"
               "       short *u;"
               "       char *y;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k=0x100;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           if (fabs(w)>k/2-1)"
               "             {if (w>=0) w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "               else w=-(-(k/2)+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "             }"
               "           y[i]=(char)w;}"
               "       break;}"
               "     case 16:{"
               "       short *u;"
               "       unsigned long *y;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {y[i]=(unsigned long)u[i];}"
               "       break;}"
               "     case 17:{"
               "       short *u;"
               "       unsigned char *y;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k=0x100;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           y[i]=(unsigned char)w;}"
               "       break;}"
               "     case 18:{"
               "       char *u;"
               "       double *y;"
               "       u=Getint8InPortPtrs(block,1);"
               "       y=GetRealOutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) y[i]=(double) u[i];"
               "       break;}"
               "     case 19:{"
               "       char *u;"
               "       long *y;"
               "       u=Getint8InPortPtrs(block,1);"
               "       y=Getint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {y[i]=(long)u[i];}"
               "       break;}"
               "     case 20:{"
               "       char *u;"
               "       short *y;"
               "       u=Getint8InPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {y[i]=(short)u[i];}"
               "       break;}"
               "     case 21:{"
               "       char *u;"
               "       unsigned long *y;"
               "       u=Getint8InPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {y[i]=(unsigned long)u[i];}"
               "       break;}"
               "     case 22:{"
               "       char *u;"
               "       unsigned short *y;"
               "       u=Getint8InPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {y[i]=(unsigned short)u[i];}"
               "       break;}"
               "     case 23:{"
               "       unsigned long *u;"
               "       double *y;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=GetRealOutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) y[i]=(double) u[i];"
               "       break;}"
               "     case 24:{"
               "       unsigned long *u;"
               "       short *y;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       k=0x10000;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           if ((w)>k/2-1)"
               "             { w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "             }"
               "           y[i]=(short)w;}"
               "       break;}"
               "     case 25:{"
               "       unsigned long *u;"
               "       char *y;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k=0x100;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           if ((w)>k/2-1)"
               "             {w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "             }"
               "           y[i]=(char)w;}"
               "       break;}"
               "     case 26:{"
               "       unsigned long *u;"
               "       unsigned short *y;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       k=0x10000;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           y[i]=(unsigned short)w;}"
               "       break;}"
               "     case 27:{"
               "       unsigned long *u;"
               "       unsigned char *y;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k=0x100;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           y[i]=(unsigned char)w;}"
               "       break;}"
               "     case 28:{"
               "       unsigned short *u;"
               "       double *y;"
               "       u=Getuint16InPortPtrs(block,1);"
               "       y=GetRealOutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) y[i]=(double) u[i];"
               "       break;}"
               "     case 29:{"
               "       unsigned short *u;"
               "       long *y;"
               "       u=Getuint16InPortPtrs(block,1);"
               "       y=Getint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {y[i]=(long)u[i];}"
               "       break;}"
               "     case 30:{"
               "       unsigned short *u;"
               "       char *y;"
               "       u=Getuint16InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k=0x100;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           if (w>k/2-1)"
               "             {w=(-k/2+fabs(w-(double)((int)(w/(k/2)))*(k/2)));"
               "             }"
               "           y[i]=(char)w;}"
               "       break;}"
               "     case 31:{"
               "       unsigned short *u;"
               "       unsigned long *y;"
               "       u=Getuint16InPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {y[i]=(unsigned long)u[i];}"
               "       break;}"
               "     case 32:{"
               "       unsigned short *u;"
               "       unsigned char *y;"
               "       u=Getuint16InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k=0x100;"
               "       for (i=0;i<m*n;i++) "
               "         {v=(double)u[i];"
               "           w=v-(double)((int)(v/k))*k;"
               "           y[i]=(unsigned char)w;}"
               "       break;}"
               "     case 33:{"
               "       unsigned char *u;"
               "       double *y;"
               "       u=Getuint8InPortPtrs(block,1);"
               "       y=GetRealOutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) y[i]=(double) u[i];"
               "       break;}"
               "     case 34:{"
               "       unsigned char *u;"
               "       long *y;"
               "       u=Getuint8InPortPtrs(block,1);"
               "       y=Getint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {y[i]=(long)u[i];}"
               "       break;}"
               "     case 35:{"
               "       unsigned char *u;"
               "       short *y;"
               "       u=Getuint8InPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {y[i]=(short)u[i];}"
               "       break;}"
               "     case 36:{"
               "       unsigned char *u;"
               "       unsigned long *y;"
               "       u=Getuint8InPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {y[i]=(unsigned long)u[i];}"
               "       break;}"
               "     case 37:{"
               "       unsigned char *u;"
               "       unsigned short *y;"
               "       u=Getuint8InPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {y[i]=(unsigned short)u[i];}"
               "       break;}"
               "     case 38:{"
               "       double *u;"
               "       long *y,k1,k2;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getint32OutPortPtrs(block,1);"
               "       k1=0x7FFFFFFF;"
               "       k2=0x80000000;"
               "       for (i=0;i<m*n;i++)"
               "         {if (u[i]>(double)k1)"
               "             {y[i]=k1;}"
               "           else if (u[i]<(double)(k2))"
               "             {y[i]=k2;}"
               "           else {y[i]=(long)(u[i]);}"
               "         }"
               "       break;}"
               "     case 39:{"
               "       double *u;"
               "       short *y,k1,k2;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       k1=0x7FFF;"
               "       k2=0x8000;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(double)(k1))"
               "             {y[i]=k1;}"
               "           else if (u[i]<(double)k2)"
               "             {y[i]=k2;}"
               "           else {y[i]=(short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 40:{"
               "       double *u;"
               "       char *y,k1,k2;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k1=0x7F;"
               "       k2=0x80;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(double)k1)"
               "             {y[i]=k1;}"
               "           else if (u[i]<(double)k2)"
               "             {y[i]=k2;}"
               "           else {y[i]=(char)(u[i]);}"
               "         }"
               "                   break;}"
               "     case 41:{"
               "       double *u;"
               "       unsigned long *y,k1;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       k1=0xFFFFFFFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(double)k1)"
               "             {y[i]=k1;}"
               "           else if (u[i]<0)"
               "             {y[i]=0;}"
               "           else {y[i]=(unsigned long)(u[i]);}"
               "         }"
               "       break;}"
               "     case 42:{"
               "       double *u;"
               "       unsigned short *y,k1;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       k1=0xFFFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(double)k1)"
               "             {y[i]=k1;}"
               "           else if (u[i]<0)"
               "             {y[i]=0;}"
               "           else {y[i]=(unsigned short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 43:{"
               "       double *u;"
               "       unsigned char *y,k1;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k1=0xFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(double)k1)"
               "             {y[i]=k1;}"
               "           else if (u[i]<0)"
               "             {y[i]=0;}"
               "           else {y[i]=(unsigned char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 44:{"
               "       long *u;"
               "       short *y,k1,k2;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       k1=0x7FFF;"
               "       k2=0x8000;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(long)(k1))"
               "             {y[i]=k1;}"
               "           else if (u[i]<(long)(k2))"
               "             {y[i]=k2;}"
               "           else {y[i]=(short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 45:{"
               "       long *u;"
               "       char *y,k1,k2;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k1=0x7F;"
               "       k2=0x80;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(long)(k1))"
               "             {y[i]=k1;}"
               "           else if (u[i]<(long)(k2))"
               "             {y[i]=k2;}"
               "           else {y[i]=(char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 46:{"
               "       long *u;"
               "       unsigned long *y;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]<0)"
               "             {y[i]=0;}"
               "           else {y[i]=(unsigned long)(u[i]);}"
               "         }"
               "       break;}"
               "     case 47:{"
               "       long *u;"
               "       unsigned short *y,k1;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       k1=0xFFFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(long)(k1))"
               "             {y[i]=k1;}"
               "           else if (u[i]<0)"
               "             {y[i]=0;}"
               "           else {y[i]=(unsigned short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 48:{"
               "       long *u;"
               "       unsigned char *y,k1;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k1=0xFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(long)k1)"
               "             {y[i]=k1;}"
               "           else if (u[i]<0)"
               "             {y[i]=0;}"
               "           else {y[i]=(unsigned char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 49:{"
               "       short *u;"
               "       char *y,k1,k2;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k1=0x7F;"
               "       k2=0x80;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(short)(k1))"
               "             {y[i]=k1;}"
               "           else if (u[i]<(short)(k2))"
               "             {y[i]=k2;}"
               "           else {y[i]=(char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 50:{"
               "       short *u;"
               "       unsigned long *y;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]<0)  y[i]=0;"
               "           else y[i]=(unsigned long)u[i];}"
               "       break;}"
               "     case 51:{"
               "       short *u;"
               "       unsigned short *y;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]<0)"
               "             {y[i]=0;}"
               "           else {y[i]=(unsigned short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 52:{"
               "       short *u;"
               "       unsigned char *y,k1;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k1=0xFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(short)k1)"
               "             {y[i]=k1;}"
               "           else if (u[i]<0)"
               "             {y[i]=0;}"
               "           else {y[i]=(unsigned char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 53:{"
               "       char *u;"
               "       unsigned long *y;"
               "       u=Getint8InPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]<0)  y[i]=0;"
               "           else y[i]=(unsigned long)u[i];}"
               "       break;}"
               "     case 54:{"
               "       char *u;"
               "       unsigned short *y;"
               "       u=Getint8InPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]<0)"
               "             {y[i]=0;}"
               "           else {y[i]=(unsigned short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 55:{"
               "       char *u;"
               "       unsigned char *y;"
               "       u=Getint8InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]<0)"
               "             {y[i]=0;}"
               "           else {y[i]=(unsigned char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 56:{"
               "       long *y,k1;"
               "       unsigned long *u;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getint32OutPortPtrs(block,1);"
               "       k1=0x7FFFFFFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned long)(k1))"
               "             {y[i]=k1;}"
               "           else {y[i]=(long)(u[i]);}"
               "         }"
               "       break;}"
               "     case 57:{"
               "       unsigned long *u;"
               "       short *y,k1;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       k1=0x7FFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned long)k1)"
               "             {y[i]=k1;}"
               "           else {y[i]=(short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 58:{"
               "       unsigned long *u;"
               "       char *y,k1;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k1=0x7F;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned long)k1)"
               "             {y[i]=k1;}"
               "           else {y[i]=(char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 59:{"
               "       unsigned long *u;"
               "       unsigned short *y,k1;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       k1=0xFFFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned long)(k1))"
               "             {y[i]=k1;}"
               "           else {y[i]=(unsigned short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 60:{"
               "       unsigned long *u;"
               "       unsigned char *y,k1;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k1=0xFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned long)k1)"
               "             {y[i]=k1;}"
               "           else {y[i]=(unsigned char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 61:{"
               "       unsigned short *u;"
               "       short *y,k1;"
               "       u=Getuint16InPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       k1=0x7FFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned short)k1)"
               "             {y[i]=k1;}"
               "           else {y[i]=(short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 62:{"
               "       unsigned short *u;"
               "       char *y,k1;"
               "       u=Getuint16InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k1=0x7F;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned short)k1)"
               "             {y[i]=k1;}"
               "           else {y[i]=(char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 63:{"
               "       unsigned short *u;"
               "       unsigned char *y,k1;"
               "       u=Getuint16InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k1=0xFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned short)k1)"
               "             {y[i]=k1;}"
               "           else {y[i]=(unsigned char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 64:{"
               "       unsigned char *u;"
               "       char *y,k1;"
               "       u=Getuint8InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k1=0x7F;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned char)k1)"
               "             {y[i]=k1;}"
               "           else {y[i]=(char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 65:{"
               "       double *u;"
               "       long *y,k1,k2;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getint32OutPortPtrs(block,1);"
               "       k1=0x7FFFFFFF;"
               "       k2=0x80000000;"
               "       for (i=0;i<m*n;i++)"
               "         {if ((u[i]>(double)k1) | (u[i]<(double)k2))"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(long)(u[i]);}"
               "         }"
               "       break;}"
               "     case 66:{"
               "       double *u;"
               "       short *y,k1,k2;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       k1=0x7FFF;"
               "       k2=0x8000;"
               "       for (i=0;i<m*n;i++) "
               "         {if ((u[i]>(double)k1) | (u[i]<(double)k2))"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 67:{"
               "       double *u;"
               "       char *y,k1,k2;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k1=0x7F;"
               "       k2=0x80;"
               "       for (i=0;i<m*n;i++) "
               "         {if ((u[i]>(double)k1) | (u[i]<(double)k2))"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 68:{"
               "       double *u;"
               "       unsigned long *y,k1;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       k1=0xFFFFFFFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if ((u[i]>(double)k1) | (u[i]<0))"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(unsigned long)(u[i]);}"
               "         }"
               "       break;}"
               "     case 69:{"
               "       double *u;"
               "       unsigned short *y,k1;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       k1=0xFFFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if ((u[i]>(double)k1) | (u[i]<0))"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(unsigned short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 70:{"
               "       double *u;"
               "       unsigned char *y,k1;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k1=0xFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if ((u[i]>(double)k1) | (u[i]<0))"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(unsigned char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 71:{"
               "       long *u;"
               "       short *y,k1,k2;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       k1=0x7FFF;"
               "       k2=0x8000;"
               "       for (i=0;i<m*n;i++) "
               "         {if ((u[i]>(long)k1) | (u[i]<(long)k2))"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 72:{"
               "       long *u;"
               "       char *y,k1,k2;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k1=0x7F;"
               "       k2=0x80;"
               "       for (i=0;i<m*n;i++) "
               "         {if ((u[i]>(long)k1) | (u[i]<(long)k2))"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 73:{"
               "       long *u;"
               "       unsigned long *y;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]<0)"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(unsigned long)(u[i]);}"
               "         }"
               "       break;}"
               "     case 74:{"
               "       long *u;"
               "       unsigned short *y,k1;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       k1=0xFFFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if ((u[i]>(long)k1) | (u[i]<0))"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(unsigned short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 75:{"
               "       long *u;"
               "       unsigned char *y,k1;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k1=0xFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if ((u[i]>(long)k1) | (u[i]<0))"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(unsigned char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 76:{"
               "       short *u;"
               "       char *y,k1,k2;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k1=0x7F;"
               "       k2=0x80;"
               "       for (i=0;i<m*n;i++) "
               "         {if ((u[i]>(short)k1) | (u[i]<(short)k2))"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 77:{"
               "       short *u;"
               "       unsigned long *y;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]<0)  "
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else y[i]=(unsigned long)u[i];}"
               "       break;}"
               "     case 78:{"
               "       short *u;"
               "       unsigned short *y;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]<0)"
               "             {if (flag==1) "
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(unsigned short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 79:{"
               "       short *u;"
               "       unsigned char *y,k1;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k1=0xFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if((u[i]>(short)k1) | (u[i]<0))"
               "             {if (flag==1) "
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(unsigned char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 80:{"
               "       char *u;"
               "       unsigned long *y;"
               "       u=Getint8InPortPtrs(block,1);"
               "       y=Getuint32OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]<0)"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else y[i]=(unsigned long)u[i];}"
               "       break;}"
               "     case 81:{"
               "       char *u;"
               "       unsigned short *y;"
               "       u=Getint8InPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]<0)"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(unsigned short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 82:{"
               "       char *u;"
               "       unsigned char *y;"
               "       u=Getint8InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]<0)"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(unsigned char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 83:{"
               "       long *y,k1;"
               "       unsigned long *u;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getint32OutPortPtrs(block,1);"
               "       k1=0x7FFFFFFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned long)k1)"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(long)(u[i]);}"
               "         }"
               "       break;}"
               "     case 84:{"
               "       unsigned long *u;"
               "       short *y,k1;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       k1=0x7FFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned long)k1)"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 85:{"
               "       unsigned long *u;"
               "       char *y,k1;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k1=0x7F;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned long)k1)"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 86:{"
               "       unsigned long *u;"
               "       unsigned short *y,k1;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getuint16OutPortPtrs(block,1);"
               "       k1=0xFFFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned )k1)"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(unsigned short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 87:{"
               "       unsigned long *u;"
               "       unsigned char *y,k1;"
               "       u=Getuint32InPortPtrs(block,1);"
               "       y=Getuint8OutPortPtrs(block,1);"
               "       k1=0xFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned long)k1)"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(unsigned char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 88:{"
               "       unsigned short *u;"
               "       short *y,k1;"
               "       u=Getuint16InPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       k1=0x7FFF;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned short)k1)"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(short)(u[i]);}"
               "         }"
               "       break;}"
               "     case 89:{"
               "       unsigned short *u;"
               "       char *y,k1;"
               "       u=Getuint16InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k1=0x7F;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned short)k1)"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(char)(u[i]);}"
               "         }"
               "       break;}"
               "            case 90:{"
               "              unsigned short *u;"
               "              unsigned char *y,k1;"
               "              u=Getuint16InPortPtrs(block,1);"
               "              y=Getuint8OutPortPtrs(block,1);"
               "              k1=0xFF;"
               "              for (i=0;i<m*n;i++) "
               "                {if (u[i]>(unsigned short)k1)"
               "                    {if (flag==1)"
               "                        {sciprint(""overflow error"");"
               "                          set_block_error(-4);"
               "                          return;}}"
               "                  else {y[i]=(unsigned char)(u[i]);}"
               "                }"
               "              break;}"
               "     case 91:{"
               "       unsigned char *u;"
               "       char *y,k1;"
               "       u=Getuint8InPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       k1=0x7F;"
               "       for (i=0;i<m*n;i++) "
               "         {if (u[i]>(unsigned char)k1)"
               "             {if (flag==1)"
               "                 {sciprint(""overflow error"");"
               "                   set_block_error(-4);"
               "                   return;}}"
               "           else {y[i]=(char)(u[i]);}"
               "         }"
               "       break;}"
               "     case 92: {"
               "       double *u;"
               "       long *y;"
               "       u=GetRealInPortPtrs(block,1);"
               "       y=GetBoolOutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++)"
               "         { if (*(u+i)==0) *(y+i)=(long)0;"
               "           else *(y+i)=(long)1;"
               "         }"
               "       break;}"
               "     case 93: {"
               "       long *u;"
               "       long *y;"
               "       u=Getint32InPortPtrs(block,1);"
               "       y=GetBoolOutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++)"
               "         { if (*(u+i)==0) *(y+i)=(long)0;"
               "           else *(y+i)=(long)1;"
               "         }"
               "       break;}"
               "     case 94: {"
               "       short *u;"
               "       long *y;"
               "       u=Getint16InPortPtrs(block,1);"
               "       y=GetBoolOutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++)"
               "         { if (*(u+i)==0) *(y+i)=(long)0;"
               "           else *(y+i)=(long)1;"
               "         }"
               "       break;}"
               "     case 95: {"
               "       char *u;"
               "       long *y;"
               "       u=Getint8InPortPtrs(block,1);"
               "       y=GetBoolOutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++)"
               "         { if (*(u+i)==0) *(y+i)=(long)0;"
               "           else *(y+i)=(long)1;"
               "         }"
               "       break;}"
               "     case 96: {"
               "       long *u;"
               "       double *y;"
               "       u=GetBoolInPortPtrs(block,1);"
               "       y=GetRealOutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++)"
               "         { *(y+i)=(double)*(u+i);"
               "         }"
               "       break;}"
               "     case 97: {"
               "       long *u;"
               "       short *y;"
               "       u=GetBoolInPortPtrs(block,1);"
               "       y=Getint16OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++)"
               "         { *(y+i)=(short)*(u+i);"
               "         }"
               "       break;}"
               "     case 98: {"
               "       long *u;"
               "       char *y;"
               "       u=GetBoolInPortPtrs(block,1);"
               "       y=Getint8OutPortPtrs(block,1);"
               "       for (i=0;i<m*n;i++)"
               "         { *(y+i)=(char)*(u+i);"
               "         }"
               "       break;}"
               "     }"
               "   }"
               "}"]

      case 'counter' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void counter(scicos_block *block,int flag)"
               "{"
               "  double *y,*z;"
               "  int *ipar;"
               "  y=GetRealOutPortPtrs(block,1);"
               "  z=GetDstate(block);"
               "  ipar=GetIparPtrs(block);"
               "  if (flag==1)"
               "    {if (*ipar==1) *y=*z+*(ipar+2);"
               "     else *y=*(ipar+1)-*z;}"
               "  else if (flag==2) "
               "    {*z=(1+(int)*z)%(*(ipar+1)-*(ipar+2)+1);}"
               "} "]

      case 'cscope' then
        txt = ["/**"
               "   \file cscope.c"
               "   \author Benoit Bayol"
               "   \version 1.0"
               "   \date September 2006 - January 2007"
               "   \brief CSCOPE is a typical scope which links its input to the simulation time but there is only one input instead of CMSCOPE"
               "   \see CSCOPE.sci in macros/scicos_blocks/Sinks/"
               "*/"
               ""
               "#include ""scoMemoryScope.h"""
               "#include ""scoWindowScope.h"""
               "#include ""scoMisc.h"""
               "#include ""scoGetProperty.h"""
               "#include ""scoSetProperty.h"""
               "#include ""scicos_block4.h"""
               ""
               "/** \fn cscope_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "    \brief Function to draw or redraw the window"
               "*/"
               "void cscope_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "{"
               "  int i;"
               "  double *rpar;"
               "  int *ipar, nipar;"
               "  double period;"
               "  int dimension;"
               "  double ymin, ymax, xmin, xmax;"
               "  int buffer_size;"
               "  int win_pos[2];"
               "  int win_dim[2];"
               "  int win;"
               "  int number_of_subwin;"
               "  int number_of_curves_by_subwin[1];"
               "  int * colors;"
               "  char *label;"
               ""
               "  /*Retrieving Parameters*/"
               "  rpar = GetRparPtrs(block);"
               "  ipar = GetIparPtrs(block);"
               "  nipar = GetNipar(block);"
               "  buffer_size = ipar[2];"
               "  win = ipar[0];"
               "  period  = rpar[3];"
               "  win_pos[0] = ipar[(nipar-1) - 3];"
               "  win_pos[1] = ipar[(nipar-1) - 2];"
               "  win_dim[0] = ipar[(nipar-1) - 1];"
               "  win_dim[1] = ipar[nipar-1];"
               "  dimension = 2;"
               "  number_of_curves_by_subwin[0] = GetInPortRows(block,1);"
               ""
               "  number_of_subwin = 1;"
               "  ymin  = rpar[1];"
               "  ymax  = rpar[2];"
               "  label = GetLabelPtrs(block);"
               ""
               "  colors = (int*)scicos_malloc(number_of_curves_by_subwin[0]*sizeof(int));"
               "  for(i = 0 ; i < number_of_curves_by_subwin[0] ; i++)"
               "    {"
               "      colors[i] = ipar[3+i];"
               "    }"
               ""
               "  /*Allocating memory*/"
               "  if(firstdraw == 1)"
               "    {"
               "      scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, number_of_curves_by_subwin);"
               "      /*Must be placed before adding polyline or other elements*/"
               "      scoSetLongDrawSize(*pScopeMemory, 0, 50);"
               "      scoSetShortDrawSize(*pScopeMemory,0,buffer_size);"
               "      scoSetPeriod(*pScopeMemory,0,period);"
               "    }"
               ""
               "  xmin = period*scoGetPeriodCounter(*pScopeMemory,0);"
               "  xmax = period*(scoGetPeriodCounter(*pScopeMemory,0)+1);"
               ""
               "  /*Creating the Scope*/"
               "  scoInitOfWindow(*pScopeMemory, dimension, win, win_pos, win_dim, &xmin, &xmax, &ymin, &ymax, NULL, NULL);"
               "  if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "    {"
               "      scoAddTitlesScope(*pScopeMemory,label,""t"",""y"",NULL);"
               "      /*Add a couple of polyline : one for the shortdraw and one for the longdraw*/"
               "      scoAddCoupleOfPolylines(*pScopeMemory,colors);"
               "      /* scoAddPolylineLineStyle(*pScopeMemory,colors); */"
               "    }"
               "  scicos_free(colors);"
               "}"
               ""
               "/** \fn void cscope(scicos_block * block,int flag)"
               "    \brief the computational function"
               "    \param block A pointer to a scicos_block"
               "    \param flag An integer which indicates the state of the block (init, update, ending)"
               "*/"
               "void cscope(scicos_block * block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  ScopeMemory * pScopeMemory;"
               "  int i;"
               "  double t;"
               "  int NbrPtsShort;"
               "  double * u1;"
               "  scoGraphicalObject pShortDraw;"
               "  int **user_data_ptr,*size_ptr;"
               ""
               "  switch(flag)"
               "    {"
               "    case Initialization:"
               "      {"
               "        cscope_draw(block,&pScopeMemory,1);"
               "        break;"
               "      }"
               "    case StateUpdate:"
               "      {"
               "        scoRetrieveScopeMemory(_work,&pScopeMemory);"
               "        if(scoGetPointerScopeWindow(pScopeMemory) == NULL) return;"
               "        if(scoGetScopeActivation(pScopeMemory) == 1)"
               "          {"
               "            t = get_scicos_time();"
               "        /*Retreiving Scope in the _work*/"
               "            "
               ""
               "        /*Maybe we are in the end of axes so we have to draw new ones */"
               "        scoRefreshDataBoundsX(pScopeMemory,t);"
               ""
               "        //Cannot be factorized depends of the scope"
               "        u1 = GetRealInPortPtrs(block,1);"
               "        for (i = 0 ; i < scoGetNumberOfCurvesBySubwin(pScopeMemory,0) ; i++)"
               "          {"
               "            pShortDraw  = scoGetPointerShortDraw(pScopeMemory,0,i);"
               "            NbrPtsShort = pPOLYLINE_FEATURE(pShortDraw)->n1;"
               "            pPOLYLINE_FEATURE(pShortDraw)->pvx[NbrPtsShort] = t;"
               "            pPOLYLINE_FEATURE(pShortDraw)->pvy[NbrPtsShort] = u1[i];"
               "            pPOLYLINE_FEATURE(pShortDraw)->n1++;"
               "          }"
               "        //End of Cannot"
               ""
               "        //Draw the Scope"
               "        scoDrawScopeAmplitudeTimeStyle(pScopeMemory, t);"
               "          }"
               "        break;"
               "      }"
               "    case Ending:"
               "      {"
               "        scoRetrieveScopeMemory(_work, &pScopeMemory);"
               "        if(scoGetScopeActivation(pScopeMemory) == 1) {"
               "          if(scoGetPointerScopeWindow(pScopeMemory) != NULL) {"
               "            sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "            pShortDraw = sciGetCurrentFigure();"
               "            sciGetPointerToUserData (pShortDraw,&user_data_ptr, &size_ptr);"
               "            FREE(*user_data_ptr);"
               "            *user_data_ptr=NULL;"
               "            *size_ptr = 0;"
               "            scoDelCoupleOfPolylines(pScopeMemory);"
               "          }"
               "        }"
               "        scoFreeScopeMemory(_work, &pScopeMemory);"
               "        break;  "
               "      }"
               "    }"
               "}"]

      case 'cscopxy' then
        txt = ["/**"
               "   \file cscopxy.c"
               "   \author Benoit Bayol"
               "   \version 1.0"
               "   \date September 2006 - January 2007"
               "   \brief CSCOPXY is a scope in 2D which draw its input as a XY scope, there is no animation, everything is keep in memory instead of CANIMXY"
               "   \see CSCOPXY.sci in macros/scicos_blocks/Sinks/"
               "*/"
               ""
               "#include ""scoMemoryScope.h"""
               "#include ""scoWindowScope.h"""
               "#include ""scoMisc.h"""
               "#include ""scoGetProperty.h"""
               "#include ""scoSetProperty.h"""
               "#include ""scicos_block4.h"""
               ""
               "/** \fn cscopxy_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "    \brief Function to draw or redraw the window"
               "*/"
               "void cscopxy_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "{"
               " int * ipar; //Integer Parameters"
               "  int color_flag; //Flag on Color"
               "  int color[2];"
               "  int line_size;"
               "  int animed;"
               "  int win; //Windows ID : To give a name to the window"
               "  int buffer_size; //Buffer Size"
               "  int win_pos[2]; //Position of the Window"
               "  int win_dim[2]; //Dimension of the Window"
               "  int nipar;"
               "  double * rpar; //Reals parameters"
               "  double xmin, xmax, ymin, ymax; //Ymin and Ymax are vectors here"
               "  int number_of_subwin;"
               "  int number_of_curves_by_subwin;"
               "  int dimension = 2;"
               "  int i;"
               "  char *label;"
               "  scoGraphicalObject ShortDraw;"
               "  scoGraphicalObject LongDraw;"
               ""
               "  /*Retrieving Parameters*/"
               "  ipar = GetIparPtrs(block);"
               "  nipar = GetNipar(block);"
               "  rpar = GetRparPtrs(block);"
               "  win = ipar[0];"
               "  color_flag = ipar[1];"
               "  buffer_size = ipar[2];"
               "  color[0] = ipar[3];"
               "  color[1] = ipar[3];"
               "  line_size = ipar[4];"
               "  animed = ipar[5];"
               "  win_pos[0] = ipar[6];"
               "  win_pos[1] = ipar[7];"
               "  win_dim[0] = ipar[8];"
               "  win_dim[1] = ipar[9];"
               "  xmin = rpar[0];"
               "  xmax = rpar[1];"
               "  ymin = rpar[2];"
               "  ymax = rpar[3];"
               "  label = GetLabelPtrs(block);"
               ""
               "  number_of_subwin = 1;"
               "  number_of_curves_by_subwin = ipar[10]; //it is a trick to recognize the type of scope, not sure it is a good way because normally a curve is the combination of a short and a longdraw"
               "  if(firstdraw == 1)"
               "    {"
               "      scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, &number_of_curves_by_subwin);"
               "      scoSetShortDrawSize(*pScopeMemory,0,buffer_size);"
               "      scoSetLongDrawSize(*pScopeMemory,0,5000);"
               "    }"
               ""
               "  scoInitOfWindow(*pScopeMemory, dimension, win, win_pos, win_dim, &xmin, &xmax, &ymin, &ymax, NULL, NULL);"
               "  if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "    {"
               "      for( i = 0 ; i < number_of_curves_by_subwin ; i++)"
               "        {"
               "          scoAddPolylineForShortDraw(*pScopeMemory,0,i,color[0]);"
               "          scoAddPolylineForLongDraw(*pScopeMemory,0,i,color[0]);"
               "          ShortDraw = scoGetPointerShortDraw(*pScopeMemory,0,i);"
               "          LongDraw = scoGetPointerLongDraw(*pScopeMemory,0,i);"
               "          /* Set ShortDraw properties */"
               "          sciSetLineWidth(ShortDraw, line_size);"
               "          sciSetMarkSize(ShortDraw, line_size);"
               "          /* Set LongDraw properties */"
               "          sciSetLineWidth(LongDraw, line_size);"
               "          sciSetMarkSize(LongDraw, line_size);"
               "        }"
               "      scoAddTitlesScope(*pScopeMemory,label,""x"",""y"",NULL);"
               "    }"
               "}"
               ""
               ""
               "/** \fn void cscopxy(scicos_block * block, int flag)"
               "    \brief the computational function"
               "    \param block A pointer to a scicos_block"
               "    \param flag An integer which indicates the state of the block (init, update, ending)"
               "*/"
               "void cscopxy(scicos_block * block, int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  /* Declarations*/"
               "  ScopeMemory * pScopeMemory;"
               "  double *u1,*u2;"
               "  scoGraphicalObject Pinceau; "
               "  int NbrPtsShort;"
               "  int i;"
               "  int **user_data_ptr,*size_ptr;"
               ""
               "  /* State Machine Control */"
               "  switch(flag)"
               "    {"
               "    case Initialization:"
               "      {"
               "        cscopxy_draw(block,&pScopeMemory,1);"
               "        break; //Break of the switch condition don t forget it"
               "      } //End of Initialization"
               ""
               "    case StateUpdate:"
               "      {"
               "        scoRetrieveScopeMemory(_work,&pScopeMemory);"
               "        if (scoGetPointerScopeWindow(pScopeMemory) == NULL) return;"
               "        if(scoGetScopeActivation(pScopeMemory) == 1)"
               "          {"
               "            "
               "        /* Charging Elements */"
               ""
               ""
               "        u1 = GetRealInPortPtrs(block,1);"
               "        u2 = GetRealInPortPtrs(block,2);"
               "        "
               "        for(i = 0 ; i < scoGetNumberOfCurvesBySubwin(pScopeMemory,0); i++)"
               "          {"
               "            Pinceau = scoGetPointerShortDraw(pScopeMemory,0,i);"
               "            NbrPtsShort = pPOLYLINE_FEATURE(Pinceau)->n1;"
               "            pPOLYLINE_FEATURE(Pinceau)->pvx[NbrPtsShort] = u1[i];"
               "            pPOLYLINE_FEATURE(Pinceau)->pvy[NbrPtsShort] = u2[i];"
               "            pPOLYLINE_FEATURE(Pinceau)->n1++;"
               "          }"
               "        "
               "        scoDrawScopeXYStyle(pScopeMemory);"
               "          }"
               "        break; //Break of the switch don t forget it !"
               "      }//End of stateupdate"
               "      "
               "      //This case is activated when the simulation is done or when we close scicos"
               "    case Ending:"
               "      {"
               "        scoRetrieveScopeMemory(_work, &pScopeMemory);"
               "        if(scoGetScopeActivation(pScopeMemory) == 1) {"
               "          if(scoGetPointerScopeWindow(pScopeMemory) != NULL) {"
               "            sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "            Pinceau = sciGetCurrentFigure();"
               "            sciGetPointerToUserData (Pinceau,&user_data_ptr, &size_ptr);"
               "            FREE(*user_data_ptr);"
               "            *user_data_ptr=NULL;"
               "            *size_ptr = 0;"
               "          }"
               "        }"
               "        scoFreeScopeMemory(_work, &pScopeMemory);"
               "        break; //Break of the switch"
               "      }"
               "      //free the memory which is allocated at each turn by some variables"
               "    }"
               "}"]

      case 'cscopxy3d' then
        txt = ["/**"
               "   \file cscopxy3d.c"
               "   \author Benoit Bayol"
               "   \version 1.0"
               "   \date September 2006 - January 2007"
               "   \brief CSCOPXY3D is a scope in 2D which draw its input as a XYZ scope, there is no animation, everything is keep in memory instead of CANIMXY3D"
               "   \see CSCOPXY3D.sci in macros/scicos_blocks/Sinks/"
               "*/"
               ""
               "#include ""scoMemoryScope.h"""
               "#include ""scoWindowScope.h"""
               "#include ""scoMisc.h"""
               "#include ""scoGetProperty.h"""
               "#include ""scoSetProperty.h"""
               "#include ""scicos_block4.h"""
               ""
               "/** \fn cscopxy3d_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "    \brief Function to draw or redraw the window"
               "*/"
               "void cscopxy3d_draw(scicos_block * block, ScopeMemory ** pScopeMemory, int firstdraw)"
               "{"
               "  int * ipar; //Integer Parameters"
               "  int color_number; //Flag on Color"
               "  int * color   ;"
               "  int * line_size;"
               "  int animed;"
               "  int win; //Windows ID : To give a name to the window"
               "  int buffer_size; //Buffer Size"
               "  int win_pos[2]; //Position of the Window"
               "  int win_dim[2]; //Dimension of the Window"
               "  int nipar;"
               "  double * rpar; //Reals parameters"
               "  double xmin, xmax, ymin, ymax, zmin, zmax,alpha, theta; //Ymin and Ymax are vectors here"
               "  int number_of_subwin;"
               "  int number_of_curves_by_subwin;"
               "  int dimension = 3;"
               "  int i;"
               "  int size=0;"
               "  char *label;"
               "  scoGraphicalObject ShortDraw;"
               "  scoGraphicalObject LongDraw;"
               ""
               "  /*Retrieving Parameters*/"
               "  ipar = GetIparPtrs(block);"
               "  nipar = GetNipar(block);"
               "  rpar = GetRparPtrs(block);"
               "  win = ipar[0];"
               "  color_number = ipar[1];"
               "  buffer_size = ipar[2];"
               "  label = GetLabelPtrs(block);"
               "  color = (int*)scicos_malloc(color_number*sizeof(int));"
               "  line_size = (int*)scicos_malloc(color_number*sizeof(int));"
               "  for(i = 0 ; i < color_number ; i++)"
               "    {"
               "      color[i] = ipar[i+3];"
               "      line_size[i] = ipar[i+3+color_number];"
               "    }"
               "  size = 2*color_number;"
               "  animed = ipar[size+3];"
               "  win_pos[0] = ipar[size+4];"
               "  win_pos[1] = ipar[size+5];"
               "  win_dim[0] = ipar[size+6];"
               "  win_dim[1] = ipar[size+7];"
               "  xmin = rpar[0];"
               "  xmax = rpar[1];"
               "  ymin = rpar[2];"
               "  ymax = rpar[3];"
               "  zmin = rpar[4];"
               "  zmax = rpar[5];"
               "  alpha = rpar[6];"
               "  theta = rpar[7];"
               ""
               "  number_of_subwin = 1;"
               "  number_of_curves_by_subwin = ipar[size+8]; //it is a trick to recognize the type of scope, not sure it is a good way because normally a curve is the combination of a short and a longdraw"
               ""
               "  if(firstdraw == 1)"
               "    {"
               "      scoInitScopeMemory(GetPtrWorkPtrs(block),pScopeMemory, number_of_subwin, &number_of_curves_by_subwin);"
               "      scoSetShortDrawSize(*pScopeMemory,0,buffer_size);"
               "      scoSetLongDrawSize(*pScopeMemory,0,5000);"
               "    }"
               ""
               "  scoInitOfWindow(*pScopeMemory, dimension, win, win_pos, win_dim, &xmin, &xmax, &ymin, &ymax, &zmin, &zmax);"
               "  if(scoGetScopeActivation(*pScopeMemory) == 1)"
               "    {"
               "      pSUBWIN_FEATURE(scoGetPointerAxes(*pScopeMemory,0))->alpha = alpha;"
               "      pSUBWIN_FEATURE(scoGetPointerAxes(*pScopeMemory,0))->theta = theta;       "
               "      scoAddTitlesScope(*pScopeMemory,label,""x"",""y"",""z"");"
               "      "
               "        "
               "      for(i = 0 ; i < scoGetNumberOfCurvesBySubwin(*pScopeMemory,0) ; i++)"
               "        {"
               "          scoAddPolylineForShortDraw(*pScopeMemory,0,i,color[i]);"
               "          scoAddPolylineForLongDraw(*pScopeMemory,0,i,color[i]);"
               "          "
               "          ShortDraw = scoGetPointerShortDraw(*pScopeMemory,0,i);"
               "          LongDraw = scoGetPointerLongDraw(*pScopeMemory,0,i);"
               "          "
               "          /* Set ShortDraw properties */"
               "          sciSetLineWidth(ShortDraw, line_size[i]);"
               "          sciSetMarkSize(ShortDraw, line_size[i]);"
               ""
               "          /* Set LongDraw properties */"
               "          sciSetLineWidth(LongDraw, line_size[i]);"
               "          sciSetMarkSize(LongDraw, line_size[i]);"
               ""
               "        }"
               "    }"
               "  scicos_free(color);"
               "  scicos_free(line_size);"
               "}"
               "/** \fn void cscopxy3d(scicos_block * block, int flag)"
               "    \brief the computational function"
               "    \param block A pointer to a scicos_block"
               "    \param flag An integer which indicates the state of the block (init, update, ending)"
               "*/"
               "void cscopxy3d(scicos_block * block, int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  /* Declarations*/"
               "  int i;"
               "  ScopeMemory * pScopeMemory;"
               "  scoGraphicalObject Pinceau; //Pointer to each polyline of each axes"
               "  double *u1,*u2, *u3;"
               "  int NbrPtsShort;"
               "  int **user_data_ptr,*size_ptr;"
               ""
               ""
               "  /* State Machine Control */"
               "  switch(flag)"
               "    {"
               "    case Initialization:"
               "      {"
               "        cscopxy3d_draw(block,&pScopeMemory, 1);"
               "        break; //Break of the switch condition don t forget it"
               "      } //End of Initialization"
               ""
               "    case StateUpdate:"
               "      {"
               "        scoRetrieveScopeMemory(_work,&pScopeMemory);"
               "        if (scoGetPointerScopeWindow(pScopeMemory) == NULL) return;"
               "        if(scoGetScopeActivation(pScopeMemory) == 1)"
               "          {"
               "            /* Charging Elements */"
               "          "
               ""
               "            u1 = GetRealInPortPtrs(block,1);"
               "            u2 = GetRealInPortPtrs(block,2);"
               "            u3 = GetRealInPortPtrs(block,3);"
               "            "
               "            for(i = 0 ; i < scoGetNumberOfCurvesBySubwin(pScopeMemory,0) ; i++)"
               "              {"
               "                Pinceau = scoGetPointerShortDraw(pScopeMemory,0,i);"
               "                "
               "                NbrPtsShort = pPOLYLINE_FEATURE(Pinceau)->n1;"
               "                "
               "                pPOLYLINE_FEATURE(Pinceau)->pvx[NbrPtsShort] = u1[i];"
               "                pPOLYLINE_FEATURE(Pinceau)->pvy[NbrPtsShort] = u2[i];"
               "                pPOLYLINE_FEATURE(Pinceau)->pvz[NbrPtsShort] = u3[i];"
               "            "
               "                pPOLYLINE_FEATURE(Pinceau)->n1++;"
               "              }"
               "            "
               "            scoDrawScopeXYStyle(pScopeMemory);"
               "          }"
               "            break; //Break of the switch don t forget it !"
               "          }//End of stateupdate"
               "      "
               "      //This case is activated when the simulation is done or when we close scicos"
               "    case Ending:"
               "      {"
               "        scoRetrieveScopeMemory(_work, &pScopeMemory);"
               "        if(scoGetScopeActivation(pScopeMemory) == 1) {"
               "          if(scoGetPointerScopeWindow(pScopeMemory) != NULL) {"
               "            sciSetUsedWindow(scoGetWindowID(pScopeMemory));"
               "            Pinceau = sciGetCurrentFigure();"
               "            sciGetPointerToUserData (Pinceau,&user_data_ptr, &size_ptr);"
               "            FREE(*user_data_ptr);"
               "            *user_data_ptr=NULL;"
               "            *size_ptr = 0;"
               "          }"
               "        }"
               "        scoFreeScopeMemory(_work, &pScopeMemory);"
               "        break; //Break of the switch"
               "      }"
               "      //free the memory which is allocated at each turn by some variables"
               "    }"
               "}"]

      case 'csslti4' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "extern int C2F(dmmul)();"
               "extern int C2F(dmmul1)();"
               ""
               "void csslti4(scicos_block *block,int flag)"
               "{"
               "  "
               "  /*  Copyright INRIA"
               ""
               "      Scicos block simulator"
               "      continuous state space linear system simulator"
               "      rpar(1:nx*nx)=A"
               "      rpar(nx*nx+1:nx*nx+nx*nu)=B"
               "      rpar(nx*nx+nx*nu+1:nx*nx+nx*nu+nx*ny)=C"
               "      rpar(nx*nx+nx*nu+nx*ny+1:nx*nx+nx*nu+nx*ny+ny*nu)=D */"
               "  "
               "  int un=1,lb,lc,ld;"
               "  int nx=GetNstate(block);"
               "  double* x=GetState(block);"
               "  double* xd=GetDerState(block);"
               "  double* rpar=GetRparPtrs(block);"
               "  double* y=GetRealOutPortPtrs(block,1);"
               "  double* u=GetRealInPortPtrs(block,1);"
               "  int noutsz=GetOutPortRows(block,1);"
               "  int ninsz=GetInPortRows(block,1);"
               "  "
               "  lb=nx*nx;"
               "  lc=lb+nx*ninsz;"
               "  "
               "  if (flag ==1 || flag ==6){"
               "    /* y=c*x+d*u     */"
               "    ld=lc+nx*noutsz;"
               "    if (nx==0) {"
               "      C2F(dmmul)(&rpar[ld],&noutsz,u,&ninsz,y,&noutsz,&noutsz,&ninsz,&un);"
               "    }else{"
               "      C2F(dmmul)(&rpar[lc],&noutsz,x,&nx,y,&noutsz,&noutsz,&nx,&un);"
               "      C2F(dmmul1)(&rpar[ld],&noutsz,u,&ninsz,y,&noutsz,&noutsz,&ninsz,&un);"
               "    }"
               "  }"
               ""
               "  else if (flag ==0){"
               "    /* xd=a*x+b*u */"
               "    C2F(dmmul)(&rpar[0],&nx,x,&nx,xd,&nx,&nx,&nx,&un);"
               "    C2F(dmmul1)(&rpar[lb],&nx,u,&ninsz,xd,&nx,&nx,&ninsz,&un);"
               "  }"
               "}"
               ""
               ""
               ""]

      case 'cstblk4' then
        txt = ["#include <memory.h>"
               "#include ""scicos_block4.h"""
               ""
               "void cstblk4(scicos_block *block,int flag)"
               "{ "
               "  double *_rpar=GetRparPtrs(block);"
               "  int _nrpar=GetNrpar(block);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  /* Copyright INRIA"
               "     "
               "  Scicos block simulator"
               "  output a vector of constants out(i)=rpar(i)"
               "  rpar(1:nrpar) : given constants */"
               "  "
               "  memcpy(_y1,_rpar,_nrpar*sizeof(double));    "
               "}"]

      case 'cstblk4_m' then
        txt = ["#include <memory.h>"
               "#include ""scicos_block4.h"""
               "#include<stdio.h>"
               ""
               "void cstblk4_m(scicos_block *block,int flag)"
               "{ "
               "  /* Copyright INRIA"
               ""
               "  Scicos block simulator"
               "  output a vector of constants out(i)=opar(i)"
               "  opar(1:nopar) : given constants */"
               "  int nopar,mo,no,so;"
               "  void *y;"
               "  void *opar;"
               "  nopar = GetNopar(block);"
               "  y=GetOutPortPtrs(block,1);"
               "  opar=GetOparPtrs(block,1);"
               "  mo=GetOparSize(block,1,1);"
               "  no=GetOparSize(block,1,2);"
               "  so=GetSizeOfOpar(block,1);"
               "  memcpy(y,opar,mo*no*so);"
               "}"]

      case 'cumsum_m' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "void cumsum_m(scicos_block *block,int flag)"
               "{"
               "  double *u;"
               "  double *y;"
               "  int nu,mu,j;"
               "  mu=GetInPortRows(block,1);"
               "  nu=GetInPortCols(block,1);"
               ""
               "  u=GetRealInPortPtrs(block,1);"
               "  y=GetRealOutPortPtrs(block,1);"
               ""
               "  y[0]=u[0];"
               "  for(j=1;j<mu*nu;j++)"
               "       {y[j]=u[j]+y[j-1];"
               "       }"
               "}"]

      case 'curve_c' then
        txt = ["#include ""scicos_block4.h"""
               ""
               "/*    Masoud Najafi, August 2007 */"
               "/*    Copyright INRIA"
               " *    Scicos block simulator"
               " *    Signal builder block"
               " */"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "int Myevalhermite(double *t, double *xa, double *xb, double *ya, double *yb, double *da, double *db, double *h, double *dh, double *ddh, double *dddh, int *i);"
               ""
               "void curve_c(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  double *_rpar=GetRparPtrs(block);"
               "  int *_ipar=GetIparPtrs(block);"
               "  double *_evout= GetNevOutPtrs(block);"
               "  double t,a,b,c,y1,y2,t1,t2;"
               "  int *ind,i,inow;"
               "  double *y;"
               "  double  d1,d2,h, dh, ddh, dddh;"
               "  double *rpar,T;"
               "  int nPoints,Order,Periodic, phase;"
               "  "
               "  rpar= _rpar;"
               "  nPoints=  _ipar[0];"
               "  Order=    _ipar[1];"
               "  Periodic= _ipar[2];"
               "  T= rpar[nPoints-1]-rpar[0];"
               ""
               ""
               "  switch(flag)"
               "  {"
               "   /* init */"
               "   case 4  : {/* the workspace is used to store discrete counter value */"
               "              if ((*_work=scicos_malloc(4*sizeof(int)))==NULL) {"
               "                set_block_error(-16);"
               "                return;"
               "              }"
               "              ind=*_work;"
               "              ind[0]=nPoints-1;"
               "              ind[1]=nPoints;"
               "              for (i=0;i<nPoints;i++){"
               "                if (rpar[i]>=0 ) {"
               "                  ind[0]=i-1;"
               "                  ind[1]=i;"
               "                  break;"
               "                }"
               "              }"
               "              ind[0]=-1;"
               "              ind[1]=0;"
               "              ind[2]=0; /* event index */"
               "              ind[3]=0; /* event counter */"
               "              return;"
               ""
               "              break;"
               "             }"
               "   /* event date computation */"
               "  case 1  : { "
               "              y=GetRealOutPortPtrs(block,1);"
               "              ind=*_work;"
               "              t=get_scicos_time();"
               "              phase= get_phase_simulation();"
               ""
               "              if (Periodic==1) {"
               "                if (ind[3]>0)"
               "                  t=t-(ind[3]-1)*T;"
               "              }"
               "              "
               "              if (phase==0 || phase==1) {"
               "                inow=nPoints-1;"
               "                for (i=ind[0];i<nPoints;i++){           "
               "                  if (i==-1) continue;"
               "                  if (t<rpar[i]) {"
               "                    inow=i-1;"
               "                    if (inow>=ind[1]){"
               "                      ind[0]=ind[1];"
               "                    }"
               "                    break;"
               "                  }"
               "                }"
               "                ind[1]=inow;"
               "              }"
               "              if (phase==2) {"
               "                inow=ind[1];"
               "              }"
               "              if (inow<0) {y[0]=0.0;    break;}"
               "              if (inow>=nPoints-1) {y[0]=rpar[nPoints*2-1];break;}"
               "              if (Order==0) {"
               "                y[0]=rpar[nPoints+inow];"
               "                break;"
               "              }"
               "              if(Order==1) {"
               "                t1=rpar[inow];"
               "                t2=rpar[inow+1];"
               "                y1=rpar[nPoints+inow];"
               "                y2=rpar[nPoints+inow+1];"
               "                y[0]=(y2-y1)*(t-t1)/(t2-t1)+y1;"
               "                break;"
               "              }"
               ""
               "              if((Order==2)&&(nPoints>2)) {"
               "                t1=rpar[inow];"
               "                a=rpar[2*nPoints+inow];"
               "                b=rpar[2*nPoints+inow+nPoints-1];"
               "                c=rpar[2*nPoints+inow+2*nPoints-2];"
               "                y[0]=a*(t-t1)*(t-t1)+b*(t-t1)+c;"
               "                break;"
               "              }      "
               ""
               "              if((Order>=3)) {"
               "                t1=rpar[inow];"
               "                t2=rpar[inow+1];"
               "                y1=rpar[nPoints+inow];"
               "                y2=rpar[nPoints+inow+1];"
               "                d1=rpar[2*nPoints+inow];"
               "                d2=rpar[2*nPoints+inow+1];"
               "                Myevalhermite(&t, &t1,&t2, &y1,&y2, &d1,&d2, &h, &dh, &ddh, &dddh, &inow);"
               "                y[0]=h;"
               "                break;"
               "              }"
               ""
               "              break;"
               "             }"
               "   /* event date computation */"
               "  case 3  : {"
               "              ind=*_work;"
               ""
               "              /*---------*/"
               "              if ((Order==1)||(Order==0)){"
               "                i=ind[2];"
               "                if (i==nPoints-1){ "
               "                  if (Periodic==1) {"
               "                    i=0;"
               "                    ind[0]=-1;"
               "                    ind[1]=0;"
               "                  }"
               "                }"
               "                if (i<nPoints-1) {"
               "                  _evout[0]=rpar[i+1]-rpar[i];"
               ""
               "                  ind[2]=i+1;"
               "                }"
               "                if (ind[2]==1)  ind[3]++;"
               "              }"
               "              /*-------------------*/"
               "              if (Order>=2){"
               "                if ( Periodic) {"
               "                  _evout[0]=T;"
               "                }else{"
               "                  if (ind[3]==0) {"
               "                    _evout[0]=T;"
               "                  }"
               "                }"
               "                ind[3]++;"
               "                ind[0]=-1;"
               "                ind[1]=0;"
               "                    "
               "              }"
               "              break;"
               "             }"
               "  case 2:"
               "             break;"
               "    /* finish */"
               "   case 5  : {"
               "              scicos_free(*_work); /*free the workspace*/"
               "              break;"
               "             }"
               ""
               "   default : break;"
               "  }"
               "}"
               ""
               "int Myevalhermite(double *t, double *x1, double *x2, double *y1, double *y2, double *d1, double *d2, double *z, double *dz, double *ddz, double *dddz, int *k)"
               "{"
               "  double Temp, p, p2, p3, D;"
               "  Temp = *t - *x1;"
               "  D = 1.0 / (*x2 - *x1);"
               "  p = (*y2 - *y1) * D;"
               "  p2 = (p - *d1) * D;"
               "  p3 = (*d2 - p + (*d1 - p)) * (D * D);"
               "  *z = p2 + p3 * (*t - *x2);"
               "  *dz = *z + p3 * Temp;"
               "  *ddz = (*dz + p3 * Temp) * 2.;"
               "  *dddz = p3 * 6.0;"
               "  *z = *d1 + *z * Temp;"
               "  *dz = *z + *dz * Temp;"
               "  *z = *y1 + *z * Temp;"
               "  return 0; "
               "}  "
               ""]

      case 'deadband' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               "void deadband(scicos_block *block,int flag)"
               "{/* rpar[0]:upper limit,  rpar[1]:lower limit */"
               "  double *_rpar=GetRparPtrs(block);"
               "  int _ng=GetNg(block);"
               "  double *_g=GetGPtrs(block);"
               "  int *_mode=GetModePtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  if (flag==1){"
               "    if (get_phase_simulation()==1||_ng==0) {"
               "      if (*_u1>=_rpar[0]){"
               "        _y1[0]=*_u1-_rpar[0];"
               "      }else if (*_u1<=_rpar[1]){"
               "        _y1[0]=*_u1-_rpar[1];"
               "      }else {"
               "        _y1[0]=0.0;"
               "      }"
               "    }else{"
               "      if (_mode[0]==1){"
               "        _y1[0]=*_u1-_rpar[0];"
               "      }else if(_mode[0]==2) {"
               "        _y1[0]=*_u1-_rpar[1];"
               "      }else{"
               "        _y1[0]=0.0;"
               "      } "
               "    }"
               "  } else if (flag==9){"
               "    _g[0]=*_u1-(_rpar[0]);"
               "    _g[1]=*_u1-(_rpar[1]);"
               "    if (get_phase_simulation()==1) {"
               "      if (_g[0]>=0){"
               "        _mode[0]=1;"
               "      }else if (_g[1]<=0){"
               "        _mode[0]=2;"
               "      }else {"
               "        _mode[0]=3;"
               "      }"
               "    }"
               "  }"
               "}"
               ""]

      case 'delay4' then
        txt = ["#include ""scicos_block4.h"""
               ""
               "void delay4(scicos_block *block,int flag)"
               "{"
               "  "
               "  /* Copyright INRIA"
               "   "
               "     Scicos block simulator"
               "     Ouputs nx*dt delayed input */"
               ""
               "  double* y=GetRealOutPortPtrs(block,1);"
               "  double* z=GetDstate(block);"
               "  int nz=GetNdstate(block);"
               "  double* u=GetRealInPortPtrs(block,1);"
               "  "
               "  int i;"
               "  "
               "  if (flag ==1 || flag ==4 || flag ==6){"
               "    y[0]=z[0];"
               "  }else if (flag == 2){"
               "    /*  shift buffer */"
               "    for (i=0; i<=nz-2; i++){"
               "      z[i]=z[i+1];"
               "    }"
               "    /* add new point to the buffer */"
               "    z[nz-1]=u[0];"
               "  }"
               "}"
               ""
               "    "]

      case 'deriv' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               "#include <stdio.h>"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "void deriv(scicos_block *block,int flag)"
               "{ "
               "  void **_work=GetPtrWorkPtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  /* int  nevprt=GetNevIn(block);*/"
               "  double* rw;"
               "  double t;"
               "  double a0,b0,a1,b1,d,x0,x1,x2,u0,u1,u2;"
               "  int i, phase;"
               "  t=get_scicos_time();"
               "  phase= get_phase_simulation();"
               "  if (flag == 4){/* the workspace is used to store previous values */"
               "    if ((*_work= scicos_malloc(sizeof(double)*2*(1+GetInPortRows(block,1))))== NULL ) {"
               "      set_block_error(-16);"
               "      return;"
               "    }"
               "    rw=*_work; "
               "    rw[0]=t;"
               "    rw[1]=t;"
               "    for(i=0;i<GetInPortRows(block,1);++i){"
               "      rw[2+2*i]=0;"
               "      rw[3+2*i]=0;"
               "    }"
               "  }else  if (flag == 5){"
               "    scicos_free(*_work);"
               "  }else  if (flag == 1 ) {"
               "    rw=*_work;"
               "    x0=rw[0];"
               "    x1=rw[1];"
               "    x2=t;"
               "    for(i=0;i<GetInPortRows(block,1);++i){"
               "      u0=rw[2+2*i];"
               "      u1=rw[3+2*i];"
               "      u2=_u1[i];"
               "      d=(x1-x2)*(x0-x2)*(x1-x0);"
               "      if( d!=0){"
               "        a0=((u2-u1)*(x1-x0)-(x2-x1)*(u1-u0))/d;     "
               "        a1=a0;"
               "        b0=(u1-u0)/(x1-x0)-a0*(x1-x0);"
               "        b1=2*a0*(x1-x0)+b0;"
               "        _y1[i]=2*a1*(x2-x1)+b1;"
               "      }else{"
               "        if(x2-x1!=0.0) {"
               "          _y1[i]=(u2-u1)/(x2-x1);"
               "        }else{"
               "          if(x2-x0!=0.0) {"
               "            _y1[i]=(u2-u0)/(x2-x0);"
               "          }else{"
               "            _y1[i]=0.0;"
               "          }"
               "        }"
               "      }"
               "    }/* for loop */"
               "    fprintf(stderr, ""\n\r OUt  =%g"", _y1[0]);"
               ""
               "  } /*  if (flag == 1)  */"
               "  else if (flag == 2 ) { /* called by odoit/ddoit & nevprt <=0 */"
               "    rw=*_work;"
               "    x0=rw[0];"
               "    x1=rw[1];"
               "    x2=t;"
               "    for(i=0;i<GetInPortRows(block,1);++i){"
               "      u0=rw[2+2*i];"
               "      u1=rw[3+2*i];"
               "      u2=_u1[i];"
               "      /*--------- memory shifting ------------*/"
               "      fprintf(stderr, ""\n\r update  t=%g"", t);"
               "      if (x2>=x1){"
               "        if (x2>x1){"
               "          rw[0]=x1;"
               "          rw[2+2*i]=u1;"
               "        }"
               "        rw[1]=x2;"
               "        rw[3+2*i]=u2;"
               "      }"
               "      /*---------- memory shifting ------------*/"
               "    }"
               "  } /*  if (flag == 2)  */"
               "} "
               "  "
               ""
               ""
               "/*"
               "  cubic interpolation ""natural"""
               "s0(x)=a0*(x-x0)^3+b0*(x-x0)^2+c0*(x-x0)+u0;"
               "s1(x)=a1*(x-x1)^3+b1*(x-x1)^2+c1*(x-x1)+u1;"
               ""
               "constraints:"
               "s0(x1)   = s1(x1)"
               "sp0(x1)  = sp1(x1)"
               "spp0(x1) = spp1(x1)"
               ""
               "s1(x2)=u2"
               "Natural method:"
               "spp0(x0) = 0"
               "spp1(x2) = 0"
               ""
               "d=2*(x0-x2)*(x0-x1)*(x2-x1)*(x1-x0);"
               "a0=(u2*(x1-x0)+u0*(x2-x1)+u1*(x0-x2))/d;"
               "a1=a0*(x1-x0)/(x1-x2);"
               "b1=3*a0*(x1-x0);"
               "c1=(u2-u1)/(x2-x1)+2*a0*(x1-x2)*(x1-x0);"
               "_y1[i]=3*a1*(x2-x1)*(x2-x1)+2*b1*(x2-x1)+c1;"
               ""
               "*/"
               ""
               ""
               "/*"
               "  squre interpolation ""natural"""
               "s0(x)=a0*(x-x0)^2+b0*(x-x0)+u0;"
               "s1(x)=a1*(x-x1)^2+b1*(x-x1)+u1;"
               ""
               "constraints:"
               "s0(x1)   = s1(x1)"
               "sp0(x1)  = sp1(x1)"
               "spp0(x1) = spp1(x1)"
               "s1(x2)   = u2"
               ""
               "d=(x1-x2)*(x0-x2)*(x1-x0);"
               "a0=((u2-u1)*(x1-x0)-(x2-x1)*(u1-u0))/d;     "
               "a1=a0;"
               "b0=(u1-u0)/(x1-x0)-a0*(x1-x0);"
               "b1=2*a0*(x1-x0)+b0;"
               "_y1[i]=2*a1*(x2-x1)+b1;"
               "*/"]

      case 'dgelsy1' then
        txt = ["/* Table of constant values */"
               ""
               "static int c__1 = 1;"
               "static int c_n1 = -1;"
               "static int c__0 = 0;"
               "static double c_b31 = 0.;"
               "static int c__2 = 2;"
               "static double c_b54 = 1.;"
               ""
               "#define min(a,b) ((a) <= (b) ? (a) : (b))"
               "#define max(a,b) ((a) >= (b) ? (a) : (b))"
               "#define abs(x) ((x) >= 0 ? (x) : -(x))"
               ""
               "/* Subroutine */ int dgelsy1_(int *m, int *n, int *nrhs, "
               "        double *a, int *lda, double *b, int *ldb, int *"
               "        jpvt, double *rcond, int *rank, double *work, int *"
               "        lwork, int *info)"
               "{"
               "    /* System generated locals */"
               "    int a_dim1, a_offset, b_dim1, b_offset, i__1, i__2;"
               "    double d__1, d__2;"
               ""
               "    /* Local variables */"
               "    static int i__, j;"
               "    static double c1, c2, s1, s2;"
               "    static int nb, mn, nb1, nb2, nb3, nb4;"
               "    static double anrm, bnrm, smin, smax;"
               "    static int iascl, ibscl;"
               "    extern /* Subroutine */ int dcopy_(int *, double *, int *, "
               "            double *, int *);"
               "    static int ismin, ismax;"
               "    extern /* Subroutine */ int dtrsm_(char *, char *, char *, char *, "
               "            int *, int *, double *, double *, int *, "
               "            double *, int *, int, int, int, int), dlaic1_("
               "            int *, int *, double *, double *, double *, "
               "            double *, double *, double *, double *);"
               "    static double wsize;"
               "    extern /* Subroutine */ int dgeqp3_(int *, int *, double *, "
               "            int *, int *, double *, double *, int *, "
               "            int *), dlabad_(double *, double *);"
               "    extern double dlamch_(char *, int), dlange_(char *, int *, "
               "            int *, double *, int *, double *, int);"
               "    extern /* Subroutine */ int dlascl_(char *, int *, int *, "
               "            double *, double *, int *, int *, double *, "
               "            int *, int *, int), dlaset_(char *, int *, int "
               "            *, double *, double *, double *, int *, int), "
               "            xerbla_(char *, int *, int);"
               "    extern int ilaenv_(int *, char *, char *, int *, int *, "
               "            int *, int *, int, int);"
               "    static double bignum;"
               "    extern /* Subroutine */ int dormqr_(char *, char *, int *, int *, "
               "            int *, double *, int *, double *, double *, "
               "            int *, double *, int *, int *, int, int);"
               "    static double sminpr, smaxpr, smlnum;"
               "    static int lwkopt;"
               "    static int lquery;"
               ""
               ""
               "/*     -- LAPACK driver routine (version 3.0) -- */"
               "/*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd., */"
               "/*     Courant Institute, Argonne National Lab, and Rice University */"
               "/*     June 30, 1999 */"
               ""
               "/*     .. Scalar Arguments .. */"
               "/*     .. */"
               "/*     .. Array Arguments .. */"
               "/*     .. */"
               ""
               "/*     Purpose */"
               "/*     ======= */"
               ""
               "/*     DGELSY1 computes a solution, with at least N-RANK zeros to a real */"
               "/*     linear least squares problem: */"
               "/*     minimize || A * X - B || */"
               "/*     using a complete orthogonal factorization of A.  A is an M-by-N */"
               "/*     matrix which may be rank-deficient. */"
               ""
               "/*     Several right hand side vectors b and solution vectors x can be */"
               "/*     handled in a single call; they are stored as the columns of the */"
               "/*     M-by-NRHS right hand side matrix B and the N-by-NRHS solution */"
               "/*     matrix X. */"
               ""
               "/*     The routine first computes a QR factorization with column */"
               "/*     pivoting: */"
               "/*     A * P = Q * [ R11 R12 ] */"
               "/*                 [  0  R22 ] */"
               "/*     with R11 defined as the largest leading submatrix whose estimated */"
               "/*     condition number is less than 1/RCOND.  The order of R11, RANK, */"
               "/*     is the effective rank of A. */"
               ""
               "/*     Then, R22 is considered to be negligible, */"
               "/*     The  solution return is then */"
               "/*     X = P * [ inv(R11)*Q1''*B ] */"
               "/*             [        0       ] */"
               "/*     where Q1 consists of the first RANK columns of Q. */"
               ""
               "/*     This routine is basically identical to the original xGELSX except */"
               "/*     three differences: */"
               "/*     o The call to the subroutine xGEQPF has been substituted by the */"
               "/*     the call to the subroutine xGEQP3. This subroutine is a Blas-3 */"
               "/*     version of the QR factorization with column pivoting. */"
               "/*     o Matrix B (the right hand side) is updated with Blas-3. */"
               "/*     o The permutation of matrix B (the right hand side) is faster and */"
               "/*     more simple. */"
               ""
               "/*     Arguments */"
               "/*     ========= */"
               ""
               "/*     M       (input) int */"
               "/*     The number of rows of the matrix A.  M >= 0. */"
               ""
               "/*     N       (input) int */"
               "/*     The number of columns of the matrix A.  N >= 0. */"
               ""
               "/*     NRHS    (input) int */"
               "/*     The number of right hand sides, i.e., the number of */"
               "/*     columns of matrices B and X. NRHS >= 0. */"
               ""
               "/*     A       (input/output) DOUBLE PRECISION array, dimension (LDA,N) */"
               "/*     On entry, the M-by-N matrix A. */"
               "/*     On exit, A has been overwritten by details of its */"
               "/*     complete orthogonal factorization. */"
               ""
               "/*     LDA     (input) int */"
               "/*     The leading dimension of the array A.  LDA >= max(1,M). */"
               ""
               "/*     B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS */"
               "/*     ) */"
               "/*     On entry, the M-by-NRHS right hand side matrix B. */"
               "/*     On exit, the N-by-NRHS solution matrix X. */"
               ""
               "/*     LDB     (input) int */"
               "/*     The leading dimension of the array B. LDB >= max(1,M,N). */"
               ""
               "/*     JPVT    (input/output) int array, dimension (N) */"
               "/*     On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted */"
               "/*     to the front of AP, otherwise column i is a free column. */"
               "/*     On exit, if JPVT(i) = k, then the i-th column of AP */"
               "/*     was the k-th column of A. */"
               ""
               "/*     RCOND   (input) DOUBLE PRECISION */"
               "/*     RCOND is used to determine the effective rank of A, which */"
               "/*     is defined as the order of the largest leading triangular */"
               "/*     submatrix R11 in the QR factorization with pivoting of A, */"
               "/*     whose estimated condition number < 1/RCOND. */"
               ""
               "/*     RANK    (output) int */"
               "/*     The effective rank of A, i.e., the order of the submatrix */"
               "/*     R11.  This is the same as the order of the submatrix T11 */"
               "/*     in the complete orthogonal factorization of A. */"
               ""
               "/*     WORK    (workspace/output) DOUBLE PRECISION array, dimension */"
               "/*     (LWORK) */"
               "/*     On exit, if INFO = 0, WORK(1) returns the optimal LWORK. */"
               ""
               "/*     LWORK   (input) int */"
               "/*     The dimension of the array WORK. */"
               "/*     The unblocked strategy requires that: */"
               "/*     LWORK >= MAX( MN+3*N+1, 2*MN+NRHS ), */"
               "/*     where MN = min( M, N ). */"
               "/*     The block algorithm requires that: */"
               "/*     LWORK >= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ), */"
               "/*     where NB is an upper bound on the blocksize returned */"
               "/*     by ILAENV for the routines DGEQP3, DTZRZF, STZRQF, DORMQR, */"
               "/*     and DORMRZ. */"
               ""
               "/*     If LWORK = -1, then a workspace query is assumed; the routine */"
               "/*     only calculates the optimal size of the WORK array, returns */"
               "/*     this value as the first entry of the WORK array, and no error */"
               "/*     message related to LWORK is issued by XERBLA. */"
               ""
               "/*     INFO    (output) int */"
               "/*     = 0: successful exit */"
               "/*     < 0: If INFO = -i, the i-th argument had an illegal value. */"
               ""
               "/*     Further Details */"
               "/*     =============== */"
               ""
               "/*     Based on contributions by */"
               "/*     A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA */"
               "/*     E. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, */"
               "/*     Spain */"
               "/*     G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, */"
               "/*     Spain */"
               ""
               "/*     ================================================================== */"
               "/*     === */"
               ""
               "/*     .. Parameters .. */"
               "/*     .. */"
               "/*     .. Local Scalars .. */"
               "/*     .. */"
               "/*     .. External Functions .. */"
               "/*     .. */"
               "/*     .. External Subroutines .. */"
               "/*     .. */"
               "/*     .. Intrinsic Functions .. */"
               "/*     .. */"
               "/*     .. Executable Statements .. */"
               ""
               "    /* Parameter adjustments */"
               "    a_dim1 = *lda;"
               "    a_offset = 1 + a_dim1;"
               "    a -= a_offset;"
               "    b_dim1 = *ldb;"
               "    b_offset = 1 + b_dim1;"
               "    b -= b_offset;"
               "    --jpvt;"
               "    --work;"
               ""
               "    /* Function Body */"
               "    mn = min(*m,*n);"
               "    ismin = mn + 1;"
               "    ismax = (mn << 1) + 1;"
               ""
               "/*     Test the input arguments. */"
               ""
               "    *info = 0;"
               "    nb1 = ilaenv_(&c__1, ""DGEQRF"", "" "", m, n, &c_n1, &c_n1, (int)6, ("
               "            int)1);"
               "    nb2 = ilaenv_(&c__1, ""DGERQF"", "" "", m, n, &c_n1, &c_n1, (int)6, ("
               "            int)1);"
               "    nb3 = ilaenv_(&c__1, ""DORMQR"", "" "", m, n, nrhs, &c_n1, (int)6, (int)"
               "            1);"
               "    nb4 = ilaenv_(&c__1, ""DORMRQ"", "" "", m, n, nrhs, &c_n1, (int)6, (int)"
               "            1);"
               "/* Computing MAX */"
               "    i__1 = max(nb1,nb2), i__1 = max(i__1,nb3);"
               "    nb = max(i__1,nb4);"
               "/* Computing MAX */"
               "    i__1 = 1, i__2 = mn + (*n << 1) + nb * (*n + 1), i__1 = max(i__1,i__2), "
               "            i__2 = (mn << 1) + nb * *nrhs;"
               "    lwkopt = max(i__1,i__2);"
               "    work[1] = (double) lwkopt;"
               "    lquery = *lwork == -1;"
               "    if (*m < 0) {"
               "        *info = -1;"
               "    } else if (*n < 0) {"
               "        *info = -2;"
               "    } else if (*nrhs < 0) {"
               "        *info = -3;"
               "    } else if (*lda < max(1,*m)) {"
               "        *info = -5;"
               "    } else /* if(complicated condition) */ {"
               "/* Computing MAX */"
               "        i__1 = max(1,*m);"
               "        if (*ldb < max(i__1,*n)) {"
               "            *info = -7;"
               "        } else /* if(complicated condition) */ {"
               "/* Computing MAX */"
               "            i__1 = 1, i__2 = mn + *n * 3 + 1, i__1 = max(i__1,i__2), i__2 = ("
               "                    mn << 1) + *nrhs;"
               "            if (*lwork < max(i__1,i__2) && ! lquery) {"
               "                *info = -12;"
               "            }"
               "        }"
               "    }"
               ""
               "    if (*info != 0) {"
               "        i__1 = -(*info);"
               "        xerbla_(""DGELSY"", &i__1, (int)6);"
               "        return 0;"
               "    } else if (lquery) {"
               "        return 0;"
               "    }"
               ""
               "/*     Quick return if possible */"
               ""
               "/* Computing MIN */"
               "    i__1 = min(*m,*n);"
               "    if (min(i__1,*nrhs) == 0) {"
               "        *rank = 0;"
               "        return 0;"
               "    }"
               ""
               "/*     Get machine parameters */"
               ""
               "    smlnum = dlamch_(""S"", (int)1) / dlamch_(""P"", (int)1);"
               "    bignum = 1. / smlnum;"
               "    dlabad_(&smlnum, &bignum);"
               ""
               "/*     Scale A, B if max entries outside range [SMLNUM,BIGNUM] */"
               ""
               "    anrm = dlange_(""M"", m, n, &a[a_offset], lda, &work[1], (int)1);"
               "    iascl = 0;"
               "    if (anrm > 0. && anrm < smlnum) {"
               ""
               "/*     Scale matrix norm up to SMLNUM */"
               ""
               "        dlascl_(""G"", &c__0, &c__0, &anrm, &smlnum, m, n, &a[a_offset], lda, "
               "                info, (int)1);"
               "        iascl = 1;"
               "    } else if (anrm > bignum) {"
               ""
               "/*     Scale matrix norm down to BIGNUM */"
               ""
               "        dlascl_(""G"", &c__0, &c__0, &anrm, &bignum, m, n, &a[a_offset], lda, "
               "                info, (int)1);"
               "        iascl = 2;"
               "    } else if (anrm == 0.) {"
               ""
               "/*     Matrix all zero. Return zero solution. */"
               ""
               "        i__1 = max(*m,*n);"
               "        dlaset_(""F"", &i__1, nrhs, &c_b31, &c_b31, &b[b_offset], ldb, (int)"
               "                1);"
               "        *rank = 0;"
               "        goto L70;"
               "    }"
               ""
               "    bnrm = dlange_(""M"", m, nrhs, &b[b_offset], ldb, &work[1], (int)1);"
               "    ibscl = 0;"
               "    if (bnrm > 0. && bnrm < smlnum) {"
               ""
               "/*     Scale matrix norm up to SMLNUM */"
               ""
               "        dlascl_(""G"", &c__0, &c__0, &bnrm, &smlnum, m, nrhs, &b[b_offset], ldb,"
               "                 info, (int)1);"
               "        ibscl = 1;"
               "    } else if (bnrm > bignum) {"
               ""
               "/*     Scale matrix norm down to BIGNUM */"
               ""
               "        dlascl_(""G"", &c__0, &c__0, &bnrm, &bignum, m, nrhs, &b[b_offset], ldb,"
               "                 info, (int)1);"
               "        ibscl = 2;"
               "    }"
               ""
               "/*     Compute QR factorization with column pivoting of A: */"
               "/*     A * P = Q * R */"
               ""
               "    i__1 = *lwork - mn;"
               "    dgeqp3_(m, n, &a[a_offset], lda, &jpvt[1], &work[1], &work[mn + 1], &i__1,"
               "             info);"
               "    wsize = mn + work[mn + 1];"
               ""
               "/*     workspace: MN+2*N+NB*(N+1). */"
               "/*     Details of Householder rotations stored in WORK(1:MN). */"
               ""
               "/*     Determine RANK using incremental condition estimation */"
               ""
               "    work[ismin] = 1.;"
               "    work[ismax] = 1.;"
               "    smax = (d__1 = a[a_dim1 + 1], abs(d__1));"
               "    smin = smax;"
               "    if ((d__1 = a[a_dim1 + 1], abs(d__1)) == 0.) {"
               "        *rank = 0;"
               "        i__1 = max(*m,*n);"
               "        dlaset_(""F"", &i__1, nrhs, &c_b31, &c_b31, &b[b_offset], ldb, (int)"
               "                1);"
               "        goto L70;"
               "    } else {"
               "        *rank = 1;"
               "    }"
               ""
               "L10:"
               "    if (*rank < mn) {"
               "        i__ = *rank + 1;"
               "        dlaic1_(&c__2, rank, &work[ismin], &smin, &a[i__ * a_dim1 + 1], &a["
               "                i__ + i__ * a_dim1], &sminpr, &s1, &c1);"
               "        dlaic1_(&c__1, rank, &work[ismax], &smax, &a[i__ * a_dim1 + 1], &a["
               "                i__ + i__ * a_dim1], &smaxpr, &s2, &c2);"
               ""
               "        if (smaxpr * *rcond <= sminpr) {"
               "            i__1 = *rank;"
               "            for (i__ = 1; i__ <= i__1; ++i__) {"
               "                work[ismin + i__ - 1] = s1 * work[ismin + i__ - 1];"
               "                work[ismax + i__ - 1] = s2 * work[ismax + i__ - 1];"
               "/* L20: */"
               "            }"
               "            work[ismin + *rank] = c1;"
               "            work[ismax + *rank] = c2;"
               "            smin = sminpr;"
               "            smax = smaxpr;"
               "            ++(*rank);"
               "            goto L10;"
               "        }"
               "    }"
               ""
               "/*     workspace: 3*MN. */"
               ""
               "/*     intly partition R = [ R11 R12 ] */"
               "/*     [  0  R22 ] */"
               "/*     where R11 = R(1:RANK,1:RANK) */"
               ""
               "/*     *     [R11,R12] = [ T11, 0 ] * Y */"
               "/*     * */"
               "/*     IF( RANK.LT.N ) */"
               "/*     $   CALL DTZRZF( RANK, N, A, LDA, WORK( MN+1 ), WORK( 2*MN+1 ), */"
               "/*     $                LWORK-2*MN, INFO ) */"
               "/*     * */"
               "/*     *     workspace: 2*MN. */"
               "/*     Details of Householder rotations stored in WORK(MN+1:2*MN) */"
               ""
               "/*     B(1:M,1:NRHS) := Q'' * B(1:M,1:NRHS) */"
               ""
               "    i__1 = *lwork - (mn << 1);"
               "    dormqr_(""Left"", ""Transpose"", m, nrhs, &mn, &a[a_offset], lda, &work[1], &"
               "            b[b_offset], ldb, &work[(mn << 1) + 1], &i__1, info, (int)4, ("
               "            int)9);"
               "/* Computing MAX */"
               "    d__1 = wsize, d__2 = (mn << 1) + work[(mn << 1) + 1];"
               "    wsize = max(d__1,d__2);"
               ""
               "/*     workspace: 2*MN+NB*NRHS. */"
               ""
               "/*     B(1:RANK,1:NRHS) := inv(T11) * B(1:RANK,1:NRHS) */"
               ""
               "    dtrsm_(""Left"", ""Upper"", ""No transpose"", ""Non-unit"", rank, nrhs, &c_b54, &"
               "            a[a_offset], lda, &b[b_offset], ldb, (int)4, (int)5, ("
               "            int)12, (int)8);"
               ""
               "    i__1 = *nrhs;"
               "    for (j = 1; j <= i__1; ++j) {"
               "        i__2 = *n;"
               "        for (i__ = *rank + 1; i__ <= i__2; ++i__) {"
               "            b[i__ + j * b_dim1] = 0.;"
               "/* L30: */"
               "        }"
               "/* L40: */"
               "    }"
               "/*     * */"
               "/*     *     B(1:N,1:NRHS) := Y'' * B(1:N,1:NRHS) */"
               "/*     * */"
               "/*     IF( RANK.LT.N ) THEN */"
               "/*     CALL DORMRZ( ''Left'', ''Transpose'', N, NRHS, RANK, N-RANK, A, */"
               "/*     $                LDA, WORK( MN+1 ), B, LDB, WORK( 2*MN+1 ), */"
               "/*     $                LWORK-2*MN, INFO ) */"
               "/*     END IF */"
               "/*     * */"
               "/*     *     workspace: 2*MN+NRHS. */"
               ""
               "/*     B(1:N,1:NRHS) := P * B(1:N,1:NRHS) */"
               ""
               "    i__1 = *nrhs;"
               "    for (j = 1; j <= i__1; ++j) {"
               "        i__2 = *n;"
               "        for (i__ = 1; i__ <= i__2; ++i__) {"
               "            work[jpvt[i__]] = b[i__ + j * b_dim1];"
               "/* L50: */"
               "        }"
               "        dcopy_(n, &work[1], &c__1, &b[j * b_dim1 + 1], &c__1);"
               "/* L60: */"
               "    }"
               ""
               "/*     workspace: N. */"
               ""
               "/*     Undo scaling */"
               ""
               "    if (iascl == 1) {"
               "        dlascl_(""G"", &c__0, &c__0, &anrm, &smlnum, n, nrhs, &b[b_offset], ldb,"
               "                 info, (int)1);"
               "        dlascl_(""U"", &c__0, &c__0, &smlnum, &anrm, rank, rank, &a[a_offset], "
               "                lda, info, (int)1);"
               "    } else if (iascl == 2) {"
               "        dlascl_(""G"", &c__0, &c__0, &anrm, &bignum, n, nrhs, &b[b_offset], ldb,"
               "                 info, (int)1);"
               "        dlascl_(""U"", &c__0, &c__0, &bignum, &anrm, rank, rank, &a[a_offset], "
               "                lda, info, (int)1);"
               "    }"
               "    if (ibscl == 1) {"
               "        dlascl_(""G"", &c__0, &c__0, &smlnum, &bnrm, n, nrhs, &b[b_offset], ldb,"
               "                 info, (int)1);"
               "    } else if (ibscl == 2) {"
               "        dlascl_(""G"", &c__0, &c__0, &bignum, &bnrm, n, nrhs, &b[b_offset], ldb,"
               "                 info, (int)1);"
               "    }"
               ""
               "L70:"
               "    work[1] = (double) lwkopt;"
               ""
               "    return 0;"
               ""
               "/*     End of DGELSY */"
               ""
               "} /* dgelsy1_ */"
               ""]

      case 'diffblk_c' then
        txt = ["#include ""scicos_block4.h"""
               ""
               "/*     February 2008 */"
               "/*    Copyright INRIA"
               " *    Scicos block simulator"
               " */"
               ""
               "void diffblk_c(scicos_block *block,int flag)"
               "{"
               "  double *_xd=GetDerState(block);"
               "  double *_x=GetState(block);"
               "  double *_res=GetResState(block);"
               "  double *y,*u;"
               "  int i;"
               "  int* property=GetXpropPtrs(block);"
               "  int nx=GetNstate(block);"
               "    switch(flag)"
               "      {"
               "      case 4  : {"
               "        for (i=0;i<nx;i++) property[i]=-1; /* xproperties*/"
               "        break;"
               "      }"
               ""
               "      case 6  : { "
               "        u=GetRealInPortPtrs(block,1);"
               "        //      for (i=0;i<nx;i++)  _x[i]=u[i];"
               "        break;  "
               "      }"
               ""
               "      case 7  : {"
               "        for (i=0;i<nx;i++) property[i]=-1; /* xproperties*/"
               "        break;"
               "      }"
               ""
               "      case 0  : {"
               "        u=GetRealInPortPtrs(block,1);"
               "        for (i=0;i<nx;i++) _res[i]=u[i]-_x[i];"
               "        break;"
               "      }"
               ""
               "      case 1  : {"
               "        y=GetRealOutPortPtrs(block,1);"
               "        for (i=0;i<nx;i++)  y[i]=_xd[i];"
               "        break;  "
               "      }"
               ""
               "      default : break;"
               "      }"
               "}"]

      case 'dollar4' then
        txt = ["#include ""scicos_block4.h"""
               ""
               "void dollar4(scicos_block *block,int flag)"
               "{"
               "  double *_z=GetDstate(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  /* c     Copyright INRIA"
               "     "
               "  Scicos block simulator"
               "  Ouputs delayed input */"
               "  "
               "  int i;"
               "  for(i=0;i< GetInPortRows(block,1);i++){"
               "    if (flag ==1 || flag ==6 || flag ==4)"
               "      _y1[i]=_z[i];"
               "    else if (flag == 2)"
               "      _z[i]=_u1[i];"
               "  }"
               "}"]

      case 'dsslti4' then
        txt = ["#include <memory.h>"
               "#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "extern int C2F(dmmul)();"
               "extern int C2F(dmmul1)();"
               ""
               ""
               "void dsslti4(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  /* Copyright INRIA"
               "     "
               "  Scicos block simulator"
               "  discrete state space linear system simulator"
               "  rpar(1:nx*nx)=A"
               "  rpar(nx*nx+1:nx*nx+nx*nu)=B"
               "  rpar(nx*nx+nx*nu+1:nx*nx+nx*nu+nx*ny)=C */"
               "  "
               "  int un=1,lb,lc,ld;"
               "  int nz=GetNdstate(block);"
               "  double* z=GetDstate(block);"
               "  double* rpar=GetRparPtrs(block);"
               "  double* y=GetRealOutPortPtrs(block,1);"
               "  double* u=GetRealInPortPtrs(block,1);"
               "  int noutsz=GetOutPortRows(block,1);"
               "  int ninsz=GetInPortRows(block,1);"
               "  double *w;"
               "  "
               "  lb=nz*nz;"
               "  "
               "  if (flag ==1 || flag ==6){"
               "    /* y=c*x+d*u */"
               "    lc=lb+nz*ninsz;"
               "    ld=lc+nz*noutsz;"
               "    if (nz==0) {"
               "      C2F(dmmul)(&rpar[ld],&noutsz,u,&ninsz,y,&noutsz,&noutsz,&ninsz,&un);"
               "    }else{"
               "      C2F(dmmul)(&rpar[lc],&noutsz,z,&nz,y,&noutsz,&noutsz,&nz,&un);"
               "      C2F(dmmul1)(&rpar[ld],&noutsz,u,&ninsz,y,&noutsz,&noutsz,&ninsz,&un);"
               "    }"
               "  }"
               "  else if (flag ==2){"
               "    /* x+=a*x+b*u */"
               "    if (nz!=0){"
               "      w =*_work;"
               "      memcpy(w,z,nz*sizeof(double));"
               "      C2F(dmmul)(&rpar[0],&nz,w,&nz,z,&nz,&nz,&nz,&un);"
               "      C2F(dmmul1)(&rpar[lb],&nz,u,&ninsz,z,&nz,&nz,&ninsz,&un);"
               "    }"
               "  }"
               "  else if (flag ==4&&nz!=0){/* the workspace for temp storage"
               "                      */"
               "    if ((*_work="
               "         scicos_malloc(sizeof(double)*nz))== NULL ) {"
               "      set_block_error(-16);"
               "      return;"
               "    }"
               "  }"
               "  else if (flag ==5&&nz!=0){"
               "    scicos_free(*_work);"
               "  }"
               "}"
               ""
               ""]

      case 'edgetrig' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "extern void sciprint();"
               ""
               "void edgetrig(scicos_block *block,int flag)"
               "{"
               "  int *_ipar=GetIparPtrs(block);"
               "  double *_z=GetDstate(block);"
               "  int _ng=GetNg(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double z= _z[0],u=_u1[0];"
               "  if(flag==2||flag==6){"
               "    _z[0]=u;"
               "  }else if(flag==1){"
               "    if(_ipar[0]!=0){"
               "      z=z*_ipar[0];"
               "      u=u*_ipar[0];"
               "      if(((z<=0)&(u>0))||((z<0)&(u>=0))) {"
               "        _y1[0]=1.;"
               "      }else{"
               "        _y1[0]=0.;"
               "      }"
               "    } else{ /* rising and falling edge */"
               "      if(((z<=0)&(u>0))||((z<0)&(u>=0))||((z>0)&(u<=0))||((z>=0)&(u<0))){"
               "        _y1[0]=1.;"
               "      }else{"
               "        _y1[0]=0.;"
               "      }"
               "    }"
               "  }else if (flag==4) {"
               "    if (_ng>0){"
               "      set_block_error(-1);"
               "      sciprint(""Trigger block must have discrete time input."");"
               "      return;"
               "    }"
               "  }"
               "}"]

      case 'evaluate_expr' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               "#if WIN32"
               "#include <float.h>"
               "#endif"
               ""
               "#if defined(solaris)"
               "#include <ieeefp.h>"
               "int isinf(double x) { return !finite(x) && x==x; }"
               "#endif"
               "#if defined(__alpha)"
               "int isinf(double x) { return !finite(x) && x==x; }"
               "#endif"
               ""
               "#ifndef min"
               "#define min(a,b) ((a) <= (b) ? (a) : (b))"
               "#endif"
               ""
               "#ifndef max"
               "#define max(a,b) ((a) >= (b) ? (a) : (b))"
               "#endif"
               ""
               "#if WIN32"
               "/*"
               "arcsinh z = log (z+sqrt(1+z2))"
               "*/"
               "double asinh(double x)"
               "{"
               "  return log(x+sqrt(x*x+1));"
               "}"
               ""
               "double acosh(double x)"
               "{"
               "  return log(x+sqrt(x*x-1));"
               "}"
               ""
               "/*"
               "Inverse hyperbolic tangent (Atanh(x)) Log((1 + x) / (1  x)) / 2 "
               "*/"
               "double atanh(double x)"
               "{"
               "        return (double)(log ((1.+x)/(1.-x))/2);"
               "}"
               "#endif"
               ""
               "void evaluate_expr(scicos_block *block,int flag)"
               "{"
               "  double *_rpar=GetRparPtrs(block);"
               "  int *_ipar=GetIparPtrs(block);"
               "  int _nin=GetNin(block);"
               "  int _ng=GetNg(block);"
               "  double *_g=GetGPtrs(block);"
               "  int *_mode=GetModePtrs(block);"
               "  int _nipar=GetNipar(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double *uytmp;"
               "  static double stack [1000];"
               "  static int count,bottom,nzcr,i,phase; "
               "  int j;  "
               "  if (flag==1||flag==6||flag==9){"
               "    phase=get_phase_simulation();"
               "    bottom=-1;"
               "    count=-1;"
               "    nzcr=-1;"
               "    while (count<_nipar-1){"
               "      count=count+1;"
               "      switch (_ipar[count]) {"
               "      case 2:"
               "        count=count+1;"
               "        bottom=bottom+1;"
               "        if(bottom>999){"
               "          set_block_error(-16);"
               "          return;"
               "        }"
               "        if (_nin>1){"
               "          uytmp=GetRealInPortPtrs(block,_ipar[count]-1+1);"
               "          stack[bottom]=uytmp[0];"
               "        }else{"
               "          j=_ipar[count]-1;"
               "          if (j<GetInPortRows(block,1)){"
               "            stack[bottom]=_u1[_ipar[count]-1];"
               "          }else{"
               "            stack[bottom]=0.;"
               "          }"
               "        }"
               "        break;"
               "      case 6:"
               "        count=count+1;"
               "        bottom=bottom+1;"
               "        if(bottom>999){"
               "          set_block_error(-16);"
               "          return;"
               "        }"
               "        stack[bottom]=_rpar[_ipar[count]-1];"
               "        break;"
               "      case 5:"
               "        count=count+1;"
               "        switch (_ipar[count]) {"
               "        case 1:"
               "          stack[bottom-1]=stack[bottom-1]+stack[bottom];"
               "          bottom=bottom-1;"
               "          break;"
               "        case 2:"
               "          stack[bottom-1]=stack[bottom-1]-stack[bottom];"
               "          bottom=bottom-1;"
               "          break;"
               "        case 3:"
               "          stack[bottom-1]=stack[bottom-1]*stack[bottom];"
               "          bottom=bottom-1;"
               "          break;"
               "        case 7:"
               "          stack[bottom-1]=stack[bottom-1]/stack[bottom];"
               "          bottom=bottom-1;"
               "          break;"
               "        case 15:"
               "          stack[bottom-1]=pow(stack[bottom-1],stack[bottom]);"
               "          bottom=bottom-1;"
               "          break;"
               "        case 16: /* case == */"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            _g[nzcr]=stack[bottom-1]-stack[bottom];"
               "            if(phase==1) {"
               "              _mode[nzcr]=(stack[bottom-1]==stack[bottom]);"
               "            }"
               "          }"
               "          if(phase==1||_ng==0){"
               "            i=(stack[bottom-1]==stack[bottom]);"
               "          } else{"
               "            i=_mode[nzcr];"
               "          }"
               "          stack[bottom-1]=(double)i;"
               "          bottom=bottom-1;"
               "          break;"
               ""
               "        case 17:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            _g[nzcr]=stack[bottom-1]-stack[bottom];"
               "            if(phase==1) {"
               "              _mode[nzcr]=(stack[bottom-1]<stack[bottom]);"
               "            }"
               "          }"
               "          if(phase==1||_ng==0){"
               "            i=(stack[bottom-1]<stack[bottom]);"
               "          } else{"
               "            i=_mode[nzcr];"
               "          }"
               "          stack[bottom-1]=(double)i;"
               "          bottom=bottom-1;"
               "          break;"
               "        case 18:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            _g[nzcr]=stack[bottom-1]-stack[bottom];"
               "            if(phase==1) {"
               "              _mode[nzcr]=(stack[bottom-1]>stack[bottom]);"
               "            }"
               "          }"
               "          if(phase==1||_ng==0){"
               "            i=(stack[bottom-1]>stack[bottom]);"
               "          } else{"
               "            i=_mode[nzcr];"
               "          }"
               "          stack[bottom-1]=(double)i;"
               "          bottom=bottom-1;"
               "          break;"
               "        case 19:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            _g[nzcr]=stack[bottom-1]-stack[bottom];"
               "            if(phase==1) {"
               "              _mode[nzcr]=(stack[bottom-1]<=stack[bottom]);"
               "            }"
               "          }"
               "          if(phase==1||_ng==0){"
               "            i=(stack[bottom-1]<=stack[bottom]);"
               "          } else{"
               "            i=_mode[nzcr];"
               "          }"
               "          stack[bottom-1]=(double)i;"
               "          bottom=bottom-1;"
               "          break;"
               "        case 20:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            _g[nzcr]=stack[bottom-1]-stack[bottom];"
               "            if(phase==1) {"
               "              _mode[nzcr]=(stack[bottom-1]>=stack[bottom]);"
               "            }"
               "          }"
               "          if(phase==1||_ng==0){"
               "            i=(stack[bottom-1]>=stack[bottom]);"
               "          } else{"
               "            i=_mode[nzcr];"
               "          }"
               "          stack[bottom-1]=(double)i;"
               "          bottom=bottom-1;"
               "          break;"
               "        case 21:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            _g[nzcr]=stack[bottom-1]-stack[bottom];"
               "            if(phase==1) {"
               "              _mode[nzcr]=(stack[bottom-1]!=stack[bottom]);"
               "            }"
               "          }"
               "          if(phase==1||_ng==0){"
               "            i=(stack[bottom-1]!=stack[bottom]);"
               "          } else{"
               "            i=_mode[nzcr];"
               "          }"
               "          stack[bottom-1]=(double)i;"
               "          bottom=bottom-1;"
               "          break;"
               "        case 28:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            _g[nzcr]=stack[bottom-1]-stack[bottom];"
               "            if(phase==1) {"
               "              _mode[nzcr]=((int)stack[bottom-1]||(int)stack[bottom]);"
               "            }"
               "          }"
               "          if(phase==1||_ng==0){"
               "            i=((int)stack[bottom-1]||(int)stack[bottom]);"
               "          } else{"
               "            i=_mode[nzcr];"
               "          }"
               "          stack[bottom-1]=(double)i;"
               "          bottom=bottom-1;"
               "          break;"
               "        case 29:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            _g[nzcr]=stack[bottom-1]-stack[bottom];"
               "            if(phase==1) {"
               "              _mode[nzcr]=((int)stack[bottom-1]&&(int)stack[bottom]);"
               "            }"
               "          }"
               "          if(phase==1||_ng==0){"
               "            i=((int)stack[bottom-1]&&(int)stack[bottom]);"
               "          } else{"
               "            i=_mode[nzcr];"
               "          }"
               "          stack[bottom-1]=(double)i;"
               "          bottom=bottom-1;"
               "          break;"
               ""
               "        case 30:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            _g[nzcr]=stack[bottom];"
               "            if(phase==1) {"
               "              _mode[nzcr]=(0.0==stack[bottom]);"
               "            }"
               "          }"
               "          if(phase==1||_ng==0){"
               "            i=(stack[bottom]==0.0);"
               "          }else{"
               "            i=_mode[nzcr];"
               "          }"
               "          if (i){"
               "            stack[bottom]=1.0;"
               "          }else{"
               "            stack[bottom]=0.0;   "
               "          }"
               "          break;"
               "        case 99:"
               "          stack[bottom]=-stack[bottom];"
               "          break;"
               "        case 101:"
               "          stack[bottom]=sin(stack[bottom]);"
               "          break;"
               "        case 102:"
               "          stack[bottom]=cos(stack[bottom]);"
               "          break;"
               "        case 103:"
               "          stack[bottom]=tan(stack[bottom]);"
               "          break;"
               "        case 104:"
               "          stack[bottom]=exp(stack[bottom]);"
               "          break;"
               "        case 105:"
               "          stack[bottom]=log(stack[bottom]);"
               "          break;"
               "        case 106:"
               "          stack[bottom]=sinh(stack[bottom]);"
               "          break;"
               "        case 107:"
               "          stack[bottom]=cosh(stack[bottom]);"
               "          break;"
               "        case 108:"
               "          stack[bottom]=tanh(stack[bottom]);"
               "          break;"
               ""
               "        case 109:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            if (stack[bottom]>0) {"
               "              i=(int)floor(stack[bottom]);"
               "            }else{"
               "              i=(int)ceil(stack[bottom]);"
               "            }"
               "            if(i==0)  {"
               "              _g[nzcr]=(stack[bottom]-1)*(stack[bottom]+1);"
               "            }else if(i>0){"
               "              _g[nzcr]=(stack[bottom]-i-1.)*(stack[bottom]-i);"
               "            }else{"
               "              _g[nzcr]=(stack[bottom]-i)*(stack[bottom]-i+1);"
               "            }"
               "            if(i%2)  _g[nzcr]=-_g[nzcr];"
               "            if(phase==1) _mode[nzcr]=i;"
               "          }"
               "          if(phase==1||_ng==0){"
               "            if (stack[bottom]>0) {"
               "              stack[bottom]=floor(stack[bottom]);"
               "            }else{"
               "              stack[bottom]=ceil(stack[bottom]);"
               "            }"
               "          }else{"
               "            stack[bottom]=(double) _mode[nzcr];"
               "          }"
               "          break;"
               "          /*"
               "          if (stack[bottom]>0) {"
               "            stack[bottom]=floor(stack[bottom]);"
               "          }else{"
               "            stack[bottom]=ceil(stack[bottom]);"
               "            }*/"
               "          break;"
               "        case 110:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            if (stack[bottom]>0) {"
               "              i=(int)floor(stack[bottom]+.5);"
               "            }else{"
               "              i=(int)ceil(stack[bottom]-.5);"
               "            }"
               "            _g[nzcr]=(stack[bottom]-i-.5)*(stack[bottom]-i+.5);"
               "            if(i%2)  _g[nzcr]=-_g[nzcr];"
               "            if(phase==1) _mode[nzcr]=i;"
               "          }"
               "          if(phase==1||_ng==0){"
               "            if (stack[bottom]>0) {"
               "              stack[bottom]=floor(stack[bottom]+.5);"
               "            }else{"
               "              stack[bottom]=ceil(stack[bottom]-.5);"
               "            }"
               "          }else{"
               "            stack[bottom]=(double) _mode[nzcr];"
               "          }"
               "          break;"
               "          /*  if (stack[bottom]>0) {"
               "            stack[bottom]=floor(stack[bottom]+.5);"
               "          }else{"
               "            stack[bottom]=ceil(stack[bottom]-.5);"
               "          }*/"
               "        case 111:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            i=(int)ceil(stack[bottom]);"
               "            _g[nzcr]=(stack[bottom]-i)*(stack[bottom]-i+1);"
               "            if(i%2)  _g[nzcr]=-_g[nzcr];"
               "            if(phase==1) _mode[nzcr]=i;"
               "          }"
               "          if(phase==1||_ng==0){"
               "            stack[bottom]=ceil(stack[bottom]);"
               "          }else{"
               "            stack[bottom]=(double) _mode[nzcr];"
               "          }"
               "          break;"
               "        case 112:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            i=(int)floor(stack[bottom]);"
               "            _g[nzcr]=(stack[bottom]-i-1)*(stack[bottom]-i);"
               "            if(i%2)  _g[nzcr]=-_g[nzcr];"
               "            if(phase==1) _mode[nzcr]=i;"
               "          }"
               "          if(phase==1||_ng==0){"
               "            stack[bottom]=floor(stack[bottom]);"
               "          }else{"
               "            stack[bottom]=(double) _mode[nzcr];"
               "          }"
               "          break;"
               "        case 113:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            if (stack[bottom]>0) {"
               "              i=1;"
               "            }else if (stack[bottom]<0){"
               "              i=-1;"
               "            }else{"
               "              i=0;"
               "            }"
               "            _g[nzcr]=stack[bottom];"
               "            if(phase==1) _mode[nzcr]=i;"
               "          }"
               "          if(phase==1||_ng==0){"
               "            if (stack[bottom]>0) {"
               "              stack[bottom]=1.0;"
               "            }else if(stack[bottom]<0){"
               "              stack[bottom]=-1.0;"
               "            }else{"
               "              stack[bottom]=0.0;"
               "            }"
               "          }else{"
               "            stack[bottom]=(double) _mode[nzcr];"
               "          }"
               "          break;"
               "          /* if (stack[bottom]>0) {"
               "            stack[bottom]=1.0;"
               "          }else if(stack[bottom]<0){"
               "            stack[bottom]=-1.0;"
               "          }else{"
               "            stack[bottom]=0.0;"
               "            }*/"
               "        case 114:  /* abs */"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            if (stack[bottom]>0) {"
               "              i=1;"
               "            }else if (stack[bottom]<0){"
               "              i=-1;"
               "            }else{"
               "              i=0;"
               "            }"
               "            _g[nzcr]=stack[bottom];"
               "            if(phase==1) _mode[nzcr]=i;"
               "          }"
               "          if(phase==1||_ng==0){"
               "            if (stack[bottom]>0) {"
               "              stack[bottom]=stack[bottom];"
               "            }else {"
               "              stack[bottom]=-stack[bottom];"
               "            }"
               "          }else{"
               "            stack[bottom]=stack[bottom]*(_mode[nzcr]);"
               "          }"
               "          break;"
               "          /* if (stack[bottom]>0) {"
               "            stack[bottom]=stack[bottom];"
               "          }else {"
               "            stack[bottom]=-stack[bottom];"
               "            }*/"
               "        case 115:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            if (stack[bottom]>stack[bottom-1]) {"
               "              i=0;"
               "            }else {"
               "              i=1;"
               "            }"
               "            _g[nzcr]=stack[bottom]-stack[bottom-1];"
               "            if(phase==1) _mode[nzcr]=i;"
               "          }"
               "          if(phase==1||_ng==0){"
               "            stack[bottom-1]=max(stack[bottom-1],stack[bottom]);"
               "          }else{"
               "            stack[bottom-1]=stack[bottom-_mode[nzcr]];"
               "          }"
               "          bottom=bottom-1;"
               "          break;"
               "        case 116:"
               "          if(_ng>0) nzcr=nzcr+1;"
               "          if (flag==9) {"
               "            if (stack[bottom]<stack[bottom-1]) {"
               "              i=0;"
               "            }else {"
               "              i=1;"
               "            }"
               "            _g[nzcr]=stack[bottom]-stack[bottom-1];"
               "            if(phase==1) _mode[nzcr]=i;"
               "          }"
               "          if(phase==1||_ng==0){"
               "            stack[bottom-1]=min(stack[bottom-1],stack[bottom]);"
               "          }else{"
               "            stack[bottom-1]=stack[bottom-_mode[nzcr]];"
               "          }"
               "          bottom=bottom-1;"
               "          break;"
               "        case 117:"
               "          stack[bottom]=asin(stack[bottom]);"
               "          break;"
               "        case 118:"
               "          stack[bottom]=acos(stack[bottom]);"
               "          break;"
               "        case 119:"
               "          stack[bottom]=atan(stack[bottom]);"
               "          break;"
               "        case 120:"
               "          stack[bottom]=asinh(stack[bottom]);"
               "          break;"
               "        case 121:"
               "          stack[bottom]=acosh(stack[bottom]);"
               "          break;"
               "        case 122:"
               "          stack[bottom]=atanh(stack[bottom]);"
               "          break;"
               "        case 123:"
               "          stack[bottom-1]=atan2(stack[bottom-1],stack[bottom]);"
               "          bottom=bottom-1;"
               "          break;"
               ""
               "        case 124:"
               "          stack[bottom]=log10(stack[bottom]);"
               "          break;"
               "        }"
               "      }"
               "    }"
               "    #if __MSC__"
               "    if(!_finite(stack[bottom])||_isnan(stack[bottom])){"
               "    #else"
               "     if(isinf(stack[bottom])||isnan(stack[bottom])){"
               "    #endif"
               "      if (flag==6) return;"
               "      set_block_error(-2);"
               "      return;"
               "    }else{"
               "      _y1[0]=stack[bottom];"
               "    }"
               "  }"
               "}"]

      case 'evtdly4' then
        txt = ["#include ""scicos_block4.h"""
               "/*    Copyright INRIA"
               " *    Scicos block simulator"
               " *    event delay with discrete counter"
               " */"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "void evtdly4(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  double *_rpar=GetRparPtrs(block);"
               "  double *_evout= GetNevOutPtrs(block);"
               "  double t;"
               "  long long int *i;"
               ""
               "  switch(flag)"
               "  {"
               "   /* init */"
               "   case 4  : {/* the workspace is used to store discrete counter value */"
               "              if ((*_work=scicos_malloc(sizeof(long long int)))==NULL) {"
               "                set_block_error(-16);"
               "                return;"
               "              }"
               "              i=*_work;"
               "              (*i)=0;"
               "              break;"
               "             }"
               ""
               "   /* event date computation */"
               "   case 3  : {"
               "              i=*_work;"
               "              t=get_scicos_time();"
               "              (*i)++; /*increase counter*/"
               "              _evout[0]=_rpar[1]+ \"
               "                              (*i)*_rpar[0]-t;"
               "              break;"
               "             }"
               ""
               "   /* finish */"
               "   case 5  : {"
               "              scicos_free(*_work); /*free the workspace*/"
               "              break;"
               "             }"
               ""
               "   default : break;"
               "  }"
               "}"]

      case 'evtvardly' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void evtvardly(scicos_block *block,int flag)"
               "{ "
               "  double *_evout= GetNevOutPtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  if (flag==3){"
               "    _evout[0]=_u1[0];"
               "  }"
               "}"
               ""]

      case 'expblk_m' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               "#include <math.h>"
               ""
               "void expblk_m(scicos_block *block,int flag)"
               "{"
               "  double *u;"
               "  double *y;"
               "  double *rpar;"
               "  int nu,mu,i;"
               ""
               "  mu=GetInPortRows(block,1);"
               "  nu=GetInPortCols(block,1);"
               "  u=GetRealInPortPtrs(block,1);"
               "  y=GetRealOutPortPtrs(block,1);"
               "  rpar=GetRparPtrs(block);"
               "  if ((flag==1)|(flag>=4)) {"
               "  for(i=0;i<mu*nu;i++) y[i]=exp(log(*rpar)*u[i]);"
               "  }"
               "}"]

      case 'extract' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "void extract(scicos_block *block,int flag)"
               "{"
               "  double *u;"
               "  double *y;"
               "  int *r;"
               "  int nu,mu,nr,i,j,ij,k,nc,nl;"
               ""
               "  mu=GetInPortRows(block,1);"
               "  nu=GetInPortCols(block,1);"
               "  nr=GetNipar(block);"
               "  r=GetIparPtrs(block);"
               "  u=GetRealInPortPtrs(block,1);"
               "  y=GetRealOutPortPtrs(block,1);"
               "  nc=r[nr-1];"
               "  nl=r[nr-2];"
               "  k=0;"
               "  for (j=0;j<nc;j++)"
               "        {for (i=0;i<nl;i++)"
               "                {ij=r[i]-1+(r[nl+j]-1)*mu;"
               "                 *(y+k)=*(u+ij);"
               "                 k++;}}"
               "}"]

      case 'extract_bit_32_UH0' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void extract_bit_32_UH0(scicos_block *block,int flag)"
               "{"
               "   int i,maxim;"
               "   long *y,*u,ref,n;"
               "   y=Getint32OutPortPtrs(block,1);"
               "   u=Getint32InPortPtrs(block,1);"
               "   maxim=32;"
               "   ref=0;"
               "   for(i=0;i<maxim/2;i++)"
               "       {n=(long)pow(2,maxim/2+i);"
               "        ref=ref+n;}"
               "   *y=(*u)&(ref);"
               "}"]

      case 'extractor' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void extractor(scicos_block *block,int flag)"
               "{"
               "  int *_ipar=GetIparPtrs(block);"
               "  int _nipar=GetNipar(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  int i,j;"
               "  if(flag==1){"
               "    for(i=0;i<_nipar;++i){"
               "      j=_ipar[i]-1;"
               "      if(j<0) j=0;"
               "      if(j>=GetInPortRows(block,1)) j=GetInPortRows(block,1)-1;"
               "      _y1[i]=_u1[j];"
               "    }"
               "  }"
               "}"]

      case 'foriterator' then
        txt = ["#include ""scicos_block4.h"""
               "#include <memory.h>"
               "/*typedef struct{"
               "  int so;"
               "  void **mem;"
               "  }foriter;*/"
               ""
               "void foriterator(scicos_block *block,int flag)"
               "{ "
               "  void *y,*u,*z;"
               "  int *ipar;"
               "  int so;"
               "  int nin;"
               "  z=GetOzPtrs(block,1);"
               "  so=GetSizeOfOut(block,1);"
               "  if (flag==1) {"
               "    y=GetOutPortPtrs(block,1);"
               "    memcpy(y,z,so);"
               "  }else if (flag==2){"
               "    ipar=GetIparPtrs(block);"
               "    if (*ipar==0){"
               "      if (so==1){"
               "        char *inp;"
               "        inp=(char *)z;"
               "        *inp=*inp+1;"
               "      }else if (so==2){"
               "        short *inp;"
               "        inp=(short *)z;"
               "        *inp=*inp+1;"
               "      }else if (so==4){"
               "        long *inp;"
               "        inp=(long *)z;"
               "        *inp=*inp+1;"
               "      }else if (so==8){"
               "        double *inp;"
               "        inp=(double *)z;"
               "        *inp=*inp+1;"
               "      }"
               "    }else {"
               "      nin=GetNin(block);"
               "      u=GetInPortPtrs(block,nin);"
               "      memcpy(z,u,so);"
               "    }"
               "  }"
               "}"
               ""
               ""
               "  "]

      case 'fromws_c' then
        txt = ["#include ""scicos_block4.h"""
               "/*    Masoud Najafi, Alan Layec September 2007 */"
               "/*    Copyright INRIA"
               " *    Scicos block simulator"
               " *    From workspace block"
               " */"
               "#include ""../stack-c.h"""
               "#include <stdio.h>"
               "#include <string.h>"
               "#include ""machine.h"""
               "#include <math.h>"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "#define T0        ptr->workt[0]"
               "#define TNm1      ptr->workt[nPoints-1]"
               "#define TP        (TNm1-0)"
               ""
               ""
               "extern int C2F(cvstr) __PARAMS((integer *,integer *,char *,integer *,unsigned long int));"
               "extern int C2F(mgetnc)();"
               "extern void C2F(mopen)();"
               "extern int C2F(cluni0) __PARAMS((char *name, char *nams, integer *ln, long int name_len,"
               "                                long int nams_len));"
               "extern void C2F(mclose) __PARAMS((integer *fd, double *res));"
               "extern void sciprint __PARAMS((char *fmt,...));"
               "int Mytridiagldltsolve(double *d, double * l, double * b, int n);"
               "int Myevalhermite2(double *t, double *xa, double *xb, double *ya, double *yb, double *da, double *db, double *h, double *dh, double *ddh, double *dddh, int *i);"
               "/*int Myevalhermite(double *t, double *xa, double *xb, double *ya, double *yb, double *da, double *db, double *h, double *dh, double *ddh, double *dddh, int *i);*/"
               ""
               "/* function to check and extract data coming from an hypermat */"
               "int Ishm(int *fd,int *Ytype,int *nPoints,int *my,int *ny,int *YsubType);"
               ""
               "static char fmtd[3]={''d'',''l'',''\000''};"
               "static char fmti[3]={''i'',''l'',''\000''};"
               "static char fmtl[3]={''l'',''l'',''\000''};"
               "static char fmts[3]={''s'',''l'',''\000''}; "
               "static char fmtc[3]={''c'',''l'',''\000''};"
               "static char fmtul[3]={''u'',''l'',''\000''};"
               "static char fmtus[3]={''u'',''s'',''\000''};"
               "static char fmtuc[3]={''u'',''c'',''\000''};"
               ""
               "#ifdef hppa"
               "#undef FILENAME_MAX"
               "#define FILENAME_MAX 4096"
               "#endif"
               "/* work struct for that block */"
               "typedef struct {"
               "  int nPoints;"
               "  int Hmat;"
               "  int Yt;"
               "  int Yst;"
               "  int cnt1;"
               "  int cnt2;"
               "  int EVindex;"
               "  int PerEVcnt;"
               "  int firstevent;"
               "  double *D;"
               "  void *work;"
               "  double *workt;"
               "} fromwork_struct ;"
               ""
               ""
               "void fromws_c(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  int *_ipar=GetIparPtrs(block);"
               "  double *_evout= GetNevOutPtrs(block);"
               "  double t,y1,y2,t1,t2,r;"
               "  double *spline, *A_d, *A_sd, *qdy;"
               "  /* double  a,b,c,*y;*/"
               "  double d1,d2,h, dh, ddh, dddh;"
               "  /* counter and indexes variables */"
               "  int i,inow;"
               "  int j,jfirst;"
               "  int cnt1, cnt2, EVindex, PerEVcnt;"
               ""
               "  int Fnlength,*FName,Method,ZC,OutEnd;"
               ""
               "  Fnlength=  _ipar[0];"
               "  FName=     _ipar+1;"
               "  Method=    _ipar[1+Fnlength];"
               "  ZC=        _ipar[2+Fnlength];"
               "  OutEnd=    _ipar[3+Fnlength];"
               ""
               ""
               "  /* variables to handle files of TMPDIR/Workspace */"
               "  int fd;"
               "  char *status;"
               "  int swap = 1;"
               "  double res;"
               "  int out_n;"
               "  long int lout;"
               "  char filename[FILENAME_MAX];"
               "  char str[100];"
               "  int ierr;"
               ""
               "  /* variables for type and dims of data coming from scilab */"
               "  int Ytype, YsubType, mY, nY;"
               "  int nPoints;"
               "  int Ydim[10];"
               ""
               "  /* variables for type and dims of data of the output port block */"
               "  int ytype, my, ny;"
               ""
               "  /* generic pointer */"
               "  SCSREAL_COP *y_d,*y_cd,*ptr_d, *ptr_T, *ptr_D;"
               "  SCSINT8_COP *y_c,*ptr_c;"
               "  SCSUINT8_COP *y_uc, *ptr_uc;"
               "  SCSINT16_COP *y_s,*ptr_s;"
               "  SCSUINT16_COP *y_us,*ptr_us;"
               "  SCSINT32_COP *y_l,*ptr_l;"
               "  SCSUINT32_COP *y_ul,*ptr_ul;"
               ""
               "  /* the struct ptr of that block */"
               "  fromwork_struct *ptr;"
               ""
               "  /* for path of TMPDIR/workspace */"
               "  char env[256];"
               "  char sep[2];"
               "#ifdef _MSC_VER"
               "  sep[0]=''\\'';"
               "#else"
               "  sep[0]=''/'';"
               "#endif"
               "  sep[1]=''\0'';"
               ""
               " /*retrieve dimensions of output port*/"
               " my       = GetOutPortRows(block,1); /* number of rows of Outputs*/"
               " ny       = GetOutPortCols(block,1); /* number of cols of Outputs*/"
               " ytype    = GetOutType(block,1);     /* output type */"
               ""
               " ptr_d=NULL;"
               " ptr_D=NULL;"
               ""
               " /* init */"
               " if (flag==4) {"
               "   /* convert scilab code of the variable name to C string */"
               "   C2F(cvstr)(&(Fnlength),FName,str,(j=1,&j),(unsigned long)strlen(str));"
               "   str[Fnlength] = ''\0'';"
               ""
               "   /* retrieve path of TMPDIR/workspace */"
               "   strcpy(env,getenv(""TMPDIR""));"
               "   strcat(env,sep);"
               "   strcat(env,""Workspace"");"
               "   strcat(env,sep);"
               "   strcat(env,str);"
               ""
               "   /* open tmp file */"
               "   status = ""rb""; /* ""r"" : read */"
               "                  /* ""b"" : binary format (required for Windows) */"
               ""
               "   lout=FILENAME_MAX;"
               "   C2F(cluni0)(env, filename, &out_n,1,lout);"
               "   C2F(mopen)(&fd,env,status,&swap,&res,&ierr);"
               ""
               "   if (ierr!=0) {"
               "     /*sciprint(""The ''%s'' variable does not exist.\n"",str);"
               "     *set_block_error(-3);"
               "     */"
               "     Coserror(""The ''%s'' variable does not exist.\n"",str);"
               "     return;"
               "   }"
               ""
               "   /* read x */"
               "   C2F(mgetnc) (&fd, &Ydim[0], (j=nsiz,&j), fmti, &ierr);  /* read sci id */"
               "   C2F(mgetnc) (&fd, &Ydim[6], (j=1,&j), fmti, &ierr);     /* read sci type */"
               "   if (Ydim[6]==17) {"
               "     if (!Ishm(&fd,&Ytype,&nPoints,&mY,&nY,&YsubType)) {"
               "       /*Coserror(""Invalid variable type.\n"");*/"
               "       /*sciprint(""Invalid variable type.\n"");"
               "       set_block_error(-3); */"
               "       C2F(mclose)(&fd,&res);"
               "       return;"
               "     }"
               "     if (!((Ytype==1) || (Ytype==8))) {"
               "       Coserror(""Invalid variable type.\n"");"
               "       /*sciprint(""Invalid variable type.\n"");"
               "       set_block_error(-3);*/"
               "       C2F(mclose)(&fd,&res);"
               "       return;"
               "     }"
               "   }"
               "   else if ((Ydim[6]==1)||(Ydim[6]==8)) {"
               "     C2F(mgetnc) (&fd, &Ydim[7], (j=3,&j), fmti, &ierr); /* read sci header */"
               "     Ytype    = Ydim[6]; /* data type        */"
               "     nPoints  = Ydim[7]; /* number of data   */"
               "     mY       = Ydim[8]; /* first dimension  */"
               "     nY       = 1;       /* second dimension */"
               "     YsubType = Ydim[9]; /* subtype          */"
               "   }"
               "   else {"
               "    Coserror(""Invalid variable type.\n"");"
               "    /*sciprint(""Invalid variable type.\n"");"
               "    set_block_error(-3);*/"
               "    C2F(mclose)(&fd,&res);"
               "    return;"
               "   }"
               ""
               "   /* check dimension for output port and variable */"
               "   if ((mY!=my)||(nY!=ny)) {"
               "     Coserror(""Data dimensions are inconsistent:\n\r Variable size=[%d,%d] \n\r"""
               "              ""Block output size=[%d,%d].\n"",mY,nY,my,ny);"
               "     /*set_block_error(-3);*/"
               "     C2F(mclose)(&fd,&res);"
               "     return;"
               "   }"
               ""
               "   /* check variable data type and output block data type */"
               "   if (Ytype==1) { /*real/complex cases*/"
               "     switch (YsubType)"
               "     {"
               "     case 0: if (ytype!=10) {"
               "               Coserror(""Output should be of Real type.\n"");"
               "               /*set_block_error(-3);*/"
               "               C2F(mclose)(&fd,&res);"
               "               return;"
               "             }"
               "             break;"
               ""
               "     case 1: if (ytype!=11) {"
               "               Coserror(""Output should be of complex type.\n"");"
               "               /*set_block_error(-3);*/"
               "               C2F(mclose)(&fd,&res);"
               "               return;"
               "             }"
               "             break;"
               "     }"
               "   }"
               "   else if(Ytype==8) { /*integer cases*/"
               "     switch (YsubType)"
               "     {"
               "     case 1: if (ytype!=81) {"
               "               sciprint(""Output should be of int8 type.\n"");"
               "               set_block_error(-3);"
               "               C2F(mclose)(&fd,&res);"
               "               return;"
               "             }"
               "             break;"
               ""
               "     case 2: if (ytype!=82) {"
               "               Coserror(""Output should be of int16 type.\n"");"
               "               /*set_block_error(-3);*/"
               "               C2F(mclose)(&fd,&res);"
               "               return;"
               "             }"
               "             break;"
               ""
               "     case 4: if (ytype!=84) {"
               "               Coserror(""Output should be of int32 type.\n"");"
               "               /*set_block_error(-3);*/"
               "               C2F(mclose)(&fd,&res);"
               "               return;"
               "             }"
               "             break;"
               ""
               "     case 11:if (ytype!=811) {"
               "               Coserror(""Output should be of uint8 type.\n"");"
               "               /*set_block_error(-3);*/"
               "               C2F(mclose)(&fd,&res);"
               "               return;"
               "             }"
               "             break;"
               ""
               "     case 12:if (ytype!=812) {"
               "               Coserror(""Output should be of uint16 type.\n"");"
               "               /*set_block_error(-3);*/"
               "               C2F(mclose)(&fd,&res);"
               "               return;"
               "             }"
               "             break;"
               ""
               "     case 14:if (ytype!=814) {"
               "               Coserror(""Output should be of uint32 type.\n"");"
               "               /*set_block_error(-3);*/"
               "               C2F(mclose)(&fd,&res);"
               "               return;"
               "             }"
               "             break;"
               "     }"
               "   }"
               ""
               "   /* allocation of the work structure of that block */"
               "   if((*(_work)=(fromwork_struct*) scicos_malloc(sizeof(fromwork_struct)))==NULL) {"
               "     set_block_error(-16);"
               "     C2F(mclose)(&fd,&res);"
               "     return;"
               "   }"
               "   ptr = *(_work);"
               "   ptr->D=NULL;"
               "   ptr->workt=NULL;"
               "   ptr->work=NULL;"
               ""
               "   if (Ytype==1) { /*real/complex case*/"
               "     switch (YsubType) {"
               "     case 0 : /* Real */"
               "       if((ptr->work=(void *) scicos_malloc(nPoints*mY*nY*sizeof(double)))==NULL) {"
               "         set_block_error(-16);"
               "         scicos_free(ptr);"
               "         *(_work)=NULL;"
               "         C2F(mclose)(&fd,&res);"
               "         return;"
               "       }"
               "       ptr_d = (SCSREAL_COP *) ptr->work;"
               "       C2F(mgetnc) (&fd, ptr_d, (j=nPoints*mY*nY,&j), fmtd, &ierr);  /* read double data */"
               "       break;"
               "     case 1:  /* complex */"
               "       if((ptr->work=(void *) scicos_malloc(2*nPoints*mY*nY*sizeof(double)))==NULL) {"
               "         set_block_error(-16);"
               "         scicos_free(ptr);"
               "         *(_work)=NULL;"
               "         C2F(mclose)(&fd,&res);"
               "         return;"
               "       }"
               "       ptr_d = (SCSREAL_COP *) ptr->work;"
               "       C2F(mgetnc) (&fd, ptr_d, (j=2*nPoints*mY*nY,&j), fmtd, &ierr);  /* read double data */"
               "       break;"
               "     }"
               "   }"
               "   else if(Ytype==8) { /*integer case*/"
               "     switch (YsubType) {"
               "     case 1 :/* int8 */"
               "       if((ptr->work=(void *) scicos_malloc(nPoints*mY*nY*sizeof(char)))==NULL) {"
               "         set_block_error(-16);"
               "         scicos_free(ptr);"
               "         *(_work)=NULL;"
               "         C2F(mclose)(&fd,&res);"
               "         return;"
               "       }"
               "       ptr_c = (SCSINT8_COP *) ptr->work;"
               "       C2F(mgetnc) (&fd, ptr_c, (j=nPoints*mY*nY,&j), fmtc, &ierr);  /* read char data */"
               "       break;"
               "     case 2 :  /* int16 */"
               "       if((ptr->work=(void *) scicos_malloc(nPoints*mY*nY*sizeof(short)))==NULL) {"
               "         set_block_error(-16);"
               "         scicos_free(ptr);"
               "         *(_work)=NULL;"
               "         C2F(mclose)(&fd,&res);"
               "         return;"
               "       }"
               "       ptr_s = (SCSINT16_COP *) ptr->work;"
               "       C2F(mgetnc) (&fd, ptr_s, (j=nPoints*mY*nY,&j), fmts, &ierr);  /* read short data */"
               "       break;"
               "     case 4 :   /* int32 */"
               "       if((ptr->work=(void *) scicos_malloc(nPoints*mY*nY*sizeof(long)))==NULL) {"
               "         set_block_error(-16);"
               "         scicos_free(ptr);"
               "         *(_work)=NULL;"
               "         C2F(mclose)(&fd,&res);"
               "         return;"
               "       }"
               "       ptr_l = (SCSINT32_COP *) ptr->work;"
               "       C2F(mgetnc) (&fd, ptr_l, (j=nPoints*mY*nY,&j), fmtl, &ierr);  /* read short data */"
               "       break;"
               "     case 11 :   /* uint8 */"
               "       if((ptr->work=(void *) scicos_malloc(nPoints*mY*nY*sizeof(unsigned char)))==NULL) {"
               "         set_block_error(-16);"
               "         scicos_free(ptr);"
               "         *(_work)=NULL;"
               "         C2F(mclose)(&fd,&res);"
               "         return;"
               "       }"
               "       ptr_uc = (SCSUINT8_COP *) ptr->work;"
               "       C2F(mgetnc) (&fd, ptr_uc, (j=nPoints*mY*nY,&j), fmtuc, &ierr);  /* read short data */"
               "       break;"
               "     case 12 : /* uint16 */"
               "       if((ptr->work=(void *) scicos_malloc(nPoints*mY*nY*sizeof(unsigned short)))==NULL) {"
               "         set_block_error(-16);"
               "         scicos_free(ptr);"
               "         *(_work)=NULL;"
               "         C2F(mclose)(&fd,&res);"
               "         return;"
               "       }"
               "       ptr_us = (SCSUINT16_COP *) ptr->work;"
               "       C2F(mgetnc) (&fd, ptr_us, (j=nPoints*mY*nY,&j), fmtus, &ierr);  /* read short data */"
               "       break;"
               "     case 14 :  /* uint32 */"
               "       if((ptr->work=(void *) scicos_malloc(nPoints*mY*nY*sizeof(unsigned long)))==NULL) {"
               "         set_block_error(-16);"
               "         scicos_free(ptr);"
               "         *(_work)=NULL;"
               "         C2F(mclose)(&fd,&res);"
               "         return;"
               "       }"
               "       ptr_ul = (SCSUINT32_COP *) ptr->work;"
               "       C2F(mgetnc) (&fd, ptr_ul, (j=nPoints*mY*nY,&j), fmtul, &ierr);  /* read short data */"
               "       break;"
               "     }"
               "   }"
               ""
               "   /* check Hmat */"
               "   if (Ydim[6]==17) {"
               "     ptr->Hmat=1;"
               "   }"
               "   else {"
               "     ptr->Hmat=0;"
               "   }"
               ""
               "   /* read t */"
               "   C2F(mgetnc) (&fd, &Ydim[0], (j=nsiz,&j), fmti, &ierr);  /* read sci id */"
               "   C2F(mgetnc) (&fd, &Ydim[6], (j=1,&j), fmti, &ierr);  /* read sci type */"
               "   C2F(mgetnc) (&fd, &Ydim[7], (j=3,&j), fmti, &ierr);  /* read sci header */"
               ""
               "   if (nPoints!=Ydim[7]) {"
               "     Coserror(""The size of the Time(%d) and Data(%d) vectors are inconsistent.\n"",Ydim[7],nPoints);"
               "     /*set_block_error(-3);*/"
               "     *(_work)=NULL;"
               "     scicos_free(ptr->work);"
               "     scicos_free(ptr);"
               "     C2F(mclose)(&fd,&res);"
               "     return;"
               "   }"
               ""
               "   if ((Ydim[6]!=1) | (Ydim[9]!=0)) {"
               "     Coserror(""The Time vector type is not """"double"""".\n""); "
               "     /*set_block_error(-3);*/"
               "     *(_work)=NULL;"
               "     scicos_free(ptr->work);"
               "     scicos_free(ptr);"
               "     C2F(mclose)(&fd,&res);"
               "     return;"
               "   }"
               ""
               "   if((ptr->workt=(double *) scicos_malloc(nPoints*sizeof(double)))==NULL) {"
               "     set_block_error(-16);"
               "     *(_work)=NULL;"
               "     scicos_free(ptr->work);"
               "     scicos_free(ptr);"
               "     C2F(mclose)(&fd,&res);"
               "     return;"
               "   }"
               "   ptr_T = (SCSREAL_COP *) ptr->workt;"
               "   C2F(mgetnc) (&fd, ptr_T, (j=nPoints,&j), fmtd, &ierr);  /* read data of t */"
               ""
               "   /* close the file*/"
               "   C2F(mclose)(&fd,&res);"
               ""
               "   /*================================*/"
               "   /* check for an increasing time data */"
               "   for(j = 0; j < nPoints-1; j++) {"
               "     if(ptr_T[j] > ptr_T[j+1]) {"
               "       Coserror(""The time vector should be an increasing vector.\n"");"
               "       /*set_block_error(-3);*/"
               "       *(_work)=NULL;"
               "       scicos_free(ptr->workt);"
               "       scicos_free(ptr->work);"
               "       scicos_free(ptr);"
               "       return;"
               "     }"
               "   }"
               "   /*=================================*/"
               "   if ((Method>1)&&(Ytype==1)&&(!ptr->Hmat)) { /* double or complex */"
               ""
               "     if (YsubType==0) { /*real*/"
               "       if((ptr->D=(double *) scicos_malloc(nPoints*mY*sizeof(double)))==NULL) {"
               "         set_block_error(-16);"
               "         *(_work)=NULL;"
               "         scicos_free(ptr->workt);"
               "         scicos_free(ptr->work);"
               "         scicos_free(ptr);"
               "         return;"
               "       }"
               "     }"
               "     else { /*complex*/"
               "       if((ptr->D=(double *) scicos_malloc(2*nPoints*mY*sizeof(double)))==NULL) {"
               "         set_block_error(-16);"
               "         *(_work)=NULL;"
               "         scicos_free(ptr->workt);"
               "         scicos_free(ptr->work);"
               "         scicos_free(ptr);"
               "         return;"
               "       }"
               "     }"
               ""
               "     if((spline=(double *) scicos_malloc((3*nPoints-2)*sizeof(double)))==NULL) {"
               "       Coserror(""Allocation problem in spline.\n"");"
               "       /*set_block_error(-16);*/"
               "       *(_work)=NULL;"
               "       scicos_free(ptr->D);"
               "       scicos_free(ptr->workt);"
               "       scicos_free(ptr->work);"
               "       scicos_free(ptr);"
               "       return;"
               "     }"
               ""
               "     A_d  = spline;"
               "     A_sd = A_d  + nPoints;"
               "     qdy  = A_sd + nPoints-1;"
               ""
               "     for (j=0;j<mY;j++) { /* real part */"
               "       for (i=0;i<=nPoints-2;i++) {"
               "         A_sd[i] = 1.0 / (ptr_T[i+1] - ptr_T[i]);"
               "         qdy[i]  = (ptr_d[i+1+j*nPoints] - ptr_d[i+j*nPoints]) * A_sd[i]*A_sd[i];"
               "       }"
               ""
               "       for (i=1;i<=nPoints-2;i++) {"
               "         A_d[i] = 2.0*(A_sd[i-1] +A_sd[i]);"
               "         ptr->D[i+j*nPoints] = 3.0*(qdy[i-1]+qdy[i]);"
               "       }"
               ""
               "       if (Method==2) {"
               "         A_d[0] =  2.0*A_sd[0];"
               "         ptr->D[0+j*nPoints] = 3.0 * qdy[0];"
               "         A_d[nPoints-1] =  2.0*A_sd[nPoints-2];"
               "         ptr->D[nPoints-1+j*nPoints] =  3.0 * qdy[nPoints-2];"
               "         Mytridiagldltsolve(A_d, A_sd, &ptr->D[j*nPoints], nPoints);"
               "       }"
               ""
               "       if (Method==3) {"
               "         /*  s''''''(x(2)-) = s''''''(x(2)+) */"
               "         r = A_sd[1]/A_sd[0];"
               "         A_d[0]= A_sd[0]/(1.0 + r);"
               "         ptr->D[j*nPoints]=((3.0*r+2.0)*qdy[0]+r*qdy[1])/((1.0+r)*(1.0+r));"
               "         /*  s''''''(x(n-1)-) = s''''''(x(n-1)+) */"
               "         r = A_sd[nPoints-3]/A_sd[nPoints-2];"
               "         A_d[nPoints-1] = A_sd[nPoints-2]/(1.0 + r);"
               "         ptr->D[nPoints-1+j*nPoints] = \"
               "                  ((3.0*r+2.0)*qdy[nPoints-2]+r*qdy[nPoints-3])/((1.0+r)*(1.0+r));"
               "         Mytridiagldltsolve(A_d, A_sd, &ptr->D[j*nPoints], nPoints);"
               "       }"
               "     }"
               ""
               "     if (YsubType==1) { /* imag part */"
               "       for (j=0;j<mY;j++) {"
               "         for (i=0;i<=nPoints-2;i++) {"
               "           A_sd[i] = 1.0 / (ptr_T[i+1] - ptr_T[i]);"
               "           qdy[i]  = (ptr_d[nPoints+i+1+j*nPoints] - ptr_d[nPoints+i+j*nPoints]) * A_sd[i]*A_sd[i];"
               "         }"
               ""
               "         for (i=1;i<=nPoints-2;i++) {"
               "           A_d[i] = 2.0*(A_sd[i-1] +A_sd[i]);"
               "           ptr->D[i+j*nPoints+nPoints] = 3.0*(qdy[i-1]+qdy[i]);"
               "         }"
               ""
               "         if (Method==2) {"
               "           A_d[0] =  2.0*A_sd[0];"
               "           ptr->D[nPoints+0+j*nPoints] = 3.0 * qdy[0];"
               "           A_d[nPoints-1] =  2.0*A_sd[nPoints-2];"
               "           ptr->D[nPoints+nPoints-1+j*nPoints] =  3.0 * qdy[nPoints-2];"
               "           Mytridiagldltsolve(A_d, A_sd, &ptr->D[nPoints+j*nPoints], nPoints);"
               "         }"
               ""
               "         if (Method==3) {"
               "           /*  s''''''(x(2)-) = s''''''(x(2)+) */"
               "           r = A_sd[1]/A_sd[0];"
               "           A_d[0]= A_sd[0]/(1.0 + r);"
               "           ptr->D[nPoints+j*nPoints]=((3.0*r+2.0)*qdy[0]+r*qdy[1])/((1.0+r)*(1.0+r));"
               "           /*  s''''''(x(n-1)-) = s''''''(x(n-1)+) */"
               "           r = A_sd[nPoints-3]/A_sd[nPoints-2];"
               "           A_d[nPoints-1] = A_sd[nPoints-2]/(1.0 + r);"
               "           ptr->D[nPoints+nPoints-1+j*nPoints] = \"
               "                    ((3.0*r+2.0)*qdy[nPoints-2]+r*qdy[nPoints-3])/((1.0+r)*(1.0+r));"
               "           Mytridiagldltsolve(A_d, A_sd, &ptr->D[nPoints+j*nPoints], nPoints);"
               "         }"
               "       }"
               "     }"
               ""
               "     scicos_free(spline);"
               "   }"
               "   /*===================================*/"
               "   cnt1=nPoints-1;"
               "   cnt2=nPoints;"
               "   for (i=0;i<nPoints;i++) { /* finding the first positive time instant */"
               "     if (ptr->workt[i]>=0 ) {"
               "       cnt1=i-1;"
               "       cnt2=i;"
               "       break;"
               "     }"
               "   }"
               "   ptr->nPoints=nPoints;"
               "   ptr->Yt=Ytype;"
               "   ptr->Yst=YsubType;"
               "   ptr->cnt1=cnt1;"
               "   ptr->cnt2=cnt2;"
               "   ptr->EVindex=0;"
               "   ptr->PerEVcnt=0;"
               "   ptr->firstevent=1;"
               "   return;"
               "   /*******************************************************/"
               "   /*******************************************************/"
               " }"
               " else if (flag==1){   /* output computation */"
               ""
               "   /* retrieve ptr of the structure of that block */"
               "   ptr = *(_work);"
               "   nPoints=ptr->nPoints;"
               "   cnt1=ptr->cnt1;"
               "   cnt2=ptr->cnt2;"
               "   EVindex= ptr->EVindex;"
               "   PerEVcnt=ptr->PerEVcnt;"
               ""
               "   /* get current simulation time */"
               "   t=get_scicos_time();"
               "   t1=t;"
               ""
               "   if (ZC==1){ /*zero crossing enable*/"
               "     if (OutEnd==2) {"
               "       t-=(PerEVcnt)*TP;"
               "     }"
               "     inow=nPoints-1;"
               "     for (i=cnt1;i<nPoints;i++) {"
               "       if (i==-1) {"
               "         continue;"
               "       }"
               "       if (t<ptr->workt[i]) {"
               "         inow=i-1;"
               "         if (inow<cnt2) {"
               "           cnt2=inow;"
               "         }"
               "         else {"
               "          cnt1=cnt2;"
               "          cnt2=inow;"
               "         }"
               "         break;"
               "       }"
               "     }"
               "   }"
               "   else { /*zero crossing disable*/"
               "     if (OutEnd==2) {"
               "       if (TP!=0) {"
               "         r=floor((t/TP));"
               "       }"
               "       else {"
               "         r=0;"
               "       }"
               "       t-=((int)r)*TP;"
               "     }"
               "     inow=nPoints-1;"
               "     for (i=0;i<nPoints;i++) {"
               "       if (t<ptr->workt[i]) {"
               "         inow=i-1;"
               "         break;"
               "       }"
               "     }"
               "   }"
               ""
               "   ptr->cnt1=cnt1;"
               "   ptr->cnt2=cnt2;"
               "   ptr->EVindex=EVindex;"
               "   ptr->PerEVcnt=PerEVcnt;"
               ""
               "   /***************************/"
               "   /* hypermatrix case */"
               "   if (ptr->Hmat) {"
               ""
               "     for (j=0;j<my*ny;j++) {"
               "       if (ptr->Yt==1) {"
               "         if (ptr->Yst==0) { /* real case */"
               "           y_d = GetRealOutPortPtrs(block,1);"
               "           ptr_d=(double*) ptr->work;"
               ""
               "           if (inow>=nPoints-1) {"
               "             if (OutEnd==0){"
               "               y_d[j]=0.0; /* outputs set to zero */"
               "             }"
               "             else if (OutEnd==1) {"
               "               y_d[j]=ptr_d[(nPoints-1)*ny*my+j]; /* hold outputs at the end */"
               "             }"
               "           }"
               "           else {"
               "             if (inow<0) {"
               "               y_d[j]=0.0;"
               "             }"
               "             else {"
               "               y_d[j]=ptr_d[inow*ny*my+j];"
               "             }"
               "           }"
               "         }"
               "         else { /* complexe case */"
               "           y_d = GetRealOutPortPtrs(block,1);"
               "           y_cd = GetImagOutPortPtrs(block,1);"
               "           ptr_d=(double*) ptr->work;"
               ""
               "           if (inow>=nPoints-1) {"
               "             if (OutEnd==0) {"
               "               y_d[j]=0.0;  /* outputs set to zero */"
               "               y_cd[j]=0.0; /* outputs set to zero */"
               "             }"
               "             else if (OutEnd==1) {"
               "               y_d[j]=ptr_d[(nPoints-1)*ny*my+j]; /* hold outputs at the end */"
               "               y_cd[j]=ptr_d[nPoints*my*ny+(nPoints-1)*ny*my+j];    /* hold outputs at the end */"
               "             }"
               "           }"
               "           else {"
               "             if (inow<0) {"
               "              y_d[j]=0.0;  /* outputs set to zero */"
               "              y_cd[j]=0.0; /* outputs set to zero */"
               "             }"
               "             else {"
               "               y_d[j]=ptr_d[inow*ny*my+j];"
               "               y_cd[j]=ptr_d[nPoints*my*ny+inow*ny*my+j];"
               "             }"
               "           }"
               "         }"
               "       }"
               "      else if (ptr->Yt==8) {"
               "        switch (ptr->Yst) {"
               "        case 1: /* ---------------------int8 char  ---------------------------- */"
               "          y_c = Getint8OutPortPtrs(block,1);"
               "          ptr_c=(char*) ptr->work;"
               "          if (inow>=nPoints-1) {"
               "            if (OutEnd==0) {"
               "              y_c[j]=0; /* outputs set to zero */"
               "            }"
               "            else if (OutEnd==1) {"
               "              y_c[j]=ptr_c[(nPoints-1)*ny*my+j]; /* hold outputs at the end */"
               "            }"
               "          }"
               "          else {"
               "            if (inow<0) {"
               "              y_c[j]=0;"
               "            }"
               "            else {"
               "              y_c[j]=ptr_c[inow*ny*my+j];"
               "            }"
               "          }"
               "          break;"
               ""
               "        case 2: /* ---------------------int16 short--------------------- */"
               "          y_s = Getint16OutPortPtrs(block,1);"
               "          ptr_s=(short*) ptr->work;"
               "          if (inow>=nPoints-1) {"
               "            if (OutEnd==0) {"
               "              y_s[j]=0; /* outputs set to zero */"
               "            }"
               "            else if (OutEnd==1) {"
               "              y_s[j]=ptr_s[(nPoints-1)*ny*my+j]; /* hold outputs at the end */"
               "            }"
               "          }"
               "          else {"
               "            if (inow<0) {"
               "              y_s[j]=0;"
               "            }"
               "            else {"
               "              y_s[j]=ptr_s[inow*ny*my+j];"
               "            }"
               "          }"
               "          break;"
               ""
               "        case 4: /* ---------------------int32 long--------------------- */"
               "          y_l = Getint32OutPortPtrs(block,1);"
               "          ptr_l=(long*) ptr->work;"
               "          if (inow>=nPoints-1) {"
               "            if (OutEnd==0) {"
               "              y_l[j]=0;/* outputs set to zero */"
               "            }"
               "            else if (OutEnd==1) {"
               "              y_l[j]=ptr_l[(nPoints-1)*ny*my+j]; /* hold outputs at the end */"
               "            }"
               "          }"
               "          else {"
               "            if (inow<0) {"
               "              y_l[j]=0;"
               "            }"
               "            else {"
               "              y_l[j]=ptr_l[inow*ny*my+j];"
               "            }"
               "          }"
               "          break;"
               ""
               "        case 11: /*--------------------- uint8 uchar---------------------*/"
               "          y_uc = Getuint8OutPortPtrs(block,1);"
               "          ptr_uc=(unsigned char*) ptr->work;"
               "          if (inow>=nPoints-1) {"
               "            if (OutEnd==0) {"
               "              y_uc[j]=0;/* outputs set to zero */"
               "            }"
               "            else if (OutEnd==1) {"
               "              y_uc[j]=ptr_uc[(nPoints-1)*ny*my+j]; /* hold outputs at the end */"
               "            }"
               "          }"
               "          else {"
               "            if (inow<0) {"
               "              y_uc[j]=0;"
               "            }"
               "            else {"
               "              y_uc[j]=ptr_uc[inow*ny*my+j];"
               "            }"
               "          }"
               "        break;"
               ""
               "        case 12: /* ---------------------uint16 ushort--------------------- */"
               "          y_us = Getuint16OutPortPtrs(block,1);"
               "          ptr_us=(unsigned short*) ptr->work;"
               "          if (inow>=nPoints-1) {"
               "            if (OutEnd==0) {"
               "              y_us[j]=0;/* outputs set to zero */"
               "            }"
               "            else if (OutEnd==1) {"
               "              y_us[j]=ptr_us[(nPoints-1)*ny*my+j]; /* hold outputs at the end */"
               "            }"
               "          }"
               "          else {"
               "            if (inow<0) {"
               "              y_us[j]=0;"
               "            }"
               "            else {"
               "              y_us[j]=ptr_us[inow*ny*my+j];"
               "            }"
               "          }"
               "          break;"
               ""
               "        case 14: /* ---------------------uint32 ulong--------------------- */"
               "          y_ul = Getuint32OutPortPtrs(block,1);"
               "          ptr_ul=(unsigned long*) ptr->work;"
               "          if (inow>=nPoints-1) {"
               "            if (OutEnd==0) {"
               "              y_ul[j]=0;/* outputs set to zero */"
               "            }"
               "            else if (OutEnd==1) {"
               "              y_ul[j]=ptr_ul[(nPoints-1)*ny*my+j]; /* hold outputs at the end */"
               "            }"
               "          }"
               "          else {"
               "            if (inow<0) {"
               "              y_ul[j]=0;"
               "            }"
               "            else {"
               "              y_ul[j]=ptr_ul[inow*ny*my+j];"
               "            }"
               "          }"
               "          break;"
               "        }"
               "      }"
               "     } /* for j loop */"
               "   }"
               "   /****************************/"
               "   /* scalar of vectorial case */"
               "   else {"
               "     for (j=0;j<my;j++) {"
               "       if (ptr->Yt==1) {"
               "         if ((ptr->Yst==0)||(ptr->Yst==1)) { /*  if Real or complex*/"
               "           y_d = GetRealOutPortPtrs(block,1);"
               "           ptr_d=(double*) ptr->work;"
               "           ptr_D=(double*) ptr->D;"
               ""
               "           if (inow>=nPoints-1) {"
               "             if (OutEnd==0){"
               "               y_d[j]=0.0; /* outputs set to zero */"
               "             }"
               "             else if (OutEnd==1) {"
               "               y_d[j]=ptr_d[nPoints-1+(j)*nPoints]; /* hold outputs at the end */"
               "             }"
               "           }"
               "           else if (Method==0) {"
               "             if (inow<0) {"
               "               y_d[j]=0.0;"
               "             }"
               "             else {"
               "               y_d[j]=ptr_d[inow+(j)*nPoints];"
               "             }"
               "           }"
               "           else if (Method==1) {"
               "             if (inow<0) {"
               "               inow=0;"
               "             }"
               "             t1=ptr->workt[inow];"
               "             t2=ptr->workt[inow+1];"
               "             y1=ptr_d[inow+j*nPoints];"
               "             y2=ptr_d[inow+1+j*nPoints];"
               "             y_d[j]=(y2-y1)*(t-t1)/(t2-t1)+y1;"
               "           }"
               "           else if (Method>=2) {"
               "             t1=ptr->workt[inow];"
               "             t2=ptr->workt[inow+1];"
               "             y1=ptr_d[inow+j*nPoints];"
               "             y2=ptr_d[inow+1+j*nPoints];"
               "             d1=ptr_D[inow+j*nPoints];"
               "             d2=ptr_D[inow+1+j*nPoints];"
               "             Myevalhermite2(&t, &t1,&t2, &y1,&y2, &d1,&d2, &h, &dh, &ddh, &dddh, &inow);"
               "             y_d[j]=h;"
               "           }"
               "         }"
               "         if (ptr->Yst==1) { /*  --------------complex----------------------*/"
               "           y_cd = GetImagOutPortPtrs(block,1);"
               "           if (inow>=nPoints-1) {"
               "             if (OutEnd==0) {"
               "               y_cd[j]=0.0;/* outputs set to zero*/"
               "             }"
               "             else if (OutEnd==1) {"
               "               y_cd[j]=ptr_d[nPoints*my+nPoints-1+(j)*nPoints]; // hold outputs at the end"
               "             }"
               "           }"
               "           else if (Method==0){"
               "             if (inow<0){"
               "              y_cd[j]=0.0; /* outputs set to zero */"
               "             }"
               "             else {"
               "               y_cd[j]=ptr_d[nPoints*my+inow+(j)*nPoints];"
               "             }"
               "           }"
               "           else if (Method==1) {"
               "             if (inow<0) {"
               "               inow=0;"
               "             } /* extrapolation for 0<t<X(0) */"
               "             t1=ptr->workt[inow];"
               "             t2=ptr->workt[inow+1];"
               "             y1=ptr_d[nPoints*my+inow+j*nPoints];"
               "             y2=ptr_d[nPoints*my+inow+1+j*nPoints];"
               "             y_cd[j]=(y2-y1)*(t-t1)/(t2-t1)+y1;"
               "           }"
               "           else if (Method>=2) {"
               "             t1=ptr->workt[inow];"
               "             t2=ptr->workt[inow+1];"
               "             y1=ptr_d[inow+j*nPoints+nPoints];"
               "             y2=ptr_d[inow+1+j*nPoints+nPoints];"
               "             d1=ptr_D[inow+j*nPoints+nPoints];"
               "             d2=ptr_D[inow+1+j*nPoints+nPoints];"
               "             Myevalhermite2(&t, &t1,&t2, &y1,&y2, &d1,&d2, &h, &dh, &ddh, &dddh, &inow);"
               "             y_cd[j]=h;"
               "           }"
               "         }"
               "       }"
               "       else if (ptr->Yt==8) {"
               "         switch (ptr->Yst) {"
               "         case 1: /* ---------------------int8 char  ---------------------------- */"
               "           y_c = Getint8OutPortPtrs(block,1);"
               "           ptr_c=(char*) ptr->work;"
               "           /*y_c[j]=ptr_c[inow+(j)*nPoints];*/"
               "           if (inow>=nPoints-1) {"
               "             if (OutEnd==0) {"
               "               y_c[j]=0; /* outputs set to zero */"
               "             }"
               "             else if (OutEnd==1) {"
               "               y_c[j]=ptr_c[nPoints-1+(j)*nPoints]; /* hold outputs at the end */"
               "             }"
               "           }"
               "           else if (Method==0) {"
               "             if (inow<0) {"
               "               y_c[j]=0;"
               "             }"
               "             else {"
               "               y_c[j]=ptr_c[inow+(j)*nPoints];"
               "             }"
               "           }"
               "           else if (Method>=1){"
               "             if (inow<0) {"
               "               inow=0;"
               "             }"
               "             t1=ptr->workt[inow];"
               "             t2=ptr->workt[inow+1];"
               "             y1=(double)ptr_c[inow+j*nPoints];"
               "             y2=(double)ptr_c[inow+1+j*nPoints];"
               "             y_c[j] =(char)((y2-y1)*(t-t1)/(t2-t1)+y1);"
               "           }"
               "           break;"
               "         case 2: /* ---------------------int16 short--------------------- */"
               "           y_s = Getint16OutPortPtrs(block,1);"
               "           ptr_s=(short*) ptr->work;"
               "           /* y_s[j]=ptr_s[inow+(j)*nPoints]; */"
               "           if (inow>=nPoints-1) {"
               "             if (OutEnd==0) {"
               "               y_s[j]=0; /* outputs set to zero */"
               "             }"
               "             else if (OutEnd==1) {"
               "                y_s[j]=ptr_s[nPoints-1+(j)*nPoints]; // hold outputs at the end"
               "             }"
               "           }"
               "           else if (Method==0) {"
               "             if (inow<0) {"
               "               y_s[j]=0;"
               "             }"
               "             else {"
               "               y_s[j]=ptr_s[inow+(j)*nPoints];"
               "             }"
               "           }"
               "           else if (Method>=1) {"
               "             if (inow<0) {"
               "               inow=0;"
               "             }"
               "             t1=ptr->workt[inow];"
               "             t2=ptr->workt[inow+1];"
               "             y1=(double)ptr_s[inow+j*nPoints];"
               "             y2=(double)ptr_s[inow+1+j*nPoints];"
               "             y_s[j] =(short)((y2-y1)*(t-t1)/(t2-t1)+y1);"
               "           }"
               "           break;"
               "         case 4: /* ---------------------int32 long--------------------- */"
               "           y_l = Getint32OutPortPtrs(block,1);"
               "           ptr_l=(long*) ptr->work;"
               "           /*y_l[j]=ptr_l[inow+(j)*nPoints];*/"
               "           if (inow>=nPoints-1) {"
               "             if (OutEnd==0) {"
               "               y_l[j]=0;/* outputs set to zero */"
               "             }"
               "             else if (OutEnd==1) {"
               "               y_l[j]=ptr_l[nPoints-1+(j)*nPoints]; /* hold outputs at the end */"
               "             }"
               "           }"
               "           else if (Method==0) {"
               "             if (inow<0) {"
               "               y_l[j]=0;"
               "             }"
               "             else {"
               "               y_l[j]=ptr_l[inow+(j)*nPoints];"
               "             }"
               "           }"
               "           else if (Method>=1) {"
               "             t1=ptr->workt[inow];"
               "             t2=ptr->workt[inow+1];"
               "             y1=(double)ptr_l[inow+j*nPoints];"
               "             y2=(double)ptr_l[inow+1+j*nPoints];"
               "             y_l[j] =(long)((y2-y1)*(t-t1)/(t2-t1)+y1);"
               "           }"
               "           break;"
               "         case 11: /*--------------------- uint8 uchar---------------------*/"
               "           y_uc = Getuint8OutPortPtrs(block,1);"
               "           ptr_uc=(unsigned char*) ptr->work;"
               "           /*y_uc[j]=ptr_uc[inow+(j)*nPoints];*/"
               "           if (inow>=nPoints-1) {"
               "             if (OutEnd==0) {"
               "               y_uc[j]=0;/* outputs set to zero */"
               "             }"
               "             else if (OutEnd==1) {"
               "               y_uc[j]=ptr_uc[nPoints-1+(j)*nPoints]; /* hold outputs at the end */"
               "             }"
               "           }"
               "           else if (Method==0) {"
               "             if (inow<0) {"
               "               y_uc[j]=0;"
               "             }"
               "             else {"
               "               y_uc[j]=ptr_uc[inow+(j)*nPoints];"
               "             }"
               "           }"
               "           else if (Method>=1) {"
               "             t1=ptr->workt[inow];"
               "             t2=ptr->workt[inow+1];"
               "             y1=(double)ptr_uc[inow+j*nPoints];"
               "             y2=(double)ptr_uc[inow+1+j*nPoints];"
               "             y_uc[j] =(unsigned char)((y2-y1)*(t-t1)/(t2-t1)+y1);"
               "           }"
               "         break;"
               "         case 12: /* ---------------------uint16 ushort--------------------- */"
               "           y_us = Getuint16OutPortPtrs(block,1);"
               "           ptr_us=(unsigned short*) ptr->work;"
               "           /* y_us[j]=ptr_us[inow+(j)*nPoints]; */"
               "           if (inow>=nPoints-1) {"
               "             if (OutEnd==0) {"
               "               y_us[j]=0;/* outputs set to zero */"
               "             }"
               "             else if (OutEnd==1) {"
               "               y_us[j]=ptr_us[nPoints-1+(j)*nPoints]; /* hold outputs at the end */"
               "             }"
               "           }"
               "           else if (Method==0) {"
               "             if (inow<0) {"
               "               y_us[j]=0;"
               "             }"
               "             else {"
               "               y_us[j]=ptr_us[inow+(j)*nPoints];"
               "             }"
               "           }"
               "           else if (Method>=1) {"
               "             t1=ptr->workt[inow];"
               "             t2=ptr->workt[inow+1];"
               "             y1=(double)ptr_us[inow+j*nPoints];"
               "             y2=(double)ptr_us[inow+1+j*nPoints];"
               "             y_us[j] =(unsigned short)((y2-y1)*(t-t1)/(t2-t1)+y1);"
               "           }"
               "           break;"
               "         case 14: /* ---------------------uint32 ulong--------------------- */"
               "           y_ul = Getuint32OutPortPtrs(block,1);"
               "           ptr_ul=(unsigned long*) ptr->work;"
               "           /* y_ul[j]=ptr_ul[inow+(j)*nPoints]; */"
               "           if (inow>=nPoints-1) {"
               "             if (OutEnd==0) {"
               "               y_ul[j]=0;/* outputs set to zero */"
               "             }"
               "             else if (OutEnd==1) {"
               "               y_ul[j]=ptr_ul[nPoints-1+(j)*nPoints]; /* hold outputs at the end */"
               "             }"
               "           }"
               "           else if (Method==0) {"
               "             if (inow<0) {"
               "               y_ul[j]=0;"
               "             }"
               "             else {"
               "               y_ul[j]=ptr_ul[inow+(j)*nPoints];"
               "             }"
               "           }"
               "           else if (Method>=1) {"
               "             t1=ptr->workt[inow];"
               "             t2=ptr->workt[inow+1];"
               "             y1=(double)ptr_ul[inow+j*nPoints];"
               "             y2=(double)ptr_ul[inow+1+j*nPoints];"
               "             y_ul[j] =(unsigned long)((y2-y1)*(t-t1)/(t2-t1)+y1);"
               "           }"
               "           break;"
               "         }"
               "       }"
               "     } /* for j loop */"
               "   }"
               "   /********************************************************************/"
               " }"
               " else if(flag==3) {   /* event date computation */"
               "   /* retrieve ptr of the structure of that block */"
               "   ptr = *(_work);"
               "   nPoints=ptr->nPoints;"
               "   cnt1=ptr->cnt1;"
               "   cnt2=ptr->cnt2;"
               "   EVindex= ptr->EVindex;"
               "   PerEVcnt=ptr->PerEVcnt;"
               ""
               "   /* get current simulation time */"
               "   t=get_scicos_time();"
               ""
               "   if (ZC==1) { /* generate Events only if ZC is active */"
               "     if ((Method==1)||(Method==0)) {"
               "       /*-------------------------*/"
               "       if (ptr->firstevent==1) {"
               "         jfirst=nPoints-1; /* finding first positive time instant */"
               "         for (j=0;j<nPoints;j++) {"
               "           if (ptr->workt[j]>0) {"
               "             jfirst=j;"
               "             break;"
               "           }"
               "         }"
               "         _evout[0]=ptr->workt[jfirst];"
               "         EVindex=jfirst;"
               "         ptr->EVindex=EVindex;"
               "         ptr->firstevent=0;"
               "         return;"
               "       }"
               "       /*------------------------*/"
               "       i=EVindex;"
               "       /*------------------------*/"
               "       if (i<nPoints-1) {"
               "         _evout[0]=ptr->workt[i+1]-ptr->workt[i];"
               "         EVindex=i+1;"
               "       }"
               "       /*------------------------*/"
               "       if (i==nPoints-1) {"
               "         if (OutEnd==2) {/*  Periodic*/"
               "           cnt1=-1;"
               "           cnt2=0;"
               "           PerEVcnt++;/* When OutEnd==2 (perodic output)*/"
               "           jfirst=nPoints-1; /* finding first positive time instant */"
               "           for (j=0;j<nPoints;j++) {"
               "             if (ptr->workt[j]>0) {"
               "               jfirst=j;"
               "               break;"
               "             }"
               "           }"
               "           _evout[0]=ptr->workt[jfirst];"
               "           EVindex=jfirst;"
               "         }"
               "       }"
               "       /*-------------------------- */"
               "     }"
               "     else if (Method<=3) {"
               "       if (ptr->firstevent==1) {"
               "         _evout[0]=TP;"
               "         ptr->firstevent=0;"
               "       }"
               "       else {"
               "         if (OutEnd==2) {"
               "           _evout[0]=TP;"
               "         }"
               "         PerEVcnt++;"
               "       }"
               "       cnt1=-1;"
               "       cnt2=0;"
               "     }"
               "     ptr->cnt1=cnt1;"
               "     ptr->cnt2=cnt2;"
               "     ptr->EVindex=EVindex;"
               "     ptr->PerEVcnt=PerEVcnt;"
               "   }"
               "   /***********************************************************************/"
               " }"
               " else if (flag==5) { /* finish */"
               "   ptr = *(_work);"
               "   if (ptr!=NULL) {"
               "     if (ptr->D!=NULL) {"
               "       scicos_free(ptr->D);"
               "     }"
               "     if (ptr->work!=NULL) {"
               "       scicos_free(ptr->work);"
               "     }"
               "     if (ptr->workt!=NULL) {"
               "       scicos_free(ptr->workt);"
               "     }"
               "     scicos_free(ptr);"
               "   }"
               " }"
               " /*************************************************************************/"
               "}"
               ""
               "int Ishm(int *fd,int *Ytype,int *nPoints,int *my,int *ny,int *YsubType)"
               "{"
               " int *ptr_i;"
               " int j,ierr;"
               ""
               " /*work array to store header of hypermat*/"
               " if((ptr_i=(int *) scicos_malloc(37*sizeof(int)))==NULL) {"
               "   return 0;"
               " }"
               ""
               " C2F(mgetnc) (fd, ptr_i, (j=37,&j), fmti, &ierr);  /* read sci id */"
               " if (ierr!=0) {"
               "   return 0;"
               " }"
               ""
               " if ((ptr_i[0]!=3)  || \"
               "     (ptr_i[1]!=1)  || \"
               "     (ptr_i[5]!=10) || \"
               "     (ptr_i[6]!=1)  || \"
               "     (ptr_i[7]!=3)  || \"
               "     (ptr_i[8]!=0)  || \"
               "     (ptr_i[9]!=1)  || \"
               "     (ptr_i[10]!=ptr_i[9]+2)  || \"
               "     (ptr_i[11]!=ptr_i[10]+4) || \"
               "     (ptr_i[12]!=ptr_i[11]+7) || \"
               "     (ptr_i[13]!=17) || \"
               "     (ptr_i[14]!=22) || \"
               "     (ptr_i[15]!=13) || \"
               "     (ptr_i[16]!=18) || \"
               "     (ptr_i[17]!=22) || \"
               "     (ptr_i[18]!=28) || \"
               "     (ptr_i[19]!=14) || \"
               "     (ptr_i[20]!=23) || \"
               "     (ptr_i[21]!=29) || \"
               "     (ptr_i[22]!=27) || \"
               "     (ptr_i[23]!=18) || \"
               "     (ptr_i[24]!=14) || \"
               "     (ptr_i[25]!=28) || \"
               "     (ptr_i[26]!=8)  || \"
               "     (ptr_i[27]!=1)  || \"
               "     (ptr_i[28]!=3)  || \"
               "     (ptr_i[29]!=4))"
               "  {"
               "   Coserror(""Invalid variable type : error in hypermat scilab coding.\n"");"
               "   return 0;"
               "  }"
               ""
               " *my      = ptr_i[30];    /*37*/"
               " *ny      = ptr_i[31];    /*38*/"
               " *nPoints = ptr_i[32];    /*39*/"
               " *Ytype   = ptr_i[33];    /*40*/"
               ""
               " if ((ptr_i[34]!=ptr_i[30]*ptr_i[31]*ptr_i[32]) || \"
               "     (ptr_i[35]!=1))"
               "  {"
               "   Coserror(""Invalid variable type : error in hypermat scilab coding.\n"");"
               "   return 0;"
               "  }"
               ""
               " *YsubType = ptr_i[36];   /*43*/"
               ""
               " scicos_free(ptr_i);"
               " return 1;"
               "}"
               ""
               "int Mytridiagldltsolve(double *dA, double * lA, double * B, int N)"
               "{"
               "  double Temp;"
               "  int j;"
               ""
               "  for (j = 1; j <= N-1; ++j) {"
               "    Temp = lA[j-1];"
               "    lA[j-1] /= dA[j-1];"
               "    B[j] -= lA[j-1] * B[j-1];"
               "    dA[j] -= Temp * lA[j-1];"
               "  } "
               ""
               "  B[N-1] /= dA[N-1];"
               "  for (j = N - 2; j >= 0; --j) {"
               "    B[j] = - lA[j] * B[j + 1] + B[j] / dA[j];"
               "  }"
               ""
               "  return 0;"
               "}"
               ""
               ""
               "int Myevalhermite2(double *t, double *x1, double *x2, double *y1, double *y2, double *d1, double *d2, double *z, double *dz, double *ddz, double *dddz, int *k)"
               "{"
               "  double Temp, p, p2, p3, D;"
               "  Temp = *t - *x1;"
               "  D = 1.0 / (*x2 - *x1);"
               "  p = (*y2 - *y1) * D;"
               "  p2 = (p - *d1) * D;"
               "  p3 = (*d2 - p + (*d1 - p)) * (D * D);"
               "  *z = p2 + p3 * (*t - *x2);"
               "  *dz = *z + p3 * Temp;"
               "  *ddz = (*dz + p3 * Temp) * 2.;"
               "  *dddz = p3 * 6.0;"
               "  *z = *d1 + *z * Temp;"
               "  *dz = *z + *dz * Temp;"
               "  *z = *y1 + *z * Temp;"
               "  return 0; "
               "}  "
               ""]

      case 'gainblk' then
        txt = [""
               "#include ""machine.h"""
               "#include ""scicos_block4.h"""
               ""
               "extern int C2F(dmmul)();"
               "extern int C2F(dmmul1)();"
               ""
               ""
               "void gainblk(scicos_block *block,int flag)"
               "{"
               "  int i;"
               ""
               "  double *u; double *y;"
               "  int nu,ny,my;"
               "  double *rpar;"
               "  int nrpar;"
               ""
               "  nu=GetInPortRows(block,1);"
               "  ny=GetOutPortRows(block,1);"
               "  my=GetOutPortCols(block,1);"
               ""
               "  u=GetRealInPortPtrs(block,1);"
               "  y=GetRealOutPortPtrs(block,1);"
               ""
               "  nrpar=GetNrpar(block);"
               ""
               "  rpar=GetRparPtrs(block);"
               ""
               "  if (nrpar==1){"
               "    for (i=0;i<nu*my;++i){"
               "     y[i]=rpar[0]*u[i];"
               "    }"
               "  }else{"
               "    C2F(dmmul)(rpar,&ny,u,&nu,y,&ny,&ny,&nu,&my);"
               "  }"
               "}"]

      case 'hystheresis' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void  hystheresis(scicos_block *block,int flag)"
               "{"
               "  double *_rpar=GetRparPtrs(block);"
               "  int _ng=GetNg(block);"
               "  double *_g=GetGPtrs(block);"
               "  int *_mode=GetModePtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  if (flag==1){"
               "    if (get_phase_simulation()==1||_ng==0) {"
               "      if (*_u1>=_rpar[0]){"
               "        _y1[0]=_rpar[2];"
               "      }else if (*_u1<=_rpar[1]){"
               "        _y1[0]=_rpar[3];"
               "      }else if ((_y1[0]!=_rpar[3])&&(_y1[0]!=_rpar[2])){"
               "        _y1[0]=_rpar[3];"
               "        /* Handling sitauations where all zero-crossings are"
               "           suppressed in discrete models. In this case, initial state"
               "           is initialised to OFF*/"
               "      }"
               "    }else{"
               "      /* compatibility with simulink: when input value is located"
               "           between two margines the OFF state is selected. Initial"
               "           Mode is OFF (mode==0)*/"
               "      if (_mode[0]==2){"
               "        _y1[0]=_rpar[2];"
               "      }else{"
               "        _y1[0]=_rpar[3];"
               "      }"
               "    } "
               "  } else if (flag==9){"
               "    _g[0]=*_u1-(_rpar[0]);"
               "    _g[1]=*_u1-(_rpar[1]);"
               "    if (get_phase_simulation()==1) {"
               "      if (_g[0]>=0){"
               "        _mode[0]=2;"
               "      }else if (_g[1]<=0){"
               "        _mode[0]=1;"
               "      }"
               "    }"
               "  }"
               "}"]

      case 'integral_func' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void  integral_func(scicos_block *block,int flag)"
               "{int i;"
               "  double *_rpar=GetRparPtrs(block);"
               "  int _nx=GetNstate(block);"
               "  double *_xd=GetDerState(block);"
               "  double *_x=GetState(block);"
               "  int _ng=GetNg(block);"
               "  double *_g=GetGPtrs(block);"
               "  int *_mode=GetModePtrs(block);"
               "  int _nevprt=GetNevIn(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double *_u2=GetRealInPortPtrs(block,2);"
               "  if (flag==0){"
               "    if(_ng>0){"
               "      for(i=0;i<_nx;++i) {"
               "        if(_mode[i]==3){"
               "          _xd[i]=_u1[i];"
               "        }else{"
               "          _xd[i]=0.0;"
               "        }"
               "      }"
               "    }else{"
               "      for(i=0;i<_nx;++i) {"
               "        _xd[i]=_u1[i];"
               "      }"
               "    }"
               "  }else if (flag==1||flag==6){"
               "    for(i=0;i<_nx;++i) {"
               "      _y1[i]=_x[i];"
               "    }"
               "  }else if (flag==2&&_nevprt==1){"
               "    for(i=0;i<_nx;++i) {"
               "      _x[i]=_u2[i];"
               "    }"
               "  } else if (flag==9){"
               "    for(i=0;i<_nx;++i) {"
               "      if (_mode[i]==3){"
               "        _g[i]=(_x[i]-(_rpar[i]))*(_x[i]-(_rpar[_nx+i]));"
               "      } else {"
               "        _g[i]=_u1[i];"
               "      } "
               "      if (get_phase_simulation()==1) {"
               "        if (_u1[i]>=0&&_x[i]>=_rpar[i]){"
               "          _mode[i]=1;"
               "        }else if (_u1[i]<=0&&_x[i]<=_rpar[_nx+i]){"
               "          _mode[i]=2;"
               "        }else {"
               "          _mode[i]=3;"
               "        }"
               "      }"
               "    }"
               "  }"
               "}"]

      case 'invblk4' then
        txt = ["#include ""scicos_block4.h"""
               "#include <stdio.h>"
               ""
               "void invblk4(scicos_block *block,int flag)"
               "{"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  /* Copyright INRIA"
               "     "
               "  Scicos block simulator"
               "  Outputs the inverse of the input */"
               "  "
               "  int i;"
               "  double ww;"
               "  if (flag == 6){"
               "    for(i=0;i< GetInPortRows(block,1);i++){"
               "      ww=_u1[i];"
               "      if (ww != 0.0)"
               "        _y1[i]=1.0/ww;"
               "    }"
               "  }"
               "  if (flag == 1){"
               "    for(i=0;i< GetInPortRows(block,1);i++){"
               "      ww=_u1[i];"
               "      if (ww != 0.0)"
               "        _y1[i]=1.0/ww;"
               "      else{"
               "        set_block_error(-2);"
               "        return;"
               "      }"
               "    }"
               "  } "
               "}"]

      case 'logic' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void logic(scicos_block *block,int flag)"
               "{"
               "    char *u,*y;"
               "    char inp,num;"
               "    int i,nin,nout,mo;"
               "    char *opar;"
               "    nin=GetNin(block);"
               "    nout=GetNout(block);"
               "    opar=Getint8OparPtrs(block,1);"
               "    mo=GetOparSize(block,1,1);"
               "    if (flag==1) {"
               "        num=0;"
               "        for (i=0;i<nin;i++)"
               "        {"
               "            u=Getint8InPortPtrs(block,i+1);"
               "            inp=*u;"
               "            if (inp>0) inp=1;"
               "            else inp=0;"
               "            inp=inp<<i;"
               "            num=num+inp;"
               "        }"
               "        for (i=0;i<nout;i++)"
               "        {"
               "            y=Getint8OutPortPtrs(block,i+1);"
               "            *y=*(opar+num+i*mo);"
               "        }"
               "    }"
               "    if (flag==6) {"
               "        u=Getint8InPortPtrs(block,1);"
               "        for (i=0;i<nout;i++)"
               "        {"
               "            y=Getint8OutPortPtrs(block,i+1);"
               "            *y=*u;"
               "        }"
               "    }"
               "}"]

      case 'logicalop' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void logicalop(scicos_block *block,int flag)"
               "{"
               "  int *_ipar=GetIparPtrs(block);"
               "  int _nin=GetNin(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double *uytmp;"
               "  int i,j,k,l;"
               "  i=_ipar[0];"
               "  switch (i)"
               "    {"
               "    case 0:"
               "      if (_nin==1)"
               "        {"
               "          _y1[0]=1.0;"
               "          for (j=0;j<GetInPortRows(block,1);j++) {"
               "            if(_u1[j]<=0)"
               "              {"
               "                _y1[0]=0.0;"
               "                break;"
               "              }"
               "          }"
               "        }"
               "      else {"
               "        for (j=0;j<GetInPortRows(block,1);j++) {"
               "          _y1[j]=1.0;"
               "          for (k=0;k<_nin;k++) {"
               "            uytmp=GetRealInPortPtrs(block,k+1);"
               "            if(uytmp[j]<=0) {"
               "              _y1[j]=0.0;"
               "              break;"
               "            }"
               "          }"
               "        }"
               "      }"
               "      break;"
               "      "
               "    case 1:"
               "      if (_nin==1)"
               "        {"
               "          _y1[0]=0.0;"
               "          for (j=0;j<GetInPortRows(block,1);j++) {"
               "            if(_u1[j]>0) {"
               "              _y1[0]=1.0;"
               "              break;"
               "            }"
               "          }"
               "        }"
               "      else {"
               "        for (j=0;j<GetInPortRows(block,1);j++) {"
               "          _y1[j]=0.0;"
               "          for (k=0;k<_nin;k++) {"
               "            uytmp=GetRealInPortPtrs(block,k+1);"
               "            if(uytmp[j]>0) {"
               "              _y1[j]=1.0;"
               "              break;"
               "            }"
               "          }"
               "        }"
               "      }"
               "      break;"
               ""
               "    case 2:"
               "      if (_nin==1)"
               "        {"
               "          _y1[0]=0.0;"
               "          for (j=0;j<GetInPortRows(block,1);j++) {"
               "            if(_u1[j]<=0)"
               "              {"
               "                _y1[0]=1.0;"
               "                break;"
               "              }"
               "          }"
               "        }"
               "      else {"
               "        for (j=0;j<GetInPortRows(block,1);j++) {"
               "          _y1[j]=0.0;"
               "          for (k=0;k<_nin;k++) {"
               "            uytmp=GetRealInPortPtrs(block,k+1);"
               "            if(uytmp[j]<=0) {"
               "              _y1[j]=1.0;"
               "              break;"
               "            }"
               "          }"
               "        }"
               "      }"
               "      break;"
               ""
               "    case 3:"
               "      if (_nin==1)"
               "        {"
               "          _y1[0]=1.0;"
               "          for (j=0;j<GetInPortRows(block,1);j++) {"
               "            if(_u1[j]>0) {"
               "              _y1[0]=0.0;"
               "              break;"
               "            }"
               "          }"
               "        }"
               "      else {"
               "        for (j=0;j<GetInPortRows(block,1);j++) {"
               "          _y1[j]=1.0;"
               "          for (k=0;k<_nin;k++) {"
               "            uytmp=GetRealInPortPtrs(block,k+1);"
               "            if(uytmp[j]>0) {"
               "              _y1[j]=0.0;"
               "              break;"
               "            }"
               "          }"
               "        }"
               "      }"
               "      break;"
               ""
               "    case 4:"
               "      if (_nin==1)"
               "        {"
               "          l=0;"
               "          for (j=0;j<GetInPortRows(block,1);j++) {"
               "            if(_u1[j]>0) {"
               "              l=(l+1)%2;"
               "            }"
               "          }"
               "          _y1[0]=(double) l;"
               "        }"
               "      else {"
               "        for (j=0;j<GetInPortRows(block,1);j++) {"
               "          l=0;"
               "          for (k=0;k<_nin;k++) {"
               "            uytmp=GetRealInPortPtrs(block,k+1);"
               "            if(uytmp[j]>0) {"
               "              l=(l+1)%2;"
               "            }"
               "          }"
               "          _y1[j]=(double) l;"
               "        }"
               "      }"
               "      break;"
               ""
               "    case 5:"
               "      for (j=0;j<GetInPortRows(block,1);j++) {"
               "        if(_u1[j]>0) {"
               "          _y1[j]=0.0;"
               "        }"
               "        else{"
               "          _y1[j]=1.0;"
               "        }"
               "      }"
               "    }"
               "}"]

      case 'lookup2d' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               ""
               ""
               "//  10/2007 --------"
               "// Copyright INRIA"
               ""
               "#if WIN32"
               "#define NULL    0"
               "#endif"
               ""
               ""
               "#define InterpExtrapBlin  1"
               "#define InterpEndValue    2"
               "#define InputNearest      3"
               "#define InputBelow        4"
               "#define InputAbove        5"
               "#define InterpExtraplin   6"
               ""
               ""
               "double computeZ2(double *X, double *Y, double *Z, int nx, int ny, int method, double x, double y);"
               "int indexfinder2(double x, int n, double *LT);"
               ""
               "void lookup2d(scicos_block *block,int flag)"
               "{"
               "  double *_rpar=GetRparPtrs(block);"
               "  int *_ipar=GetIparPtrs(block);"
               "  double *y, *u1, *u2;"
               "  double *X, *Y, *Z;"
               ""
               "  int Nx= _ipar[0];"
               "  int Ny= _ipar[1];"
               "  int method= _ipar[2];"
               ""
               "  X = _rpar;"
               "  Y = X+Nx; "
               "  Z = Y+Ny;"
               ""
               "  switch(flag)"
               "  {"
               "   /* init */"
               "   case 4  :"
               ""
               "   case 1  : "
               "     u1=GetRealInPortPtrs(block,1);"
               "     u2=GetRealInPortPtrs(block,2);"
               "     y =GetRealOutPortPtrs(block,1);"
               "     y[0]=computeZ2(X, Y, Z, Nx, Ny, method, u1[0], u2[0]);"
               "     break;"
               "   case 3  : "
               "   case 5  :"
               "   default : break;"
               "  }"
               "}"
               ""
               "double computeZ2(double *X, double *Y, double *Z, int nx, int ny, int method, double x, double y)"
               "{"
               "  int i,j,im,jm;"
               "  double fq11,fq12,fq21,fq22,w,w1,w2,z=0.;"
               "  double x1,x2,x3,y1,y2,y3,z1,z2,z3,A,B,C,D;"
               "  i=indexfinder2(x, nx, X); "
               "  j=indexfinder2(y, ny, Y);  "
               ""
               "  if (method==InputNearest){"
               "    "
               "    if ((X[i]-x)>(x-X[i-1])) i=i-1;    "
               "    if ((Y[j]-y)>(y-Y[j-1])) j=j-1;"
               "    z=Z[i+j*nx];"
               ""
               "  }else if (method==InputBelow){"
               "    im=i-1; jm=j-1;    "
               "    z=Z[im+jm*nx];    "
               "  }else if (method==InputAbove){"
               "    z=Z[i+j*nx];"
               "  }else if (method==InterpEndValue){"
               "    if (x>=X[nx-1]){x=X[nx-1];} else if(x<=X[0]){x=X[0];};    "
               "    if (y>=Y[ny-1]){y=Y[ny-1];} else if(y<=Y[0]){y=Y[0];};"
               "    im=i-1; jm=j-1;    "
               "    fq11=Z[im+jm*nx];"
               "    fq21=Z[i+jm*nx];"
               "    fq12=Z[im+j*nx];"
               "    fq22=Z[i+j*nx];"
               ""
               "    w=(X[i]-X[im])*(Y[j]-Y[jm]);"
               "    w1=(fq11*(X[i]-x)+fq21*(x-X[im]))*(Y[j]-y);"
               "    w2=(fq12*(X[i]-x)+fq22*(x-X[im]))*(y-Y[jm]);"
               "    z=(w1+w2)/w;"
               "  "
               "  }else if (method==InterpExtrapBlin){"
               "    im=i-1; jm=j-1;    "
               "    fq11=Z[im+jm*nx];"
               "    fq21=Z[i+jm*nx];"
               "    fq12=Z[im+j*nx];"
               "    fq22=Z[i+j*nx];"
               ""
               "    w=(X[i]-X[im])*(Y[j]-Y[jm]);"
               "    w1=(fq11*(X[i]-x)+fq21*(x-X[im]))*(Y[j]-y);"
               "    w2=(fq12*(X[i]-x)+fq22*(x-X[im]))*(y-Y[jm]);"
               "    z=(w1+w2)/w;"
               "  }else if (method==InterpExtraplin){ /* triangulation*/"
               "    /*"
               "      If the linear interpolation scheme is selected, the 2D points"
               "      are first triangulated. It is a network of triangles connecting"
               "      the points together. It is used to interpolate.  The equation of"
               "      the plane defined by the three vertices of a triangle is as"
               "      follows: Ax+By+Cz+D=0; where A, B, and C, and D are computed"
               "      from the coordinates of the three vertices (x1,y1,z1),"
               "      (x2,y2,z2), & (x3,y3,z3).  which is the form of the plane"
               "      equation used to compute the elevation at any point on the"
               "      triangle."
               "    */"
               ""
               "    im=i-1; jm=j-1;    "
               "    x1=X[i];"
               "    y1=Y[jm];"
               "    z1=Z[i+nx*jm];"
               "    x2=X[im];"
               "    y2=Y[j];"
               "    z2=Z[im+nx*j];"
               "    if ( ((x-x1)/(x2-x1)>(y-y1)/(y2-y1)) ) {"
               "      x3=X[im];"
               "      y3=Y[jm];"
               "      z3=Z[im+nx*jm];"
               "    }else{"
               "      x3=X[i];"
               "      y3=Y[j];"
               "      z3=Z[i+nx*(j)];"
               "    }"
               "    A=y1*(z2-z3)+y2*(z3-z1)+y3*(z1-z2);"
               "    B=z1*(x2-x3)+z2*(x3-x1)+z3*(x1-x2);"
               "    C=x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2);"
               "    D=-A*x1-B*y1-C*z1;"
               "    z=-(A*x+B*y+D)/C;"
               "  }"
               "  return z;"
               "}"
               ""
               "int indexfinder2(double x, int n, double *LT)"
               "{"
               "  int i1, i2, i_mid;"
               "  "
               "  /* if X(k-1)<= x < X(k) then i2=k */"
               "  if (x<=LT[0]  ) return 1;"
               "  if (x>=LT[n-1]) return n-1;"
               "  i1=0;"
               "  i2=n-1;"
               ""
               "  while (i1!=i2-1){"
               "    i_mid=(int)((i1+i2)/2);"
               "    if (x>=LT[i_mid])  i1=i_mid;"
               "    else          i2=i_mid;"
               "  }     "
               "  return i2;"
               "}       "
               ""]

      case 'lookup_c' then
        txt = ["#include ""scicos_block4.h"""
               ""
               "/*    Masoud Najafi, January 2008 */"
               "/*    Copyright INRIA"
               " *    Scicos block simulator"
               " *    Lookup table block"
               " */"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "int FindIndex(int, double , int , int , double *, int);"
               ""
               "int Myevalhermite(double *t, double *xa, double *xb, double *ya, double *yb, double *da, double *db, double *h, double *dh, double *ddh, double *dddh, int *i);"
               ""
               "void lookup_c(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  double *_rpar=GetRparPtrs(block);"
               "  int *_ipar=GetIparPtrs(block);"
               "  /* double *_evout= GetNevOutPtrs(block); */"
               "  double a,b,c,y1,y2,t1,t2,*RPAR,T;"
               "  int *ind,inow,i,ip1,nPoints,Order,Periodic,Extrapo;"
               "  double *y,*u,u0;"
               "  double  d1,d2,h, dh, ddh, dddh;"
               ""
               "  RPAR=     _rpar;"
               "  nPoints=  _ipar[0];"
               "  Order=    _ipar[1];"
               "  Periodic= _ipar[2];"
               "  Extrapo=  _ipar[3];"
               "  T=        RPAR[nPoints-1]-RPAR[0];"
               ""
               "    switch(flag)"
               "      {"
               "        /* init */"
               "      case 4  : {/* the workspace is used to store discrete counter value */"
               "        if ((*_work=scicos_malloc(1*sizeof(int)))==NULL) {set_block_error(-16);return;}"
               "        ind=*_work;"
               "        ind[0]=0;"
               ""
               "        return;"
               "      } "
               "        /* event date computation */"
               "      case 1  : { "
               "        y=GetRealOutPortPtrs(block,1);"
               "        u=GetRealInPortPtrs(block,1); "
               "        u0=u[0];"
               "        ind=*_work;"
               "        i=ind[0];"
               "        ip1=i+1;"
               ""
               "        if((Extrapo==0)||((Extrapo==1)&&((Order==0)||(Order==8)||(Order==9)))) {"
               "          if(u0<RPAR[0]) {"
               "            y[0]=RPAR[nPoints];"
               "            break;"
               "          }"
               "          if (u0>=RPAR[nPoints-1]){"
               "            y[0]=RPAR[nPoints*2-1];"
               "            break;"
               "          }"
               "        }"
               ""
               "        if (u0<RPAR[i]) {"
               "          i=FindIndex(Order,u0,0,i,RPAR,nPoints);"
               "          ip1=i+1;"
               "        }else if (u0>=RPAR[ip1]) {"
               "          i=FindIndex(Order,u0,ip1,nPoints-1,RPAR,nPoints);             "
               "          ip1=i+1;"
               "        }"
               "        ind[0]=i;"
               ""
               "        if (Order==0) { /* (METHOD==''zero order-below'')*/"
               "          y[0]=RPAR[nPoints+i];"
               "          break;"
               "        }"
               ""
               "        if (Order==8) { /* (METHOD==''zero order-above'')*/"
               "          y[0]=RPAR[nPoints+i+1];"
               "          break;"
               "        }"
               ""
               "        if (Order==9) { /* (METHOD==''zero order-nearest'')*/"
               "          if (u0<(RPAR[i]+RPAR[i+1])/2 )"
               "            y[0]=RPAR[nPoints+i];"
               "          else"
               "            y[0]=RPAR[nPoints+i+1];"
               "          break;"
               "        }"
               ""
               "        if(Order==1) {"
               "          t1=RPAR[i];"
               "          t2=RPAR[i+1];"
               "          y1=RPAR[nPoints+i]; "
               "          y2=RPAR[nPoints+i+1];"
               "          y[0]=(y2-y1)*(u0-t1)/(t2-t1)+y1;"
               "          break;"
               "        }"
               "        "
               "        if((Order==2)&&(nPoints>2)) {"
               "          t1=RPAR[i];"
               "          a=RPAR[2*nPoints+i];"
               "          b=RPAR[2*nPoints+i+nPoints-1];"
               "          c=RPAR[2*nPoints+i+2*nPoints-2];"
               "          y[0]=a*(u0-t1)*(u0-t1)+b*(u0-t1)+c;"
               "          break;"
               "        }            "
               "        "
               "        if((Order>=3)&&(Order<=7)) {"
               "          t1=RPAR[i];"
               "          t2=RPAR[i+1];"
               "          y1=RPAR[nPoints+i];"
               "          y2=RPAR[nPoints+i+1];"
               "          d1=RPAR[2*nPoints+i];"
               "          d2=RPAR[2*nPoints+i+1];"
               "          /*-- this function is defined in curve_c.c ---*/"
               "          Myevalhermite(&u0, &t1,&t2, &y1,&y2, &d1,&d2, &h, &dh, &ddh, &dddh, &inow);"
               "          y[0]=h;"
               "          break;"
               "        }"
               "      }"
               "        /* event date computation */"
               "      case 3  : {"
               "        /*      ind=*_work;"
               "        i=ind[0];"
               ""
               "        if ((Order==1)||(Order==0)){"
               "          i=ind[2];"
               "          if (i==nPoints-1){ "
               "            if (Periodic==1) {"
               "              i=0;"
               "              ind[0]=-1;"
               "              ind[1]=0;"
               "            }"
               "          }"
               "          if (i<nPoints-1) {"
               "            _evout[0]=RPAR[i+1]-RPAR[i];"
               "            "
               "            ind[2]=i+1;"
               "          }"
               "          if (ind[2]==1)  ind[3]++;"
               "        }"
               ""
               "        if (Order>=2){"
               "          if ( Periodic) {"
               "            _evout[0]=T;"
               "          }else{"
               "            if (ind[3]==0) {"
               "              _evout[0]=T;"
               "            }"
               "          }"
               "          ind[3]++;"
               "          ind[0]=-1;"
               "          ind[1]=0;"
               "          "
               "        }*/"
               "        break;"
               "      }"
               ""
               "        /* finish */"
               "      case 5  : {"
               "        scicos_free(*_work); /*free the workspace*/"
               "        break;"
               "      }"
               "        "
               "      default : break;"
               "      }"
               "}"
               ""
               ""
               ""
               "int FindIndex(int order, double inp, int idown, int iup, double *data, int N)"
               " {"
               "  int im;"
               "  if (inp<=data[0] )  return 0;"
               "  if (inp>=data[N-1] ) return N-2;"
               "  /*"
               "  if ((order==0) || (order==8)|| (order==9)) {"
               "    if (inp>=data[N-1] ) return (N-1);"
               "  }else {"
               "    if (inp>=data[N-1] ) return (N-2);"
               "    }"
               "  */"
               "  "
               "  while (idown+1!=iup ){"
               "    im = (int)((idown+iup)/2);"
               "    if (inp>=data[im]) {"
               "      idown=im;"
               "    }else if (inp<data[im]) {"
               "      iup=im;"
               "    }     "
               "  }"
               "  "
               "  return idown;"
               "}"]

      case 'm_frequ' then
        txt = ["#include ""scicos_block4.h"""
               ""
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "void m_frequ(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  double *_evout= GetNevOutPtrs(block);"
               "  double *mat;"
               "  double *Dt;"
               "  double *off;"
               "  long *icount;"
               "  double t;"
               "  long long *counter;"
               "  int m;"
               "  mat=GetRealOparPtrs(block,1);"
               "  Dt=GetRealOparPtrs(block,2);"
               "  off=GetRealOparPtrs(block,3);"
               "  icount=Getint32OparPtrs(block,4);"
               "  m=GetOparSize(block,1,1);"
               "  "
               "  switch(flag)"
               "  {"
               ""
               "   case 4 :  {/* the workspace is used to store discrete counter value */"
               "              if ((*_work=scicos_malloc(sizeof(long long int)*2))==NULL) {"
               "                set_block_error(-16);"
               "                return;"
               "              }"
               "              counter=*_work;"
               "              *counter=*icount;"
               "              (*(counter+1))=0;"
               "              break;"
               "             }"
               ""
               "   /* event date computation */"
               "   case 3  : {"
               "              counter=*_work;"
               "              t=get_scicos_time(); "
               "              *counter+=(int)mat[*(counter+1)]; /*increase counter*/"
               "              _evout[(int)mat[*(counter+1)+m]-1]=*off+((double)*counter*(*Dt))-t;"
               "              (*(counter+1))++;"
               "              *(counter+1)=*(counter+1)%m;"
               "              break;"
               "             }"
               ""
               "   /* finish */"
               "   case 5  : {"
               "              scicos_free(*_work); /*free the workspace*/"
               "              break;"
               "             }"
               ""
               "   default : break;"
               "  }"
               "}"]

      case 'mat_bksl' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "#include <stdio.h>"
               "#include <math.h>"
               "extern int C2F(dgetrf)();"
               "extern double C2F(dlamch)();"
               "extern double C2F(dlange)();"
               "extern int C2F(dlacpy)();"
               "extern int C2F(dgecon)();"
               "extern int C2F(dgetrs)();"
               "extern int C2F(dgelsy1)();"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "#ifndef min"
               "#define min(a,b) ((a) <= (b) ? (a) : (b))"
               "#endif"
               ""
               "#ifndef max"
               "#define max(a,b) ((a) >= (b) ? (a) : (b))"
               "#endif"
               ""
               "typedef struct"
               "{         int *ipiv;"
               "          int *rank;"
               "          int *jpvt;"
               "          int *iwork;"
               "          double *dwork;"
               "          double *LAF;"
               "          double *LA;"
               "          double *LXB;"
               "} mat_bksl_struct ;"
               "void mat_bksl(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               " double *u1;"
               " double *u2;"
               " double *y;"
               " int mu;"
               " int nu1;"
               " int nu2;"
               " int info;"
               " int i,l,lw,lu;"
               " mat_bksl_struct *ptr;"
               " double rcond, ANORM, EPS;"
               ""
               " mu =GetInPortRows(block,1);"
               " nu1 =GetInPortCols(block,1);"
               " nu2 =GetInPortCols(block,2);"
               " u1=GetRealInPortPtrs(block,1);"
               " u2=GetRealInPortPtrs(block,2);"
               " y=GetRealOutPortPtrs(block,1);"
               " l=max(mu,nu1);"
               " lu=max(4*nu1,min(mu,nu1)+3*nu1+1);"
               " lw=max(lu,2*min(mu,nu1)+nu2);"
               "             /*init : initialization*/"
               "if (flag==4)"
               "   {if((*(_work)=(mat_bksl_struct*) scicos_malloc(sizeof(mat_bksl_struct)))==NULL)"
               "        {set_block_error(-16);"
               "         return;}"
               "    ptr=*(_work);"
               "    if((ptr->ipiv=(int*) scicos_malloc(sizeof(int)*nu1))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->rank=(int*) scicos_malloc(sizeof(int)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->jpvt=(int*) scicos_malloc(sizeof(int)*nu1))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->rank);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->iwork=(int*) scicos_malloc(sizeof(int)*nu1))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->jpvt);"
               "         scicos_free(ptr->rank);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->dwork=(double*) scicos_malloc(sizeof(double)*lw))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->jpvt);"
               "         scicos_free(ptr->rank);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LAF=(double*) scicos_malloc(sizeof(double)*(mu*nu1)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->jpvt);"
               "         scicos_free(ptr->rank);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LA=(double*) scicos_malloc(sizeof(double)*(mu*nu1)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LAF);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->jpvt);"
               "         scicos_free(ptr->rank);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LXB=(double*) scicos_malloc(sizeof(double)*(l*nu2)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr->LAF);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->jpvt);"
               "         scicos_free(ptr->rank);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    "
               "   }"
               ""
               "       /* Terminaison */"
               "else if (flag==5)"
               "   {ptr=*(_work);"
               "    if(ptr->LXB!=NULL){"
               "        scicos_free(ptr->ipiv);"
               "        scicos_free(ptr->rank);"
               "        scicos_free(ptr->jpvt);"
               "        scicos_free(ptr->iwork);"
               "        scicos_free(ptr->LAF);"
               "        scicos_free(ptr->LA);"
               "        scicos_free(ptr->LXB);"
               "        scicos_free(ptr->dwork);"
               "        scicos_free(ptr);"
               "        return;}"
               "   }"
               ""
               "else"
               "   {"
               "    ptr=*(_work);"
               "    EPS=C2F(dlamch)(""e"",1L);"
               "    ANORM=C2F(dlange)(""1"",&mu,&nu1,u1,&mu,ptr->dwork);"
               "    C2F(dlacpy)(""F"",&mu,&nu1,u1,&mu,ptr->LA,&mu);"
               "    if (mu==nu1)"
               "        {C2F(dlacpy)(""F"",&mu,&nu1,ptr->LA,&mu,ptr->LAF,&mu);"
               "         C2F(dgetrf)(&nu1,&nu1,ptr->LAF,&nu1,ptr->ipiv,&info);"
               "         rcond=0;"
               "         if (info==0)"
               "            {C2F(dgecon)(""1"",&nu1,ptr->LAF,&nu1,&ANORM,&rcond,ptr->dwork,ptr->iwork,&info);"
               "             if (rcond>pow(EPS,0.5))"
               "                {C2F(dlacpy)(""F"",&nu1,&nu2,u2,&nu1,ptr->LXB,&nu1);"
               "                 C2F(dgetrs)(""N"",&nu1,&nu2,ptr->LAF,&nu1,ptr->ipiv,ptr->LXB,&nu1,&info);"
               "                 C2F(dlacpy)(""F"",&nu1,&nu2,ptr->LXB,&nu1,y,&nu1);"
               "                 return;"
               "                }"
               "            }"
               "        }"
               "    rcond=pow(EPS,0.5);"
               "    C2F(dlacpy)(""F"",&mu,&nu2,u2,&mu,ptr->LXB,&l);"
               "    for (i=0;i<nu1;i++)    *(ptr->jpvt+i)=0;"
               "    "
               "    C2F(dgelsy1)(&mu,&nu1,&nu2,ptr->LA,&mu,ptr->LXB,&l,ptr->jpvt,&rcond,ptr->rank,ptr->dwork,&lw,&info);"
               "    if (info!=0)"
               "        {if (flag!=6)"
               "            {set_block_error(-7);"
               "             return;"
               "            }"
               "        }"
               "    C2F(dlacpy)(""F"",&nu1,&nu2,ptr->LXB,&l,y,&nu1);"
               "    }"
               "}"]

      case 'mat_cath' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "#include <stdio.h>"
               "#include <memory.h>"
               "extern void matz_cath();"
               "void mat_cath(scicos_block *block,int flag)"
               "{"
               " int mu,nu,nin,so,pointerposition,ot,i;"
               " ot=GetOutType(block,1);"
               " mu =GetInPortRows(block,1);"
               " if (ot== SCSCOMPLEX_N){"
               "   matz_cath(block,flag);"
               " } "
               " else{"
               "   void *u,*y;"
               "   y=GetOutPortPtrs(block,1);"
               "   nin=GetNin(block);"
               "   if ((flag==1) || (flag==6)) {"
               "     pointerposition=0;"
               "     for (i=0;i<nin;i++) { "
               "       u=GetInPortPtrs(block,i+1);"
               "       nu=GetInPortCols(block,i+1);"
               "       so=GetSizeOfIn(block,i+1);"
               "       memcpy(y+pointerposition,u,mu*nu*so);"
               "       pointerposition=pointerposition+mu*nu*so;"
               "     }"
               "   }"
               " }"
               "}"
               ""
               ""]

      case 'mat_catv' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "#include <stdio.h>"
               "#include <memory.h>"
               "extern void matz_catv();"
               "void mat_catv(scicos_block *block,int flag)"
               "{"
               "  int mu,nu,nin,so,pointerposition,ot,i,j;"
               " ot=GetOutType(block,1);"
               " nu =GetInPortCols(block,1);"
               " if (ot== SCSCOMPLEX_N){"
               "   matz_catv(block,flag);"
               " } "
               " else{"
               "   void *u,*y;"
               "   y=GetOutPortPtrs(block,1);"
               "   nin=GetNin(block);"
               "   if ((flag==1) || (flag==6)) {"
               "     pointerposition=0;"
               "     for (j=0;j<nu;j++) {"
               "       for (i=0;i<nin;i++) { "
               "         u=GetInPortPtrs(block,i+1);"
               "         mu=GetInPortRows(block,i+1);"
               "         so=GetSizeOfIn(block,i+1);"
               "         memcpy(y+pointerposition,u+j*mu*so,mu*so);"
               "         pointerposition=pointerposition+mu*so;"
               "       }"
               "     }"
               "   }"
               " }"
               "}"
               ""]

      case 'mat_det' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "#include <stdio.h>"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "extern int C2F(dgetrf)();"
               "typedef struct"
               "{         int *ipiv;"
               "          double *wrk;"
               "} mat_det_struct ;"
               "void mat_det(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               " double *u;"
               " double *y;"
               " int nu;"
               " int info;"
               " int i;"
               " double D,l;"
               " mat_det_struct *mdet;"
               " "
               " nu =GetInPortRows(block,1);"
               " u=GetRealInPortPtrs(block,1);"
               " y=GetRealOutPortPtrs(block,1);"
               ""
               "             /*init : initialization*/"
               "if (flag==4)"
               ""
               "   {if((*(_work)=(mat_det_struct*) scicos_malloc(sizeof(mat_det_struct)))==NULL)"
               "        {set_block_error(-16);"
               "         return;}"
               "    mdet=*(_work);"
               "    if((mdet->ipiv=(int*) scicos_malloc(sizeof(int)*nu))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(mdet);"
               "         return;}"
               "    if((mdet->wrk=(double*) scicos_malloc(sizeof(double)*(nu*nu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(mdet->ipiv);"
               "         scicos_free(mdet);"
               "         return;}"
               "    }"
               ""
               "       /* Terminaison */"
               "else if (flag==5)"
               "   {mdet=*(_work);"
               "    if(mdet->wrk!=NULL) {"
               "        scicos_free(mdet->ipiv);"
               "        scicos_free(mdet->wrk);"
               "        scicos_free(mdet);"
               "        return;}"
               "   }"
               ""
               "else"
               "   {"
               "    mdet=*(_work);"
               "    for (i=0;i<(nu*nu);i++)   mdet->wrk[i]=u[i];"
               "     C2F(dgetrf)(&nu,&nu,mdet->wrk,&nu,mdet->ipiv,&info);"
               "    if (info <0)"
               "       {if (flag!=6)"
               "        {set_block_error(-7);"
               "        return;}}"
               "      D=1;"
               "    for (i=0;i<nu;i++)"
               "       {if((*(mdet->ipiv+i))!=i+1) D=-D;"
               "        l=*(mdet->wrk+i*(nu+1));"
               "        D=D*l;"
               "        };"
               "     *y=D;"
               "    }"
               " }"]

      case 'mat_diag' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "void mat_diag(scicos_block *block,int flag)"
               "{"
               "  double *u1;"
               "  double *y;"
               ""
               "  int mu,i,ii;"
               ""
               "  mu=GetInPortRows(block,1);"
               ""
               "  u1=GetRealInPortPtrs(block,1);"
               "  y=GetRealOutPortPtrs(block,1);"
               "  for (i=0;i<mu*mu;i++) *(y+i)=0;"
               "  for (i=0;i<mu;i++)     "
               "        {ii=i+i*mu;"
               "         *(y+ii)=*(u1+i);}"
               "}"]

      case 'mat_div' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "#include <stdio.h>"
               "#include <math.h>"
               "extern int C2F(dgetrf)();"
               "extern double C2F(dlamch)();"
               "extern double C2F(dlange)();"
               "extern int C2F(dlacpy)();"
               "extern int C2F(dgecon)();"
               "extern int C2F(dgetrs)();"
               "extern int C2F(dgelsy1)();"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "#ifndef min"
               "#define min(a,b) ((a) <= (b) ? (a) : (b))"
               "#endif"
               ""
               "#ifndef max"
               "#define max(a,b) ((a) >= (b) ? (a) : (b))"
               "#endif"
               ""
               "typedef struct"
               "{         int *ipiv;"
               "          int *rank;"
               "          int *jpvt;"
               "          int *iwork;"
               "          double *dwork;"
               "          double *LAF;"
               "          double *LBT;"
               "          double *LAT;"
               "} mat_div_struct ;"
               "void mat_div(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               " double *u1;"
               " double *u2;"
               " double *y;"
               " int mu1,mu2;"
               " int nu,nu2;"
               " int info;"
               " int i,j,l,lw,lu,ij,ji;"
               " mat_div_struct *ptr;"
               " double rcond, ANORM, EPS;"
               ""
               " mu2 =GetInPortRows(block,1);"
               " nu =GetInPortCols(block,1);"
               " mu1 =GetInPortRows(block,2);"
               " nu2 =GetInPortCols(block,2);"
               " u2=GetRealInPortPtrs(block,1);"
               " u1=GetRealInPortPtrs(block,2);"
               " y=GetRealOutPortPtrs(block,1);"
               " l=max(mu1,nu);"
               " lu=max(4*nu,min(mu1,nu)+3*mu1+1);"
               " lw=max(lu,2*min(mu1,nu)+mu2);"
               "             /*init : initialization*/"
               "if (flag==4)"
               "   {if((*(_work)=(mat_div_struct*) scicos_malloc(sizeof(mat_div_struct)))==NULL)"
               "        {set_block_error(-16);"
               "         return;}"
               "    ptr=*(_work);"
               "    if((ptr->ipiv=(int*) scicos_malloc(sizeof(int)*nu))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->rank=(int*) scicos_malloc(sizeof(int)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->jpvt=(int*) scicos_malloc(sizeof(int)*mu1))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->rank);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->iwork=(int*) scicos_malloc(sizeof(int)*nu))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->jpvt);"
               "         scicos_free(ptr->rank);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->dwork=(double*) scicos_malloc(sizeof(double)*lw))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->jpvt);"
               "         scicos_free(ptr->rank);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LAF=(double*) scicos_malloc(sizeof(double)*(nu*mu1)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->jpvt);"
               "         scicos_free(ptr->rank);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LBT=(double*) scicos_malloc(sizeof(double)*(l*mu2)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LAF);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->jpvt);"
               "         scicos_free(ptr->rank);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LAT=(double*) scicos_malloc(sizeof(double)*(nu*mu1)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LBT);"
               "         scicos_free(ptr->LAF);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->jpvt);"
               "         scicos_free(ptr->rank);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "   }"
               ""
               "       /* Terminaison */"
               "else if (flag==5)"
               "   {ptr=*(_work);"
               "    if((ptr->LAT)!=NULL) {"
               "        scicos_free(ptr->ipiv);"
               "        scicos_free(ptr->rank);"
               "        scicos_free(ptr->jpvt);"
               "        scicos_free(ptr->iwork);"
               "        scicos_free(ptr->LAF);"
               "        scicos_free(ptr->LBT);"
               "        scicos_free(ptr->LAT);"
               "        scicos_free(ptr->dwork);"
               "        scicos_free(ptr);"
               "        return;}"
               "   }"
               ""
               "else"
               "   {"
               "    ptr=*(_work);"
               "    EPS=C2F(dlamch)(""e"",1L);"
               "    ANORM=C2F(dlange)(""l"",&mu1,&nu,u1,&mu1,ptr->dwork);"
               "    for (j=0;j<mu1;j++)"
               "        {for (i=0;i<nu;i++)"
               "                {ij=i+j*nu;"
               "                 ji=j+i*mu1;"
               "                 *(ptr->LAT+ij)=*(u1+ji);}"
               "        }"
               "     for (j=0;j<mu2;j++)"
               "        {for (i=0;i<nu;i++)"
               "                {ij=i+j*l;"
               "                 ji=j+i*mu2;"
               "                 *(ptr->LBT+ij)=*(u2+ji);}"
               "        }"
               "     if (mu1==nu)"
               "        {C2F(dlacpy)(""F"",&nu,&nu,ptr->LAT,&nu,ptr->LAF,&nu);"
               "         C2F(dgetrf)(&nu,&nu,ptr->LAF,&nu,ptr->ipiv,&info);"
               "         rcond=0;"
               "         if (info==0)"
               "            {C2F(dgecon)(""1"",&nu,ptr->LAF,&nu,&ANORM,&rcond,ptr->dwork,ptr->iwork,&info);"
               "             if (rcond>pow(EPS,0.5))"
               "                {C2F(dgetrs)(""N"",&nu,&mu2,ptr->LAF,&nu,ptr->ipiv,ptr->LBT,&nu,&info);"
               "                for (j=0;j<nu;j++)"
               "                {for (i=0;i<mu2;i++)"
               "                        {ij=i+j*mu2;"
               "                        ji=j+i*nu;"
               "                        *(y+ij)=*(ptr->LBT+ji);}"
               "                }"
               "                 return;"
               "                }"
               "            }"
               "        }"
               "    rcond=pow(EPS,0.5);"
               "    for (i=0;i<mu1;i++)    *(ptr->jpvt+i)=0;"
               "    C2F(dgelsy1)(&nu,&mu1,&mu2,ptr->LAT,&nu,ptr->LBT,&l,ptr->jpvt,&rcond,ptr->rank,ptr->dwork,&lw,&info);"
               "    if (info!=0)"
               "        {if (flag!=6)"
               "            {set_block_error(-7);"
               "             return;"
               "            }"
               "        }"
               "    for (j=0;j<mu1;j++)"
               "        {for (i=0;i<mu2;i++)"
               "                {ij=i+j*mu2;"
               "                ji=j+i*l;"
               "                *(y+ij)=*(ptr->LBT+ji);}"
               "        }"
               "    }"
               "}"]

      case 'mat_expm' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "#include <stdio.h>"
               "#include <math.h>"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               ""
               "extern int C2F(dexpm1)();"
               "typedef struct"
               "{         int *iwork;"
               "          double *dwork;"
               "} mat_exp_struct ;"
               "void mat_expm(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               " double *u;"
               " double *y;"
               " int nu;"
               " int ierr;"
               " mat_exp_struct *ptr;"
               ""
               " nu =GetInPortCols(block,1);"
               " u=GetRealInPortPtrs(block,1);"
               " y=GetRealOutPortPtrs(block,1);"
               ""
               "             /*init : initialization*/"
               "if (flag==4)"
               "   {if((*(_work)=(mat_exp_struct*) scicos_malloc(sizeof(mat_exp_struct)))==NULL)"
               "        {set_block_error(-16);"
               "         return;}"
               "    ptr=*(_work);"
               "    if((ptr->iwork=(int*) scicos_malloc(sizeof(int)*(2*nu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->dwork=(double*) scicos_malloc(sizeof(double)*(nu*(2*nu+2*nu+5))))== NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr);"
               "         return;}"
               "   }"
               ""
               "       /* Terminaison */"
               "else if (flag==5)"
               "   {ptr=*(_work);"
               "    if (ptr->dwork!=NULL){"
               "        scicos_free(ptr->iwork);"
               "        scicos_free(ptr->dwork);"
               "        scicos_free(ptr);"
               "        return;}"
               "   }"
               ""
               "else"
               "   {ptr=*(_work);"
               "    C2F(dexpm1)(&nu,&nu,u,y,&nu,ptr->dwork,ptr->iwork,&ierr);"
               "    if (ierr!=0)"
               "        {if (flag!=6)"
               "        {set_block_error(-7);"
               "        return;}"
               "        }"
               "   }"
               "}"]

      case 'mat_inv' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "#include <stdio.h>"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "extern int C2F(dgetrf)();"
               "extern int C2F(dgetri)();"
               "typedef struct"
               "{         int *ipiv;"
               "          double *dwork;"
               "} mat_inv_struct ;"
               "void mat_inv(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               " double *u;"
               " double *y;"
               " int nu;"
               " int info;"
               " int i;"
               " mat_inv_struct *ptr;"
               " "
               " nu =GetInPortRows(block,1);"
               " u=GetRealInPortPtrs(block,1);"
               " y=GetRealOutPortPtrs(block,1);"
               ""
               "             /*init : initialization*/"
               "if (flag==4)"
               "   {if((*(_work)=(mat_inv_struct*) scicos_malloc(sizeof(mat_inv_struct)))==NULL)"
               "        {set_block_error(-16);"
               "         return;}"
               "    ptr=*(_work);"
               "    if((ptr->ipiv=(int*) scicos_malloc(sizeof(int)*nu))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->dwork=(double*) scicos_malloc(sizeof(double)*nu))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "   }"
               ""
               "       /* Terminaison */"
               "else if (flag==5)"
               "   {ptr=*(_work);"
               "    if ((ptr->dwork)!=NULL){"
               "        scicos_free(ptr->ipiv);"
               "        scicos_free(ptr->dwork);"
               "        scicos_free(ptr);"
               "        return;}"
               "   }"
               ""
               "else"
               "   {"
               "    ptr=*(_work);"
               "    for (i=0;i<(nu*nu);i++)   { y[i]=u[i];}"
               "    C2F(dgetrf)(&nu,&nu,&y[0],&nu,ptr->ipiv,&info);"
               "    if (info !=0)"
               "       {if (flag!=6)"
               "        {set_block_error(-7);"
               "        return;}}"
               "    C2F (dgetri)(&nu,y,&nu,ptr->ipiv,ptr->dwork,&nu,&info);"
               "    "
               "   }"
               "}"]

      case 'mat_lu' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "#include <stdio.h>"
               "extern int C2F(dgetrf)();"
               "extern int C2F(dlaswp)();"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "#ifndef min"
               "#define min(a,b) ((a) <= (b) ? (a) : (b))"
               "#endif"
               ""
               "#ifndef max"
               "#define max(a,b) ((a) >= (b) ? (a) : (b))"
               "#endif"
               ""
               "typedef struct"
               "{         int *ipiv;"
               "          double *dwork;"
               "          double *IL;"
               "          double *IU;"
               "} mat_lu_struct ;"
               "void mat_lu(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               " double *u;"
               " double *y1;"
               " double *y2;"
               " int mu;"
               " int nu;"
               " int info;"
               " int i,j,l,ij,ik;"
               " mat_lu_struct *ptr;"
               " "
               " mu =GetInPortRows(block,1);"
               " nu =GetInPortCols(block,1);"
               " u=GetRealInPortPtrs(block,1);"
               " y1=GetRealOutPortPtrs(block,1);"
               " y2=GetRealOutPortPtrs(block,2);"
               " l=min(mu,nu);"
               "             /*init : initialization*/"
               "if (flag==4)"
               "   {if((*(_work)=(mat_lu_struct*) scicos_malloc(sizeof(mat_lu_struct)))==NULL)"
               "        {set_block_error(-16);"
               "         return;}"
               "    ptr=*(_work);"
               "    if((ptr->ipiv=(int*) scicos_malloc(sizeof(int)*nu))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->dwork=(double*) scicos_malloc(sizeof(double)*(mu*nu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->IL=(double*) scicos_malloc(sizeof(double)*(mu*l)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->IU=(double*) scicos_malloc(sizeof(double)*(l*nu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->IL);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->ipiv);"
               "         scicos_free(ptr);"
               "         return;}"
               "   }"
               ""
               "       /* Terminaison */"
               "else if (flag==5)"
               "   {ptr=*(_work);"
               "    if((ptr->IU)!=NULL){"
               "        scicos_free(ptr->ipiv);"
               "        scicos_free(ptr->dwork);"
               "        scicos_free(ptr->IL);"
               "        scicos_free(ptr->IU);"
               "        scicos_free(ptr);"
               "        return;}"
               "   }"
               ""
               "else"
               "   {"
               "    ptr=*(_work);"
               "    for (i=0;i<(mu*nu);i++)   { ptr->dwork[i]=u[i];}"
               "    C2F(dgetrf)(&mu,&nu,ptr->dwork,&mu,ptr->ipiv,&info);"
               "    if (info !=0)"
               "       {if (flag!=6)"
               "        {set_block_error(-7);"
               "        return;}}"
               "   for (j=0;j<l;j++)"
               "        {for (i=0;i<mu;i++)"
               "             {ij=i+j*mu;"
               "              if (i==j)"
               "                {*(y2+ij)=1;}"
               "              else if (i>j)"
               "                {*(y2+ij)=*(ptr->dwork+ij);}"
               "              else "
               "                {*(y2+ij)=0;}"
               "              }"
               "        }"
               "        for (j=0;j<nu;j++)"
               "        {for (i=0;i<l;i++)"
               "             {ij=i+j*l;"
               "              ik=i+j*mu;"
               "              if (i<=j)"
               "                {*(y1+ij)=*(ptr->dwork+ik);}"
               "              else"
               "                {*(y1+ij)=0;}"
               "              }"
               "        }"
               "   }"
               "}"]

      case 'mat_pinv' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "#include <stdio.h>"
               "extern int C2F(dgesvd)();"
               "extern int C2F(dlaset)();"
               "extern int C2F(dlacpy)();"
               "extern int C2F(dmmul)();"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "#ifndef min"
               "#define min(a,b) ((a) <= (b) ? (a) : (b))"
               "#endif"
               ""
               "#ifndef max"
               "#define max(a,b) ((a) >= (b) ? (a) : (b))"
               "#endif"
               ""
               "typedef struct"
               "{         double *l0;"
               "          double *LA;"
               "          double *LC;"
               "          double *LS;"
               "          double *LSV;"
               "          double *LSW;"
               "          double *LU;"
               "          double *LUT;"
               "          double *LV;"
               "          double *LVT;"
               "          double *dwork;"
               "} mat_pinv_struct ;"
               "void mat_pinv(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               " double *u;"
               " double *y;"
               " int nu,mu;"
               " int info;"
               " int i,j,ij,ji,ii,lwork;"
               " mat_pinv_struct *ptr;"
               " mu=GetInPortRows(block,1);"
               " nu=GetInPortCols(block,1);"
               " u=GetRealInPortPtrs(block,1);"
               " y=GetRealOutPortPtrs(block,1);"
               " /* for lapack 2.0 (1994) "
               " lwork=max(3*min(mu,nu)+max(mu,nu),5*min(mu,nu)-4);*/"
               " /* for lapack 3.1 (2006)*/"
               " lwork=max(3*min(mu,nu)+max(mu,nu),5*min(mu,nu));"
               " lwork=max(1,lwork); "
               "             /*init : initialization*/"
               "if (flag==4)"
               "   {if((*(_work)=(mat_pinv_struct*) scicos_malloc(sizeof(mat_pinv_struct)))==NULL)"
               "        {set_block_error(-16);"
               "         return;}"
               "    ptr=*(_work);"
               "    if((ptr->l0=(double*) scicos_malloc(sizeof(double)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LA=(double*) scicos_malloc(sizeof(double)*(mu*nu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->l0);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LC=(double*) scicos_malloc(sizeof(double)*(nu*mu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr->l0);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LS=(double*) scicos_malloc(sizeof(double)*(nu*mu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LC);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr->l0);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LSV=(double*) scicos_malloc(sizeof(double)*(min(mu,nu))))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LS);"
               "         scicos_free(ptr->LC);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr->l0);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LSW=(double*) scicos_malloc(sizeof(double)*(min(mu,nu))))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LSV);"
               "         scicos_free(ptr->LS);"
               "         scicos_free(ptr->LC);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr->l0);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LU=(double*) scicos_malloc(sizeof(double)*(mu*mu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LSW);"
               "         scicos_free(ptr->LSV);"
               "         scicos_free(ptr->LS);"
               "         scicos_free(ptr->LC);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr->l0);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LUT=(double*) scicos_malloc(sizeof(double)*(mu*mu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LU);"
               "         scicos_free(ptr->LSW);"
               "         scicos_free(ptr->LSV);"
               "         scicos_free(ptr->LS);"
               "         scicos_free(ptr->LC);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr->l0);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LV=(double*) scicos_malloc(sizeof(double)*(nu*nu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LUT);"
               "         scicos_free(ptr->LU);"
               "         scicos_free(ptr->LSW);"
               "         scicos_free(ptr->LSV);"
               "         scicos_free(ptr->LS);"
               "         scicos_free(ptr->LC);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr->l0);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LVT=(double*) scicos_malloc(sizeof(double)*(nu*nu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LV);"
               "         scicos_free(ptr->LUT);"
               "         scicos_free(ptr->LU);"
               "         scicos_free(ptr->LSW);"
               "         scicos_free(ptr->LSV);"
               "         scicos_free(ptr->LS);"
               "         scicos_free(ptr->LC);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr->l0);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->dwork=(double*) scicos_malloc(sizeof(double)*lwork))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LVT);"
               "         scicos_free(ptr->LV);"
               "         scicos_free(ptr->LUT);"
               "         scicos_free(ptr->LU);"
               "         scicos_free(ptr->LSW);"
               "         scicos_free(ptr->LSV);"
               "         scicos_free(ptr->LS);"
               "         scicos_free(ptr->LC);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr->l0);"
               "         scicos_free(ptr);"
               "         return;}"
               "   }"
               ""
               "       /* Terminaison */"
               "else if (flag==5)"
               "   {ptr=*(_work);"
               "    if((ptr->dwork)!=0){"
               "        scicos_free(ptr->LC);"
               "        scicos_free(ptr->l0);"
               "        scicos_free(ptr->LA);"
               "        scicos_free(ptr->LSW);"
               "        scicos_free(ptr->LS);"
               "        scicos_free(ptr->LSV);"
               "        scicos_free(ptr->LU);"
               "        scicos_free(ptr->LUT);"
               "        scicos_free(ptr->LV);"
               "        scicos_free(ptr->LVT);"
               "        scicos_free(ptr->dwork);"
               "        scicos_free(ptr);"
               "        return;}"
               "   }"
               ""
               "else"
               "   {"
               "    ptr=*(_work);"
               "    for(i=0;i<mu*nu;i++) y[i]=0;"
               "    C2F(dlacpy)(""F"",&mu,&nu,u,&mu,ptr->LA,&mu);"
               "    C2F(dgesvd)(""A"",""A"",&mu,&nu,ptr->LA,&mu,ptr->LSV,ptr->LU,&mu,ptr->LVT,&nu,ptr->dwork,&lwork,&info);"
               "     if (info !=0)"
               "       {if (flag!=6)"
               "        {set_block_error(-7);"
               "        return;}}"
               "    for (i=0;i<min(mu,nu);i++)  "
               "         {if (*(ptr->LSV+i)!=0)"
               "              {*(ptr->LSW+i)=1/(*(ptr->LSV+i));}"
               "         else "
               "              {*(ptr->LSW+i)=0;}}"
               "    *(ptr->l0)=0;"
               "     C2F(dlaset)(""F"",&nu,&mu,ptr->l0,ptr->l0,ptr->LS,&nu);"
               "    for (i=0;i<min(mu,nu);i++)"
               "        {ii=i+i*nu;"
               "         *(ptr->LS+ii)=*(ptr->LSW+i);}"
               "    for (j=0;j<mu;j++)"
               "        {for (i=j;i<mu;i++)"
               "                {ij=i+j*mu;"
               "                 ji=j+i*mu;"
               "                 *(ptr->LUT+ij)=*(ptr->LU+ji);"
               "                 *(ptr->LUT+ji)=*(ptr->LU+ij);}"
               "        }"
               "    for (j=0;j<nu;j++)"
               "        {for (i=j;i<nu;i++)"
               "                {ij=i+j*nu;"
               "                 ji=j+i*nu;"
               "                 *(ptr->LV+ij)=*(ptr->LVT+ji);"
               "                 *(ptr->LV+ji)=*(ptr->LVT+ij);}"
               "        }"
               "      C2F(dmmul)(ptr->LV,&nu,ptr->LS,&nu,ptr->LC,&nu,&nu,&nu,&mu);"
               "      C2F(dmmul)(ptr->LC,&nu,ptr->LUT,&mu,y,&nu,&nu,&mu,&mu);"
               "   }"
               "}"]

      case 'mat_reshape' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "void mat_reshape(scicos_block *block,int flag)"
               "{"
               "  double *u1;"
               "  double *y;"
               ""
               "  int i,xu,vu;"
               ""
               "  xu=GetOutPortRows(block,1);"
               "  vu=GetOutPortCols(block,1);"
               "  u1=GetRealInPortPtrs(block,1);"
               "  y=GetRealOutPortPtrs(block,1);"
               ""
               "  for (i=0;i<xu*vu;i++) *(y+i)=*(u1+i);"
               "}"]

      case 'mat_sing' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "#include <stdio.h>"
               "extern int C2F(dgesvd)();"
               "extern int C2F(dlaset)();"
               "extern int C2F(dlacpy)();"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "#ifndef min"
               "#define min(a,b) ((a) <= (b) ? (a) : (b))"
               "#endif"
               ""
               "#ifndef max"
               "#define max(a,b) ((a) >= (b) ? (a) : (b))"
               "#endif"
               ""
               "typedef struct"
               "{         double *LA;"
               "          double *LU;"
               "          double *LVT;"
               "          double *dwork;"
               "} mat_sing_struct ;"
               "void mat_sing(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               " double *u;"
               " double *y;"
               " int nu,mu;"
               " int info;"
               " int lwork;"
               " mat_sing_struct *ptr;"
               " mu=GetInPortRows(block,1);"
               " nu=GetInPortCols(block,1);"
               " u=GetRealInPortPtrs(block,1);"
               " y=GetRealOutPortPtrs(block,1);"
               " /* for lapack 2.0 (1994) "
               " lwork=max(3*min(mu,nu)+max(mu,nu),5*min(mu,nu)-4);*/"
               " /* for lapack 3.1 (2006)*/"
               " lwork=max(3*min(mu,nu)+max(mu,nu),5*min(mu,nu));"
               " lwork=max(1,lwork); "
               " "
               "             /*init : initialization*/"
               "if (flag==4)"
               "   {if((*(_work)=(mat_sing_struct*) scicos_malloc(sizeof(mat_sing_struct)))==NULL)"
               "        {set_block_error(-16);"
               "         return;}"
               "    ptr=*(_work);"
               "    if((ptr->LA=(double*) scicos_malloc(sizeof(double)*(mu*nu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LU=(double*) scicos_malloc(sizeof(double)*(mu*mu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LVT=(double*) scicos_malloc(sizeof(double)*(nu*nu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LU);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->dwork=(double*) scicos_malloc(sizeof(double)*lwork))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LVT);"
               "         scicos_free(ptr->LU);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr);"
               "         return;}"
               "   }"
               ""
               "       /* Terminaison */"
               "else if (flag==5)"
               "   {ptr=*(_work);"
               "    if(ptr->dwork!=0) {"
               "        scicos_free(ptr->LA);"
               "        scicos_free(ptr->LU);"
               "        scicos_free(ptr->LVT);"
               "        scicos_free(ptr->dwork);"
               "        scicos_free(ptr);"
               "        return;}"
               "   }"
               ""
               "else"
               "   {"
               "    ptr=*(_work);"
               "    C2F(dlacpy)(""F"",&mu,&nu,u,&mu,ptr->LA,&mu);"
               "    C2F(dgesvd)(""A"",""A"",&mu,&nu,ptr->LA,&mu,y,ptr->LU,&mu,ptr->LVT,&nu,ptr->dwork,&lwork,&info);"
               "     if (info !=0)"
               "       {if (flag!=6)"
               "        {set_block_error(-7);"
               "         return;}}"
               "   }"
               "}"]

      case 'mat_sqrt' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void mat_sqrt(scicos_block *block,int flag)"
               "{"
               "  double *u;"
               "  double *y;"
               ""
               "  int nu,mu,i;"
               ""
               "  mu=GetInPortRows(block,1);"
               "  nu=GetInPortCols(block,1);"
               ""
               "  u=GetRealInPortPtrs(block,1);"
               "  y=GetRealOutPortPtrs(block,1);"
               ""
               "  for(i=0;i<mu*nu;i++)  y[i]=pow(u[i],0.5);"
               ""
               "}"]

      case 'mat_sum' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "void mat_sum(scicos_block *block,int flag)"
               "{"
               "  double *u;"
               "  double *y;"
               "  int nu,mu,i;"
               "  mu=GetInPortRows(block,1);"
               "  nu=GetInPortCols(block,1);"
               ""
               "  u=GetRealInPortPtrs(block,1);"
               "  y=GetRealOutPortPtrs(block,1);"
               "  "
               "  y[0]=0.0;"
               "  for(i=0;i<nu*mu;i++)"
               "       {y[0]=u[i]+y[0];}"
               "}"]

      case 'mat_vps' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "#include <stdio.h>"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "extern int C2F(dlacpy)();"
               "extern int C2F(dgeev)();"
               "extern int C2F(zlaset)();"
               "extern int C2F(issymmetric)();"
               "extern int C2F(dsyev)();"
               "typedef struct"
               "{         double *LA;"
               "          double *LVR;"
               "          double *dwork;"
               "          double *dwork1;"
               "} mat_vps_struct ;"
               "void mat_vps(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               " double *u;"
               " double *y1;"
               " double *y2;"
               " int nu;"
               " int info;"
               " int i,lwork,lwork1,j,ij,ji;"
               " int symmetric;"
               " mat_vps_struct *ptr;"
               " "
               " nu =GetInPortRows(block,1);"
               " u=GetRealInPortPtrs(block,1);"
               " y1=GetRealOutPortPtrs(block,1);"
               " y2=GetImagOutPortPtrs(block,1);"
               " lwork1=3*nu;"
               " lwork=3*nu-1;"
               "             /*init : initialization*/"
               "if (flag==4)"
               "   {if((*(_work)=(mat_vps_struct*) scicos_malloc(sizeof(mat_vps_struct)))==NULL)"
               "        {set_block_error(-16);"
               "         return;}"
               "    ptr=*(_work);"
               "    if((ptr->LA=(double*) scicos_malloc(sizeof(double)*(nu*nu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LVR=(double*) scicos_malloc(sizeof(double)*(nu*nu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->dwork=(double*) scicos_malloc(sizeof(double)*lwork))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LVR);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->dwork1=(double*) scicos_malloc(sizeof(double)*lwork1))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->LVR);"
               "         scicos_free(ptr->LA);"
               "         scicos_free(ptr);"
               "         return;}"
               "   }"
               ""
               "       /* Terminaison */"
               "else if (flag==5)"
               "   {ptr=*(_work);"
               "    if((ptr->dwork1)!=NULL){"
               "        scicos_free(ptr->LA);"
               "        scicos_free(ptr->LVR);"
               "        scicos_free(ptr->dwork);"
               "        scicos_free(ptr->dwork1);"
               "        scicos_free(ptr);"
               "        return;}"
               "   }"
               ""
               "else"
               "   {"
               "    ptr=*(_work);"
               "    C2F(dlacpy)(""F"",&nu,&nu,u,&nu,ptr->LA,&nu);"
               "   symmetric=1;"
               "    for (j=0;j<nu;j++)"
               "        {for (i=j;i<nu;i++)"
               "                {ij=i+j*nu;"
               "                 ji=j+i*nu;"
               "                if (i!=j)"
               "                        {if (*(ptr->LA+ij)==*(ptr->LA+ji)) symmetric*= 1;"
               "                         else { symmetric*=0;break;}}}}"
               "    if (symmetric==1)"
               "        {C2F(dsyev)(""N"",""U"",&nu,ptr->LA,&nu,y1,ptr->dwork,&lwork,&info);"
               "         if (info!=0)"
               "                {if (flag!=6)"
               "                {set_block_error(-7);"
               "                return;"
               "                }}"
               "        }"
               "   else"
               "        {C2F(dgeev)(""N"",""N"",&nu,ptr->LA,&nu,y1,y2,ptr->dwork1,&nu,ptr->LVR,&nu,ptr->dwork1,&lwork1,&info);"
               "        if (info!=0)"
               "                {if (flag!=6)"
               "                {set_block_error(-7);"
               "                return;"
               "                }}"
               "        }"
               "   }"
               "}"]

      case 'matmul_m' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "extern int C2F(dmmul)();"
               "extern int C2F(dmmul1)();"
               ""
               "void matmul_m(scicos_block *block,int flag)"
               "{"
               "  double *u1;"
               "  double *u2;"
               "  double *y;"
               ""
               "  int nu,nu2,mu2;"
               ""
               "  nu=GetInPortRows(block,1);"
               "  nu2=GetInPortRows(block,2);"
               "  mu2=GetInPortCols(block,2);"
               ""
               "  u1=GetRealInPortPtrs(block,1);"
               "  u2=GetRealInPortPtrs(block,2);"
               "  y=GetRealOutPortPtrs(block,1);"
               ""
               "  C2F(dmmul)(u1,&nu,u2,&nu2,y,&nu,&nu,&nu2,&mu2);"
               "}"]

      case 'mattran_m' then
        txt = ["#include ""machine.h"""
               "#include ""scicos_block4.h"""
               ""
               "extern int C2F(mtran)();"
               ""
               "void mattran_m(scicos_block *block,int flag)"
               "{"
               "  double *u;"
               "  double *y;"
               "  int nu,mu;"
               ""
               "  nu=GetInPortRows(block,1);"
               "  mu=GetInPortCols(block,1);"
               ""
               "  u=GetRealInPortPtrs(block,1);"
               "  y=GetRealOutPortPtrs(block,1);"
               ""
               "  C2F(mtran)(u,&nu,y,&mu,&nu,&mu);"
               "}"]

      case 'matz_abs' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               "#include <math.h>"
               "void matz_abs(scicos_block *block,int flag)"
               "{"
               "  double *u1r;"
               "  double *u1i;"
               "  double *y1,*y2;"
               ""
               "  int nu,mu,i;"
               ""
               "  mu=GetOutPortRows(block,1);"
               "  nu=GetOutPortCols(block,1);"
               "  u1r=GetRealInPortPtrs(block,1);"
               "  u1i=GetImagInPortPtrs(block,1);"
               "  y1=GetRealOutPortPtrs(block,1);"
               "  y2=GetRealOutPortPtrs(block,2);"
               "  for (i=0;i<mu*nu;i++) "
               "        {*(y1+i)=pow((pow(*(u1r+i),2)+pow(*(u1i+i),2)),0.5);"
               "         *(y2+i)=atan2(*(u1i+i),*(u1r+i));}"
               "}"
               ""]

      case 'matz_conj' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "void matz_conj(scicos_block *block,int flag)"
               "{"
               "  double *u1r;"
               "  double *u1i;"
               "  double *yr;"
               "  double *yi;"
               ""
               "  int nu,mu,i;"
               ""
               "  mu=GetOutPortRows(block,1);"
               "  nu=GetOutPortCols(block,1);"
               "  u1r=GetRealInPortPtrs(block,1);"
               "  u1i=GetImagInPortPtrs(block,1);"
               "  yr=GetRealOutPortPtrs(block,1);"
               "  yi=GetImagOutPortPtrs(block,1);"
               "  "
               "  for (i=0;i<mu*nu;i++) "
               "        {*(yr+i)=*(u1r+i);"
               "         *(yi+i)=-(*(u1i+i));}"
               "}"
               ""]

      case 'matz_reim' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "void matz_reim(scicos_block *block,int flag)"
               "{"
               "  double *u1r;"
               "  double *u1i;"
               "  double *y1;"
               "  double *y2;"
               ""
               "  int nu,mu,i;"
               ""
               "  mu=GetOutPortRows(block,1);"
               "  nu=GetOutPortCols(block,1);"
               "  u1r=GetRealInPortPtrs(block,1);"
               "  u1i=GetImagInPortPtrs(block,1);"
               "  y1=GetRealOutPortPtrs(block,1);"
               "  y2=GetRealOutPortPtrs(block,2);"
               "  "
               "  for (i=0;i<mu*nu;i++) "
               "        {*(y1+i)=*(u1r+i);"
               "         *(y2+i)=*(u1i+i);}"
               "}"
               ""]

      case 'minmax' then
        txt = ["#include <math.h>"
               "#include ""scicos_block4.h"""
               ""
               "#ifndef min"
               "#define min(a,b) ((a) <= (b) ? (a) : (b))"
               "#endif"
               ""
               "#ifndef max"
               "#define max(a,b) ((a) >= (b) ? (a) : (b))"
               "#endif"
               ""
               "void minmax(scicos_block *block,int flag)"
               "{ /*ipar[0]=1 -> min,  ipar[0]=2 -> max */"
               "  int *_ipar=GetIparPtrs(block);"
               "  int _nin=GetNin(block);"
               "  int _ng=GetNg(block);"
               "  double *_g=GetGPtrs(block);"
               "  int *_mode=GetModePtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double *_u2=GetRealInPortPtrs(block,2);"
               "  double *uytmp;"
               "  "
               "  int i,phase;"
               "  double maxmin;"
               "  phase=get_phase_simulation();"
               "  if (flag == 1) {"
               "    if(_nin==1){"
               "      if((_ng==0)||(phase==1)){"
               "        maxmin=_u1[0];"
               "        for (i=1;i<GetInPortRows(block,1);++i){"
               "          if(_ipar[0]==1){"
               "            if(_u1[i]<maxmin)  maxmin=_u1[i];"
               "          } else {"
               "            if(_u1[i]>maxmin)  maxmin=_u1[i];"
               "          }"
               "        }"
               "      }else{"
               "        maxmin=_u1[_mode[0]-1];"
               "      }"
               "      _y1[0]=maxmin;"
               ""
               "    }else if (_nin==2){"
               "      for (i=0;i<GetInPortRows(block,1);++i){"
               "        if((_ng==0)||(phase==1)){"
               "          if(_ipar[0]==1){"
               "            _y1[i]=min(_u1[i],_u2[i]);"
               "          } else {"
               "            _y1[i]=max(_u1[i],_u2[i]);"
               "          }"
               "        }else{"
               "          uytmp=GetRealInPortPtrs(block,_mode[0]-1+1);"
               "          _y1[i]=uytmp[i];"
               "        }"
               "      }"
               "    }"
               "  } else if(flag == 9){"
               "    if(_nin==1){"
               ""
               "      if (phase==2){"
               "        for (i=0;i<GetInPortRows(block,1);++i){"
               "          if(i!=_mode[0]-1){"
               "            _g[i]=_u1[i]-_u1[_mode[0]-1];"
               "          }else{"
               "            _g[i]=1.0;"
               "          }"
               "        }"
               "      } else if (phase==1){"
               "        maxmin=_u1[0];"
               "        _mode[0]=1;"
               "        for (i=1;i<GetInPortRows(block,1);++i){"
               "          if(_ipar[0]==1){"
               "            if(_u1[i]<maxmin) {"
               "              maxmin=_u1[i];"
               "              _mode[0]=i+1;"
               "            }"
               "          } else {"
               "            if(_u1[i]>maxmin) {"
               "              maxmin=_u1[i];"
               "              _mode[0]=i+1;"
               "            }"
               "          }"
               "        }"
               "      }"
               "    }else if(_nin==2){"
               "      for (i=0;i<GetInPortRows(block,1);++i){"
               "        _g[i]=_u1[i]-_u2[i];"
               "        if(phase==1){"
               "          if(_ipar[0]==1){"
               "            if(_g[i]>0) {"
               "              _mode[i]=2;"
               "            }else{"
               "              _mode[i]=1;"
               "            }"
               "          }else{"
               "            if(_g[i]<0) {"
               "              _mode[i]=2;"
               "            }else{"
               "              _mode[i]=1;"
               "            }"
               "          }"
               "        }"
               "      }"
               "    }"
               "  }"
               "}"
               ""]

      case 'modulo_count' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void "
               "modulo_count(scicos_block *block,int flag)"
               "{"
               "  int *_ipar=GetIparPtrs(block);"
               "  double *_z=GetDstate(block);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  if(flag == 1) {"
               "    *_y1=_z[0];"
               "  }else if (flag == 2){"
               "    _z[0]=(1+(int)_z[0])%(_ipar[0]);"
               "   }"
               "}"
               ""]

      case 'mswitch' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               "#include <memory.h>"
               ""
               "#define max(a,b) ((a) >= (b) ? (a) : (b))"
               "#define min(a,b) ((a) <= (b) ? (a) : (b))"
               ""
               "void  mswitch(scicos_block *block,int flag)"
               "{"
               "  if ((flag==1)||(flag==6)){"
               "    int i,j,nin,so,my,ny;"
               "    int mu,nu;"
               "    int *ipar;"
               "    double *u1;"
               "    void *uj;    "
               "    void *y;"
               "    j=0;"
               "    y=GetOutPortPtrs(block,1);"
               "    so=GetSizeOfOut(block,1);"
               "    my=GetOutPortRows(block,1);"
               "    ny=GetOutPortCols(block,1);"
               "    u1=GetRealInPortPtrs(block,1);"
               "    ipar=GetIparPtrs(block);"
               "    nin=GetNin(block);"
               "    i=*(ipar+1);"
               "    if (i==0) {"
               "      if (*u1>0) {"
               "        j=(int)floor(*u1);"
               "      }else{"
               "        j=(int)ceil(*u1);"
               "      }"
               "    }else if (i==1) {"
               "      if (*u1>0) {"
               "        j=(int)floor(*u1+.5);"
               "      }else{"
               "        j=(int)ceil(*u1-.5);"
               "      }"
               "    }else if (i==2) {"
               "      j=(int)ceil(*u1);"
               "    }else if (i==3) {"
               "      j=(int)floor(*u1);"
               "    }"
               "    j=j+1-*ipar;"
               "    j=max(j,1);"
               "    if (nin==2) {"
               "      mu=GetInPortRows(block,2);"
               "      nu=GetInPortCols(block,2);"
               "      uj=GetInPortPtrs(block,2);"
               "      j=min(j,mu*nu);"
               "      memcpy(y,uj+(j-1)*my*ny*so,my*ny*so);"
               "    } else{"
               "      j=min(j,nin-1);"
               "      uj=GetInPortPtrs(block,j+1);"
               "      memcpy(y,uj,my*ny*so);"
               "    }"
               "  }"
               "}"]

      case 'multiplex' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void multiplex(scicos_block *block,int flag)"
               "{"
               "  int _nin=GetNin(block);"
               "  int _nout=GetNout(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double *uytmp;"
               "  int i,j,k;"
               "  if (_nin==1){"
               "    k=0;"
               "    for (i=0;i<_nout;++i){"
               "      for (j=0;j<GetOutPortRows(block,i+1);++j){"
               "        uytmp=GetRealOutPortPtrs(block,i+1);"
               "        uytmp[j]=_u1[k];"
               "        ++k;"
               "      }"
               "    }"
               "  }else {"
               "    k=0;"
               "    for (i=0;i<_nin;++i){"
               "      for (j=0;j<GetInPortRows(block,i+1);++j){"
               "        uytmp=GetRealInPortPtrs(block,i+1);"
               "        _y1[k]=uytmp[j];"
               "        ++k;"
               "      }"
               "    }"
               "  }"
               "}"]

      case 'product' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void product(scicos_block *block,int flag)"
               "{"
               "  int *_ipar=GetIparPtrs(block);"
               "  int _nin=GetNin(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double *uytmp;"
               "  int j,k;"
               "  if(flag==1){"
               "    if (_nin==1){"
               "      _y1[0]=1.0;"
               "      for (j=0;j<GetInPortRows(block,1);j++) {"
               "        _y1[0]=_y1[0]*_u1[j];"
               "      }"
               "    }"
               "    else {"
               "      for (j=0;j<GetInPortRows(block,1);j++) {"
               "        _y1[j]=1.0;"
               "        for (k=0;k<_nin;k++) {"
               "          if(_ipar[k]>0){"
               "            uytmp=GetRealInPortPtrs(block,k+1);"
               "            _y1[j]=_y1[j]*uytmp[j];"
               "          }else{"
               "            uytmp=GetRealInPortPtrs(block,k+1);"
               "            if(uytmp[j]==0){"
               "              set_block_error(-2);"
               "              return;"
               "            }else{"
               "              uytmp=GetRealInPortPtrs(block,k+1);"
               "              _y1[j]=_y1[j]/uytmp[j];"
               "            }"
               "          }"
               "        }"
               "      }"
               "    }"
               "  }"
               "}"]

      case 'ramp' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void ramp(scicos_block *block,int flag)"
               "{double dt;"
               "  double *_rpar=GetRparPtrs(block);"
               "  double *_g=GetGPtrs(block);"
               "  int *_mode=GetModePtrs(block);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  if (flag==1){"
               "    dt=get_scicos_time()-_rpar[1];"
               "    if (get_phase_simulation()==1) {"
               "      if(dt>0) {"
               "        _y1[0]=_rpar[2]+_rpar[0]*dt;"
               "      }else{"
               "        _y1[0]=_rpar[2];"
               "      }"
               "    }else{"
               "      if(_mode[0]==1) {"
               "        _y1[0]=_rpar[2]+_rpar[0]*dt;"
               "      }else {"
               "        _y1[0]=_rpar[2];"
               "      }"
               "    }"
               "  } else if (flag==9){"
               "    _g[0]=get_scicos_time()-(_rpar[1]);"
               "    if (get_phase_simulation()==1) {"
               "      if (_g[0]>=0){"
               "        _mode[0]=1;"
               "      }else{"
               "        _mode[0]=2;"
               "      }"
               "    }"
               "  }"
               "}"
               ""]

      case 'ratelimiter' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "void ratelimiter(scicos_block *block,int flag)"
               "{/*  rpar[0]=rising rate limit, rpar[1]=falling rate limit */"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  double *_rpar=GetRparPtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double* pw;"
               "  double rate=0.,t;"
               "  if (flag == 4){/* the workspace is used to store previous values */"
               "    if ((*_work="
               "         scicos_malloc(sizeof(double)*4))== NULL ) {"
               "      set_block_error(-16);"
               "      return;"
               "    }"
               "    pw=*_work; "
               "    pw[0]=0.0;"
               "    pw[1]=0.0;"
               "    pw[2]=0.0;"
               "    pw[3]=0.0;"
               "  }else  if (flag == 5){"
               "    scicos_free(*_work);"
               "  } else if (flag==1) {"
               "    if (get_phase_simulation()==1) do_cold_restart();"
               "    pw=*_work; "
               "    t=get_scicos_time();"
               "    if(t>pw[2]){"
               "      pw[0]=pw[2];"
               "      pw[1]=pw[3];"
               "      rate=(_u1[0]-pw[1])/(t-pw[0]);"
               "    }"
               "    else if(t<=pw[2]){"
               "      if(t>pw[0]){"
               "        rate=(_u1[0]-pw[1])/(t-pw[0]);"
               "      }else{"
               "        rate=0.0;"
               "      }"
               "    }"
               "    if(rate>_rpar[0]){"
               "      _y1[0]=(t-pw[0])*_rpar[0]+pw[1];"
               "    } else if(rate<_rpar[1]){"
               "      _y1[0]=(t-pw[0])*_rpar[1]+pw[1];"
               "    }else{"
               "      _y1[0]=_u1[0];"
               "    }"
               "    pw[2]=t;"
               "    pw[3]=_y1[0];"
               "  }"
               "}"]

      case 'relationalop' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               ""
               "void relationalop(scicos_block *block,int flag)"
               "{"
               "  int *_ipar=GetIparPtrs(block);"
               "  int _ng=GetNg(block);"
               "  double *_g=GetGPtrs(block);"
               "  int *_mode=GetModePtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double *_u2=GetRealInPortPtrs(block,2);"
               "  int i;"
               "  i=_ipar[0];"
               "  if(flag==1){"
               "    if ((_ng!=0)&(get_phase_simulation()==2))"
               "      {"
               "        _y1[0]=_mode[0]-1.0;"
               "      }"
               "    else {"
               "      switch (i)"
               "        {"
               "        case 0:"
               "          if(_u1[0]==_u2[0]) {"
               "            _y1[0]=1.0;"
               "          }else{"
               "            _y1[0]=0.0;"
               "          }"
               "          break;"
               "          "
               "        case 1:"
               "          if(_u1[0]!=_u2[0]) {"
               "            _y1[0]=1.0;"
               "          }else{"
               "            _y1[0]=0.0;"
               "          }"
               "          break;"
               "        case 2:"
               "          if(_u1[0]<_u2[0]) {"
               "            _y1[0]=1.0;"
               "          }else{"
               "            _y1[0]=0.0;"
               "          }"
               "          break;    "
               "        case 3:"
               "          if(_u1[0]<=_u2[0]) {"
               "            _y1[0]=1.0;"
               "          }else{"
               "            _y1[0]=0.0;"
               "          }"
               "          break;   "
               "        case 4:"
               "          if(_u1[0]>=_u2[0]) {"
               "            _y1[0]=1.0;"
               "          }else{"
               "            _y1[0]=0.0;"
               "          }"
               "          break;   "
               "        case 5:"
               "          if(_u1[0]>_u2[0]) {"
               "            _y1[0]=1.0;"
               "          }else{"
               "            _y1[0]=0.0;"
               "          }"
               "          break;"
               "        }"
               "    }"
               ""
               "  }else if(flag==9){"
               "    _g[0]=_u1[0]-_u2[0];"
               "    if (get_phase_simulation()==1) {"
               "      switch (i)"
               "        {"
               "        case 0:"
               "          if(_u1[0]==_u2[0]) {"
               "            _mode[0]=(int)2.0;"
               "          }else{"
               "            _mode[0]=(int)1.0;"
               "          }"
               "          break;"
               "          "
               "        case 1:"
               "          if(_u1[0]!=_u2[0]) {"
               "            _mode[0]=(int)2.0;"
               "          }else{"
               "            _mode[0]=(int)1.0;"
               "          }"
               "          break;"
               "        case 2:"
               "          if(_u1[0]<_u2[0]) {"
               "            _mode[0]=(int)2.0;"
               "          }else{"
               "            _mode[0]=(int)1.0;"
               "          }"
               "          break;    "
               "        case 3:"
               "          if(_u1[0]<=_u2[0]) {"
               "            _mode[0]=(int)2.0;"
               "          }else{"
               "            _mode[0]=(int)1.0;"
               "          }"
               "          break;   "
               "        case 4:"
               "          if(_u1[0]>=_u2[0]) {"
               "            _mode[0]=(int)2.0;"
               "          }else{"
               "            _mode[0]=(int)1.0;"
               "          }"
               "          break;   "
               "        case 5:"
               "          if(_u1[0]>_u2[0]) {"
               "            _mode[0]=(int)2.0;"
               "          }else{"
               "            _mode[0]=(int)1.0;"
               "          }"
               "          break;"
               "        }"
               "    }"
               "  }"
               "}"]

      case 'ricc_m' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "extern int C2F(riccsl)();"
               "extern int C2F(riccms)();"
               "extern int C2F(ricdsl)();"
               "extern int C2F(ricdmf)();"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "#ifndef min"
               "#define min(a,b) ((a) <= (b) ? (a) : (b))"
               "#endif"
               ""
               "#ifndef max"
               "#define max(a,b) ((a) >= (b) ? (a) : (b))"
               "#endif"
               ""
               "typedef struct"
               "{         int *bwork;"
               "          int *iwork;"
               "          double *dwork;"
               "          double *LX;"
               "          double *LWI;"
               "          double *LWR;"
               "          double *Rcond;"
               "          double *Ferr;"
               "} ricc_struct ;"
               "void ricc_m(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               " double *u1;"
               " double *u2;"
               " double *u3;"
               " double *y;"
               " int *ipar;"
               " int nu;"
               " int info,i;"
               " int lw;"
               " ricc_struct *ptr;"
               ""
               " nu =GetInPortCols(block,1);"
               " u1=GetRealInPortPtrs(block,1);"
               " u2=GetRealInPortPtrs(block,2);"
               " u3=GetRealInPortPtrs(block,3);"
               " y=GetRealOutPortPtrs(block,1);"
               " ipar=GetIparPtrs(block);"
               " if (ipar[0]==1)"
               "    {if (ipar[1]==1)"
               "         {lw=9*nu*nu+4*nu+max(1,6*nu);}"
               "     else"
               "         {lw=9*nu*nu+7*nu+1;}}"
               " else"
               "     {if (ipar[1]==1)"
               "         {lw=12*nu*nu+22*nu+max(21,4*nu);}"
               "     else"
               "         {lw=28*nu*nu+2*nu+max(1,2*nu);}}"
               ""
               "             /*init : initialization*/"
               "if (flag==4)"
               "   {if((*(_work)=(ricc_struct*) scicos_malloc(sizeof(ricc_struct)))==NULL)"
               "        {set_block_error(-16);"
               "         return;}"
               "    ptr=*(_work);"
               "    if((ptr->bwork=(int*) scicos_malloc(sizeof(int)*2*nu))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->iwork=(int*) scicos_malloc(sizeof(int)*max(2*nu,nu*nu)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->bwork);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->dwork=(double*) scicos_malloc(sizeof(double)*lw))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->bwork);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LWR=(double*) scicos_malloc(sizeof(double)*nu))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->bwork);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LWI=(double*) scicos_malloc(sizeof(double)*nu))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LWR);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->bwork);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->Rcond=(double*) scicos_malloc(sizeof(double)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->LWI);"
               "         scicos_free(ptr->LWR);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->bwork);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->Ferr=(double*) scicos_malloc(sizeof(double)))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->Rcond);"
               "         scicos_free(ptr->LWI);"
               "         scicos_free(ptr->LWR);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->bwork);"
               "         scicos_free(ptr);"
               "         return;}"
               "    if((ptr->LX=(double*) scicos_malloc(sizeof(double)*nu*nu))==NULL)"
               "        {set_block_error(-16);"
               "         scicos_free(ptr->Ferr);"
               "         scicos_free(ptr->Rcond);"
               "         scicos_free(ptr->LWI);"
               "         scicos_free(ptr->LWR);"
               "         scicos_free(ptr->dwork);"
               "         scicos_free(ptr->iwork);"
               "         scicos_free(ptr->bwork);"
               "         scicos_free(ptr);"
               "         return;}"
               "   }"
               ""
               "       /* Terminaison */"
               "else if (flag==5)"
               "   {ptr=*(_work);"
               "    if((ptr->LX)!=NULL){"
               "        scicos_free(ptr->bwork);"
               "        scicos_free(ptr->Ferr);"
               "        scicos_free(ptr->Rcond);"
               "        scicos_free(ptr->iwork);"
               "        scicos_free(ptr->LWR);"
               "        scicos_free(ptr->LWI);"
               "        scicos_free(ptr->LX);"
               "        scicos_free(ptr->dwork);"
               "        scicos_free(ptr);"
               "        return;}"
               "   }"
               ""
               "else"
               "   {"
               "    ptr=*(_work);"
               "    if (ipar[0]==1)"
               "       {if (ipar[1]==1)"
               "            {C2F(riccsl)(""N"",&nu,u1,&nu,""U"",u3,&nu,u2,&nu,ptr->LX,&nu,ptr->LWR,ptr->LWI,ptr->Rcond,ptr->Ferr,ptr->dwork,&lw,ptr->iwork,ptr->bwork,&info);}"
               "         else"
               "            {C2F(riccms)(""N"",&nu,u1,&nu,""U"",u3,&nu,u2,&nu,ptr->LX,&nu,ptr->LWR,ptr->LWI,ptr->Rcond,ptr->Ferr,ptr->dwork,&lw,ptr->iwork,&info);}}"
               "     else"
               "         {if (ipar[1]==1)"
               "             {C2F(ricdsl)(""N"",&nu,u1,&nu,""U"",u3,&nu,u2,&nu,ptr->LX,&nu,ptr->LWR,ptr->LWI,ptr->Rcond,ptr->Ferr,ptr->dwork,&lw,ptr->iwork,ptr->bwork,&info);}"
               "          else"
               "             {C2F(ricdmf)(""N"",&nu,u1,&nu,""U"",u3,&nu,u2,&nu,ptr->LX,&nu,ptr->LWR,ptr->LWI,ptr->Rcond,ptr->Ferr,ptr->dwork,&lw,ptr->iwork,&info);}}"
               "     if (info!=0)"
               "        {if (flag!=6)"
               "            {set_block_error(-7);"
               "             return;"
               "            }"
               "        }"
               "     for(i=0;i<nu*nu;i++) *(y+i)=*(ptr->LX+i);"
               "    }"
               "}"]

      case 'rndblk_m' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               "#include <math.h>"
               "extern double C2F(urand)();"
               "void rndblk_m(scicos_block *block,int flag)"
               "{"
               "  double *y;"
               "  double *rpar;"
               "  double *z;"
               "  int *ipar;"
               "  int ny,my,i,iy;"
               "  double sr,si,tl;"
               ""
               "  my=GetOutPortRows(block,1);"
               "  ny=GetOutPortCols(block,1);"
               "  ipar=GetIparPtrs(block);"
               "  rpar=GetRparPtrs(block);"
               "  y=GetRealOutPortPtrs(block,1);"
               "  z=GetDstate(block);"
               ""
               "  if (flag==2||flag==4)"
               "  {if (ipar[0]==0)"
               "       {iy=(int)z[0];"
               "        for (i=0;i<my*ny;i++)"
               "             {*(z+i+1)=C2F(urand)(&iy);}"
               "       }"
               "   else "
               "        {iy=(int)z[0];"
               "         for (i=0;i<my*ny;i++)"
               "              {do"
               "                 {sr=2.0*C2F(urand)(&iy)-1.0;"
               "                  si=2.0*C2F(urand)(&iy)-1.0;"
               "                  tl=sr*sr+si*si;"
               "                 } while(tl>1.0);"
               "               z[i+1]= sr*(sqrt(-2.0*log(tl)/tl));}"
               "          }"
               "    *(z)=iy;"
               "    }"
               ""
               "  if (flag==1||flag==6)"
               "      {for (i=0;i<my*ny;i++) *(y+i)=*(rpar+i)+(*(rpar+i+my*ny))*(*(z+i+1));"
               "      }"
               "}"
               ""]

      case 'root_coef' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               "extern int C2F(dprxc)();"
               "void root_coef(scicos_block *block,int flag)"
               "{"
               "  double *u;"
               "  double *y;"
               "  int mu;"
               "  mu=GetInPortRows(block,1);"
               ""
               "  u=GetRealInPortPtrs(block,1);"
               "  y=GetRealOutPortPtrs(block,1);"
               "  if (flag==1||flag==6)"
               "  C2F(dprxc)(&mu,u,y);"
               "}"]

      case 'samphold4_m' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""memory.h"""
               ""
               "void samphold4_m(scicos_block *block,int flag)"
               "{"
               "  /* c     Copyright INRIA"
               "     "
               "  Scicos block simulator"
               "  returns sample and hold  of the input */"
               "  "
               "if ((flag ==1)) {"
               "  void *u,*y;"
               "  int m,n,sz;"
               "  m=GetInPortRows(block,1);"
               "  n=GetInPortCols(block,1);"
               "  u=GetInPortPtrs(block,1);"
               "  y=GetOutPortPtrs(block,1);"
               "  sz=GetSizeOfOut(block,1);"
               "  memcpy(y,u,m*n*sz);"
               "  }"
               "}"]

      case 'satur' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void  satur(scicos_block *block,int flag)"
               "{/* rpar[0]:upper limit,  rpar[1]:lower limit */"
               "  double *_rpar=GetRparPtrs(block);"
               "  int _ng=GetNg(block);"
               "  double *_g=GetGPtrs(block);"
               "  int *_mode=GetModePtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  if (flag==1){"
               "    if (get_phase_simulation()==1||_ng==0) {"
               "      if (*_u1>=_rpar[0]){"
               "        _y1[0]=_rpar[0];"
               "      }else if (*_u1<=_rpar[1]){"
               "        _y1[0]=_rpar[1];"
               "      }else {"
               "        _y1[0]=_u1[0];"
               "      }"
               "    }else{"
               "      if (_mode[0]==1){"
               "        _y1[0]=_rpar[0];"
               "      }else if(_mode[0]==2) {"
               "        _y1[0]=_rpar[1];"
               "      }else{"
               "        _y1[0]=_u1[0];"
               "      } "
               "    }"
               "  } else if (flag==9){"
               "    _g[0]=*_u1-(_rpar[0]);"
               "    _g[1]=*_u1-(_rpar[1]);"
               "    if (get_phase_simulation()==1) {"
               "      if (_g[0]>=0){"
               "        _mode[0]=1;"
               "      }else if (_g[1]<=0){"
               "        _mode[0]=2;"
               "      }else {"
               "        _mode[0]=3;"
               "      }"
               "    }"
               "  }"
               "}"
               ""]

      case 'scalar2vector' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void scalar2vector(scicos_block *block,int flag)"
               "{"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  int i;"
               "  if(flag==1){"
               "    for(i=0;i<GetOutPortRows(block,1);++i){"
               "      _y1[i]=_u1[0];"
               "    }"
               "  }"
               "}"]

      case 'scicosexit' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "void scicosexit(scicos_block *block,int flag)"
               "{"
               " if (flag==1) end_scicos_sim();"
               "}"
               ""]

      case 'selector_m' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               "#include <memory.h>"
               ""
               "void selector_m(scicos_block *block,int flag)"
               " {"
               "  void *u;"
               "  void *y;"
               "  double *z;"
               "  int nu,mu,ic,nev,nin,so;"
               ""
               "  z=GetDstate(block);"
               "  nin=GetNin(block);"
               "  ic=(int)z[0];"
               "  if (flag<3)"
               "     {ic=0;"
               "      nev=GetNevIn(block);"
               "      while (nev>=1) "
               "           {"
               "            ic=ic+1;"
               "            nev=nev/2;"
               "           }"
               "     }"
               "  if (nin>1)"
               "     {"
               "      mu=GetInPortRows(block,ic);"
               "      nu=GetInPortCols(block,ic);"
               "      u=GetInPortPtrs(block,ic);"
               "      so=GetSizeOfOut(block,1);"
               "      y=GetOutPortPtrs(block,1);"
               "      memcpy(y,u,mu*nu*so);"
               "      }"
               "   else"
               "      {"
               "       mu=GetInPortRows(block,1);"
               "       nu=GetInPortCols(block,1);"
               "       u=GetInPortPtrs(block,1);"
               "       y=GetOutPortPtrs(block,ic);"
               "       so=GetSizeOfIn(block,1);"
               "       memcpy(y,u,mu*nu*so);"
               "       }"
               "}"]

      case 'shift_32_LA' then
        txt = ["# include ""scicos_block4.h"""
               "# include ""machine.h"""
               "# include <math.h>"
               ""
               "void shift_32_LA(scicos_block *block,int flag)"
               "{"
               "  long *u,*y; "
               "  int *ipar;"
               "  int mu,nu,i;"
               "  mu=GetInPortRows(block,1);"
               "  nu=GetInPortCols(block,1);"
               "  u=Getint32InPortPtrs(block,1);"
               "  y=Getint32OutPortPtrs(block,1);"
               "  ipar=GetIparPtrs(block);"
               "  for (i=0;i<mu*nu;i++) y[i]=u[i]<<ipar[0];"
               "}"]

      case 'signum' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void  signum(scicos_block *block,int flag)"
               "{"
               "  int _ng=GetNg(block);"
               "  double *_g=GetGPtrs(block);"
               "  int *_mode=GetModePtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  int i,j;"
               "  if (flag==1){"
               "    for(i=0;i<GetInPortRows(block,1);++i){"
               "      if (get_phase_simulation()==1||_ng==0) {"
               "        if (_u1[i]<0){"
               "          j=2;"
               "        } else if (_u1[i]>0){"
               "          j=1;"
               "        }else{"
               "          j=0;"
               "        }"
               "      }else {"
               "        j=_mode[i];"
               "      }"
               "      if (j==1){"
               "        _y1[i]=1.0;"
               "      } else if(j==2){"
               "        _y1[i]=-1.0;"
               "      }else{"
               "        _y1[i]=0.0;"
               "      }"
               "    }"
               "  }else if (flag==9){"
               "    for(i=0;i<GetInPortRows(block,1);++i){"
               "      _g[i]=_u1[i];"
               "      if (get_phase_simulation()==1) {"
               "        if(_g[i]<0){"
               "          _mode[i]=2;"
               "        }else{"
               "          _mode[i]=1;"
               "        }"
               "      }"
               "    }"
               "  }"
               "}"
               ""]

      case 'sin_blk' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void sin_blk(scicos_block *block,int flag)"
               "{"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  int j;"
               "  if(flag==1){"
               "    for (j=0;j<GetInPortRows(block,1);j++) {"
               "      _y1[j]=sin(_u1[j]);"
               "    }"
               "  }"
               "}"]

      case 'step_func' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               "void  step_func(scicos_block *block,int flag)"
               "{"
               "  double *_rpar=GetRparPtrs(block);"
               "  int _nevprt=GetNevIn(block);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  int i;"
               "  if (flag==1&&_nevprt==1) {"
               "    for (i=0;i<GetOutPortRows(block,1);++i) {"
               "      _y1[i]=_rpar[GetOutPortRows(block,1)+i];"
               "    } "
               "  }else if (flag==4) {"
               "    for(i=0;i<GetOutPortRows(block,1);++i) {"
               "      _y1[i]=_rpar[i];"
               "    }"
               "  }"
               "}"
               ""]

      case 'submat' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "void submat(scicos_block *block,int flag)"
               "{"
               "  double *u;"
               "  double *y;"
               "  int *r;"
               "  int nu,mu,i,j,ij,k;"
               ""
               "  mu=GetInPortRows(block,1);"
               "  nu=GetInPortCols(block,1);"
               "  r=GetIparPtrs(block);"
               "  u=GetRealInPortPtrs(block,1);"
               "  y=GetRealOutPortPtrs(block,1);"
               "  k=0;"
               "  for (j=r[2]-1;j<r[3];j++)"
               "        {for (i=r[0]-1;i<r[1];i++)"
               "                {ij=i+j*mu;"
               "                 *(y+k)=*(u+ij);"
               "                 k++;}}"
               "}"]

      case 'summation' then
        txt = ["#include <math.h>"
               "#include ""scicos_block4.h"""
               ""
               ""
               "void summation(scicos_block *block,int flag)"
               "{"
               "  int j,k;"
               ""
               "  double *u;"
               "  int nu,mu;"
               "  double *y;"
               "  int *ipar;"
               ""
               "  y=GetRealOutPortPtrs(block,1);"
               "  nu=GetInPortRows(block,1);"
               "  mu=GetInPortCols(block,1);"
               "  ipar=GetIparPtrs(block);"
               ""
               "  if(flag==1){"
               "    if (GetNin(block)==1){"
               "      y[0]=0.0;"
               "      u=GetRealInPortPtrs(block,1);"
               "      for (j=0;j<nu*mu;j++) {"
               "        y[0]=y[0]+u[j];"
               "      }"
               "    }"
               "    else {"
               "      for (j=0;j<nu*mu;j++) {"
               "        y[j]=0.0;"
               "        for (k=0;k<GetNin(block);k++) {"
               "          u=GetRealInPortPtrs(block,k+1);"
               "          if(ipar[k]>0){"
               "            y[j]=y[j]+u[j];"
               "          }else{"
               "            y[j]=y[j]-u[j];"
               "          }"
               "        }"
               "      }"
               "    }"
               "  }"
               "}"]

      case 'switch2_m' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               "#include <memory.h>"
               ""
               "void  switch2_m(scicos_block *block,int flag)"
               "{"
               "  int _ng=GetNg(block);"
               "  double *_g=GetGPtrs(block);"
               "  int *_mode=GetModePtrs(block);"
               "  int i=0;"
               "  int phase,ipar,mu,nu,so;"
               "  int *iparptrs;"
               "  double *rpar;"
               "  double *u2;"
               "  void *y,*u;"
               "  iparptrs=GetIparPtrs(block);"
               "  ipar=*iparptrs;"
               "  rpar=GetRparPtrs(block);"
               "  mu=GetInPortRows(block,1);"
               "  nu=GetInPortCols(block,1);"
               "  u2=GetRealInPortPtrs(block,2);"
               "  y=GetOutPortPtrs(block,1);"
               "  if (flag == 1) {"
               "    phase=get_phase_simulation();"
               "    if (phase==1||_ng==0){"
               "      i=3;"
               "      if (ipar==0){"
               "        if (*u2>=*rpar) i=1;"
               "      }else if (ipar==1){"
               "        if (*u2>*rpar) i=1;"
               "      }else {"
               "        if (*u2!=*rpar) i=1;"
               "      }"
               "    }else{"
               "      if(_mode[0]==1){"
               "        i=1;"
               "      }else if(_mode[0]==2){"
               "        i=3;"
               "      }"
               "    }"
               "       u=GetInPortPtrs(block,i);"
               "       so=GetSizeOfOut(block,1);"
               "       memcpy(y,u,mu*nu*so);"
               "  }else if(flag == 9){"
               "    phase=get_phase_simulation();"
               "    _g[0]=*u2-*rpar;"
               "    if (phase==1){"
               "      i=3;"
               "      if (ipar==0){"
               "        if (_g[0]>=0.0) i=1;"
               "      }else if (ipar==1){"
               "        if (_g[0]>0.0) i=1;"
               "      }else {"
               "        if (_g[0]!=0.0) i=1;"
               "      }"
               "      if(i==1) {"
               "        _mode[0]=1;"
               "      }else{"
               "        _mode[0]=2;"
               "      }"
               "    }"
               "  }"
               "}"]

      case 'tcslti4' then
        txt = [""
               "#include <math.h>"
               "#include <memory.h>"
               ""
               "#include ""scicos_block4.h"""
               "#include ""machine.h"""
               ""
               "extern int C2F(dmmul)();"
               "extern int C2F(dmmul1)();"
               ""
               ""
               "void tcslti4(scicos_block *block,int flag)"
               "{"
               "  int _nevprt=GetNevIn(block);"
               "  /* Copyright INRIA"
               "   "
               "     Scicos block simulator"
               "     continuous state space linear system simulator"
               "     rpar(1:nx*nx)=A"
               "     rpar(nx*nx+1:nx*nx+nx*nu)=B"
               "     rpar(nx*nx+nx*nu+1:nx*nx+nx*nu+nx*ny)=C"
               "     rpar(nx*nx+nx*nu+nx*ny+1:nx*nx+nx*nu+nx*ny+ny*nu)=D */"
               ""
               "  int un=1,lb,lc,ld;"
               "  int nx=GetNstate(block);"
               "  double* x=GetState(block);"
               "  double* xd=GetDerState(block);"
               "  double* rpar=GetRparPtrs(block);"
               "  double* y=GetRealOutPortPtrs(block,1);"
               "  double* u1=GetRealInPortPtrs(block,1);"
               "  double* u2=GetRealInPortPtrs(block,2);"
               "  int noutsz=GetOutPortRows(block,1);"
               "  int ninsz=GetInPortRows(block,1);"
               "    "
               "  lb=nx*nx;"
               "  lc=lb+nx*ninsz;"
               "  "
               "  if (flag ==1 || flag ==6){"
               "    /* y=c*x+d*u1 */  "
               "    ld=lc+nx*noutsz;"
               ""
               "    C2F(dmmul)(&rpar[lc],&noutsz,x,&nx,y,&noutsz,&noutsz,&nx,&un);"
               "    C2F(dmmul1)(&rpar[ld],&noutsz,u1,&ninsz,y,&noutsz,&noutsz,ninsz,&un);"
               ""
               "  }else if (flag == 2 && _nevprt == 1){"
               "    /* x+=u2 */"
               "    memcpy(x,u2 ,nx*sizeof(double));"
               "  }else if (flag ==0 && _nevprt == 0){"
               "    /* xd=a*x+b*u1 */"
               "    C2F(dmmul)(&rpar[0],&nx,x,&nx,xd,&nx,&nx,&nx,&un);"
               "    C2F(dmmul1)(&rpar[lb],&nx,u1,&ninsz,xd,&nx,&nx,&ninsz,&un);"
               "  }"
               "}"
               ""]

      case 'time_delay' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               "#include ""machine.h"""
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "extern void sciprint __PARAMS((char *fmt,...));"
               ""
               "void time_delay(scicos_block *block,int flag)"
               "{/*  rpar[0]=delay, rpar[1]=init value, ipar[0]=buffer length */"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  double *_rpar=GetRparPtrs(block);"
               "  int *_ipar=GetIparPtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double* pw,del,t,td,eps;"
               "  int* iw;"
               "  int i,j,k;"
               "  if (flag == 4){/* the workspace is used to store previous values */"
               "    if ((*_work="
               "         scicos_malloc(sizeof(int)+sizeof(double)* "
               "                       _ipar[0]*(1+GetInPortRows(block,1))))== NULL ) {"
               "      set_block_error(-16);"
               "      return;"
               "    }"
               "    eps=1.0e-9; /* shift times to left to avoid replacing 0 */"
               "    pw=*_work; "
               "    pw[0]=-_rpar[0]*(_ipar[0]-1)-eps;"
               "    for(j=1;j< GetInPortRows(block,1)+1;j++){"
               "        pw[_ipar[0]*j]=_rpar[1];"
               "    }"
               ""
               "    for(i=1;i< _ipar[0];i++){"
               "      pw[i]=pw[i-1]+_rpar[0]-eps;"
               "      for(j=1;j< GetInPortRows(block,1)+1;j++){"
               "        pw[i+_ipar[0]*j]=_rpar[1];"
               "      }"
               "    }"
               "    "
               "    iw=(int *)(pw+_ipar[0]*(1+GetInPortRows(block,1)));"
               "    *iw=0;"
               "    for (k=0;k<GetInPortRows(block,1);k++){"
               "        _y1[k]=_rpar[1];"
               "    }"
               "  }else  if (flag == 5){"
               "    scicos_free(*_work);"
               ""
               "  } else if (flag==0||flag==2) {"
               "    if (flag==2) do_cold_restart();"
               "    pw=*_work; "
               "    iw=(int *)(pw+_ipar[0]*(1+GetInPortRows(block,1)));"
               "    t=get_scicos_time();"
               "    td=t-_rpar[0];"
               "    if(td<pw[*iw]){"
               "      sciprint(""delayed time=%f but last stored time=%f \r\n"", td, pw[*iw]);"
               "      sciprint(""Consider increasing the length of buffer in delay block \r\n"");"
               "    }"
               ""
               "    if (t>pw[(_ipar[0]+*iw-1)%_ipar[0]]){"
               "      for(j=1;j< GetInPortRows(block,1)+1;j++){"
               "        pw[*iw +_ipar[0]*j]=_u1[j-1];"
               "      }"
               "      pw[*iw]=t;"
               "      /*sciprint(""**time is %f. I put %f, in %d \r\n"", t,_u1[0],*iw);*/"
               "      *iw=(*iw+1)%_ipar[0];"
               " "
               "    }else{"
               "      for(j=1;j< GetInPortRows(block,1)+1;j++){"
               "        pw[(_ipar[0]+*iw-1)%_ipar[0] +_ipar[0]*j]=_u1[j-1];"
               "      }"
               "      pw[(_ipar[0]+*iw-1)%_ipar[0]]=t;"
               "      /*sciprint(""**time is %f. I put %f, in %d \r\n"", t,_u1[0],*iw);*/"
               ""
               "    }"
               ""
               "  } else if (flag==1) {"
               "    pw=*_work; "
               "    iw=(int *) (pw+_ipar[0]*(1+GetInPortRows(block,1)));"
               "    t=get_scicos_time();"
               "    td=t-_rpar[0];"
               ""
               "    i=0;j= _ipar[0]-1;"
               ""
               "    while (j-i>1) {"
               "      k=(i+j)/2;"
               "      if (td<pw[(k+*iw)%_ipar[0]]) {"
               "        j=k;"
               "      }else if (td>pw[(k+*iw)%_ipar[0]]) {"
               "        i=k;"
               "      }else{"
               "        i=k;"
               "        j=k;"
               "        break;"
               "      }"
               "    }"
               "    i=(i+*iw)%_ipar[0];"
               "    j=(j+*iw)%_ipar[0];"
               "    del=pw[j]-pw[i];"
               "    /*    sciprint(""time is %f. interpolating %d and %d, i.e. %f, %f\r\n"", t,i,j,pw[i],pw[j]);"
               "          sciprint(""values are  %f   %f.\r\n"",pw[i+_ipar[0]],pw[j+_ipar[0]]);*/"
               "    if(del!=0.0){"
               "      for (k=1;k<GetInPortRows(block,1)+1;k++){"
               "        _y1[k-1]=((pw[j]-td)*pw[i+_ipar[0]*k] +"
               "                               (td-pw[i])*pw[j+_ipar[0]*k])/del;"
               "      }"
               "    }else{"
               "      for (k=1;k<GetInPortRows(block,1)+1;k++){"
               "        _y1[k-1]=pw[i+_ipar[0]*k];"
               "      }"
               "    }"
               "  }"
               "}"]

      case 'tows_c' then
        txt = ["#include ""scicos_block4.h"""
               "#include ""machine.h"""
               "#include ""../stack-c.h"""
               "#include <stdio.h>"
               "#include <string.h>"
               ""
               "#ifndef NULL"
               "#define NULL    0"
               "#endif"
               ""
               "/*YAPASDETROUDANSLESLISTESDANSLESFICHERS*/"
               "/*ONLITPASPTR_I[8-9-10-11]*/"
               "#define codehm \"
               "        ptr_i[6]   = 17; \"
               "        ptr_i[7]   = 3;  \"
               "        ptr_i[8]   = 1;  \"
               "        ptr_i[9]   = ptr_i[8]  + 11; \"
               "        ptr_i[10]  = ptr_i[9]  + 4;  \"
               "        ptr_i[11]  = ptr_i[10] + 2 + nz*nu*nu2; \"
               "        ptr_i[12]  = 10; \"
               "        ptr_i[13]  = 1; \"
               "        ptr_i[14]  = 3; \"
               "        ptr_i[15]  = 0; \"
               "        ptr_i[16]  = 1; \"
               "        ptr_i[17]  = ptr_i[16] + 2; \"
               "        ptr_i[18]  = ptr_i[17] + 4; \"
               "        ptr_i[19]  = ptr_i[18] + 7; \"
               "        i = strlen(str_hmlst[0]);   \"
               "        C2F(cvstr)(&i,&ptr_i[20],str_hmlst[0],(l=0,&l),(unsigned long) i); \"
               "        j = strlen(str_hmlst[1]); \"
               "        C2F(cvstr)(&j,&ptr_i[20+i],str_hmlst[1],(l=0,&l),(unsigned long) j); \"
               "        k = strlen(str_hmlst[2]); \"
               "        C2F(cvstr)(&k,&ptr_i[20+i+j],str_hmlst[2],(l=0,&l),(unsigned long) k); \"
               "        ptr_i[33]  = 8; \"
               "        ptr_i[34]  = 1; \"
               "        ptr_i[35]  = 3; \"
               "        ptr_i[36]  = 4; \"
               "        ptr_i[37]  = nu; \"
               "        ptr_i[38]  = nu2; \"
               "        ptr_i[39]  = nz;"
               ""
               "extern int C2F(cvstr) __PARAMS((integer *,integer *,char *,integer *,unsigned long int));"
               "extern int C2F(mputnc)();"
               "extern int C2F(namstr)();"
               "extern void C2F(mopen)();"
               "extern int C2F(cluni0) __PARAMS((char *name, char *nams, integer *ln, long int name_len,"
               "                                long int nams_len));"
               "extern void C2F(mclose) __PARAMS((integer *fd, double *res));"
               "extern void sciprint __PARAMS((char *fmt,...));"
               ""
               "static int id[nsiz];"
               "static char fmtd[3]  = {''d'',''l'',''\000''};"
               "static char fmti[3]  = {''i'',''l'',''\000''};"
               "static char fmtl[3]  = {''l'',''l'',''\000''};"
               "static char fmts[3]  = {''s'',''l'',''\000''};"
               "static char fmtc[3]  = {''c'',''l'',''\000''};"
               "static char fmtul[3] = {''u'',''l'',''\000''};"
               "static char fmtus[3] = {''u'',''s'',''\000''};"
               "static char fmtuc[3] = {''u'',''c'',''\000''};"
               ""
               "static char *str_hmlst[]={""hm"",""dims"",""entries""};"
               ""
               "#ifdef hppa"
               "#undef FILENAME_MAX"
               "#define FILENAME_MAX 4096"
               "#endif"
               ""
               "/* work struct for that block */"
               "typedef struct {"
               "  int cnt;"
               "  int loop;"
               "  void *work;"
               "  void *workt;"
               "} towork_struct ;"
               ""
               "void tows_c(scicos_block *block,int flag)"
               "/* Copyright INRIA */"
               "/* Put a typed vector in a scilab file."
               " * Independant platform."
               " *"
               " * Author A.Layec - initial rev. 18/09/07"
               " */"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  int *_ipar=GetIparPtrs(block);"
               " /* for mopen */"
               " int fd;"
               " char *status;"
               " int swap = 1;"
               " double res;"
               " int out_n;"
               " long int lout;"
               " char filename[FILENAME_MAX];"
               " /* for name of file */"
               " char str[100];"
               " /* generic pointer */"
               " SCSREAL_COP *u_d,*u_cd,*ptr_d,*sav_d;"
               " SCSINT8_COP *u_c,*ptr_c,*sav_c;"
               " SCSUINT8_COP *u_uc, *ptr_uc,*sav_uc;"
               " SCSINT16_COP *u_s,*ptr_s,*sav_s;"
               " SCSUINT16_COP *u_us,*ptr_us,*sav_us;"
               " SCSINT_COP *ptr_i;"
               " SCSINT32_COP *u_l,*ptr_l,*sav_l;"
               " SCSUINT32_COP *u_ul,*ptr_ul,*sav_ul;"
               " double sav_t;"
               " /* the struct ptr of that block */"
               " towork_struct *ptr;"
               " /* */"
               " int nu,nu2,ut;"
               " int nz;"
               " double t,t_old;"
               " /* local */"
               " int i,j,k,l;"
               " int ierr;"
               ""
               " int  ismat=0;"
               ""
               " /* for path of TMPDIR/workspace */"
               " char env[256];"
               " char sep[2];"
               "#ifdef _MSC_VER"
               "  sep[0]=''\\'';"
               "#else"
               "  sep[0]=''/'';"
               "#endif"
               "  sep[1]=''\0'';"
               ""
               " /* retrieve param of that block */"
               " nu  = GetInPortRows(block,1); /* number of rows of inputs*/"
               " nu2 = GetInPortCols(block,1); /* number of cols of inputs*/"
               " ut  = GetInType(block,1);     /* input type */"
               " nz  = _ipar[0];         /* buffer size */"
               ""
               " /* check if u is a matrix */"
               " if (nu2!=1) {"
               "   ismat=1;"
               " }"
               ""
               " if (flag==4) { /* init */"
               ""
               "   /* begin campaign of allocations */"
               "   if((*(_work)=(towork_struct*) scicos_malloc(sizeof(towork_struct)))==NULL) {"
               "     set_block_error(-16);"
               "     return;"
               "   }"
               ""
               "   ptr = *(_work);"
               ""
               "   /*"
               "    * t"
               "    */"
               "   if((ptr->workt=(void *) scicos_malloc(6*sizeof(int)+4*sizeof(int)+ \"
               "                                          nz*sizeof(double)))==NULL) {"
               "     set_block_error(-16);"
               "     scicos_free(ptr);"
               "     *(_work) = NULL;"
               "     return;"
               "   }"
               "   ptr_i    = (int*) ptr->workt;"
               "   ptr_i[6] = 1;"
               "   ptr_i[7] = nz;"
               "   ptr_i[8] = 1;"
               "   ptr_i[9] = 0;"
               ""
               "   ptr_d = (SCSREAL_COP *) &(ptr_i[10]);"
               "   for (i=0;i<nz;i++) {"
               "     ptr_d[i]=-1;"
               "   }"
               ""
               "   /* Scilab variable code name */"
               "   C2F(namstr)(id,(i=29,&i),(j=1,&j),(k=0,&k));"
               ""
               "   ptr_i    = (int*) ptr->workt;"
               "   ptr_i[0] = id[0];"
               "   ptr_i[1] = id[1];"
               "   ptr_i[2] = id[2];"
               "   ptr_i[3] = id[3];"
               "   ptr_i[4] = id[4];"
               "   ptr_i[5] = id[5];"
               ""
               "   /*"
               "    * x"
               "    */"
               "   switch (ut)"
               "   {"
               "    case SCSREAL_N    :"
               "      if (ismat) {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int) + \"
               "                                             2*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (2+4+7)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (3)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             nz*nu*nu2*sizeof(double)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        codehm"
               "        ptr_i[40]  = 1;                     /*head of entries for hm*/"
               "        ptr_i[41]  = nu*nu2*nz;"
               "        ptr_i[42]  = 1;"
               "        ptr_i[43]  = 0;"
               "        ptr_d      = (SCSREAL_COP *) &(ptr_i[44]);"
               ""
               "      }"
               "      else {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int)+4*sizeof(int)+ \"
               "                                              nz*nu*sizeof(double)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        ptr_i[6]   = 1;"
               "        ptr_i[7]   = nz;"
               "        ptr_i[8]   = nu;"
               "        ptr_i[9]   = 0;"
               "        ptr_d      = (SCSREAL_COP *) &(ptr_i[10]);"
               "      }"
               "      for (i=0;i<nu*nu2*nz;i++) {"
               "        ptr_d[i] = 0.;"
               "      }"
               "      break;"
               ""
               "    case SCSCOMPLEX_N :"
               "      if (ismat) {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int) + \"
               "                                             2*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (2+4+7)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (3)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             2*nz*nu*nu2*sizeof(double)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        codehm"
               "        ptr_i[40]  = 1;                     /*head of entries for hm*/"
               "        ptr_i[41]  = nu*nu2*nz;"
               "        ptr_i[42]  = 1;"
               "        ptr_i[43]  = 1;"
               "        ptr_d      = (SCSREAL_COP *) &(ptr_i[44]);"
               ""
               "      }"
               "      else {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int)+4*sizeof(int)+ \"
               "                                              2*nz*nu*sizeof(double)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        ptr_i[6]   = 1;"
               "        ptr_i[7]   = nz;"
               "        ptr_i[8]   = nu;"
               "        ptr_i[9]   = 1;"
               "        ptr_d      = (SCSREAL_COP *) &(ptr_i[10]);"
               "      }"
               "      for (i=0;i<2*nu*nu2*nz;i++) {"
               "        ptr_d[i] = 0.;"
               "      }"
               "      break;"
               ""
               "    case SCSINT8_N    :"
               "      if (ismat) {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int) + \"
               "                                             2*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (2+4+7)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (3)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             nz*nu*nu2*sizeof(char)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        codehm"
               "        ptr_i[40]  = 8;                     /*head of entries for hm*/"
               "        ptr_i[41]  = nu*nu2*nz;"
               "        ptr_i[42]  = 1;"
               "        ptr_i[43]  = 1;"
               "        ptr_c      = (SCSINT8_COP *) &(ptr_i[44]);"
               ""
               "      }"
               "      else {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int)+4*sizeof(int)+ \"
               "                                              nz*nu*sizeof(char)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        ptr_i[6]   = 8;"
               "        ptr_i[7]   = nz;"
               "        ptr_i[8]   = nu;"
               "        ptr_i[9]   = 1;"
               "        ptr_c      = (SCSINT8_COP *) &(ptr_i[10]);"
               "      }"
               "      for (i=0;i<nu*nu2*nz;i++) {"
               "        ptr_c[i] = 0;"
               "      }"
               "      break;"
               ""
               "    case SCSINT16_N   :"
               "      if (ismat) {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int) + \"
               "                                             2*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (2+4+7)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (3)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             nz*nu*nu2*sizeof(short)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        codehm"
               "        ptr_i[40]  = 8;                     /*head of entries for hm*/"
               "        ptr_i[41]  = nu*nu2*nz;"
               "        ptr_i[42]  = 1;"
               "        ptr_i[43]  = 2;"
               "        ptr_s      = (SCSINT16_COP *) &(ptr_i[44]);"
               "      }"
               "      else {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int)+4*sizeof(int)+ \"
               "                                              nz*nu*sizeof(short)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        ptr_i[6]   = 8;"
               "        ptr_i[7]   = nz;"
               "        ptr_i[8]   = nu;"
               "        ptr_i[9]   = 2;"
               "        ptr_s      = (SCSINT16_COP *) &(ptr_i[10]);"
               "      }"
               "      for (i=0;i<nu*nu2*nz;i++) {"
               "        ptr_s[i] = 0;"
               "      }"
               "      break;"
               ""
               "    case SCSINT32_N   :"
               "      if (ismat) {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int) + \"
               "                                             2*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (2+4+7)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (3)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             nz*nu*nu2*sizeof(long)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        codehm"
               "        ptr_i[40]  = 8;                     /*head of entries for hm*/"
               "        ptr_i[41]  = nu*nu2*nz;"
               "        ptr_i[42]  = 1;"
               "        ptr_i[43]  = 4;"
               "        ptr_l      = (SCSINT32_COP *) &(ptr_i[44]);"
               "      }"
               "      else {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int)+4*sizeof(int)+ \"
               "                                              nz*nu*sizeof(long)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        ptr_i[6]   = 8;"
               "        ptr_i[7]   = nz;"
               "        ptr_i[8]   = nu;"
               "        ptr_i[9]   = 4;"
               "        ptr_l      = (SCSINT32_COP *) &(ptr_i[10]);"
               "      }"
               "      for (i=0;i<nu*nu2*nz;i++) {"
               "        ptr_l[i] = 0;"
               "      }"
               "      break;"
               ""
               "    case SCSUINT8_N   :"
               "      if (ismat) {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int) + \"
               "                                             2*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (2+4+7)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (3)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             nz*nu*nu2*sizeof(unsigned char)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        codehm"
               "        ptr_i[40]  = 8;                     /*head of entries for hm*/"
               "        ptr_i[41]  = nu*nu2*nz;"
               "        ptr_i[42]  = 1;"
               "        ptr_i[43]  = 11;"
               "        ptr_uc     = (SCSUINT8_COP *) &(ptr_i[44]);"
               "      }"
               "      else {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int)+4*sizeof(int)+ \"
               "                                              nz*nu*sizeof(unsigned char)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i       = (int*) ptr->work;"
               "        ptr_i[6]    = 8;"
               "        ptr_i[7]    = nz;"
               "        ptr_i[8]    = nu;"
               "        ptr_i[9]    = 11;"
               "        ptr_uc      = (SCSUINT8_COP *) &(ptr_i[10]);"
               "      }"
               "      for (i=0;i<nu*nu2*nz;i++) {"
               "        ptr_uc[i] = 0;"
               "      }"
               "      break;"
               ""
               "    case SCSUINT16_N  :"
               "      if (ismat) {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int) + \"
               "                                             2*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (2+4+7)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (3)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             nz*nu*nu2*sizeof(unsigned short)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        codehm"
               "        ptr_i[40]  = 8;                     /*head of entries for hm*/"
               "        ptr_i[41]  = nu*nu2*nz;"
               "        ptr_i[42]  = 1;"
               "        ptr_i[43]  = 12;"
               "        ptr_us     = (SCSUINT16_COP *) &(ptr_i[44]);"
               "      }"
               "      else {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int)+4*sizeof(int)+ \"
               "                                              nz*nu*sizeof(unsigned short)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i = (int*) ptr->work;"
               "        ptr_i[6]    = 8;"
               "        ptr_i[7]    = nz;"
               "        ptr_i[8]    = nu;"
               "        ptr_i[9]    = 12;"
               "        ptr_us      = (SCSUINT16_COP *) &(ptr_i[10]);"
               "      }"
               "      for (i=0;i<nu*nu2*nz;i++) {"
               "        ptr_us[i] = 0;"
               "      }"
               "      break;"
               ""
               "    case SCSUINT32_N  :"
               "      if (ismat) {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int) + \"
               "                                             2*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (2+4+7)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             (3)*sizeof(int) + \"
               "                                             4*sizeof(int) + \"
               "                                             nz*nu*nu2*sizeof(unsigned long)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i      = (int*) ptr->work;"
               "        codehm"
               "        ptr_i[40]  = 8;                     /*head of entries for hm*/"
               "        ptr_i[41]  = nu*nu2*nz;"
               "        ptr_i[42]  = 1;"
               "        ptr_i[43]  = 14;"
               "        ptr_ul     = (SCSUINT32_COP *) &(ptr_i[44]);"
               "      }"
               "      else {"
               "        if((ptr->work=(void *) scicos_malloc(6*sizeof(int)+4*sizeof(int)+ \"
               "                                              nz*nu*sizeof(unsigned long)))==NULL) {"
               "          set_block_error(-16);"
               "          scicos_free(ptr->workt);"
               "          scicos_free(ptr);"
               "          *(_work) = NULL;"
               "          return;"
               "        }"
               "        ptr_i = (int*) ptr->work;"
               "        ptr_i[6]    = 8;"
               "        ptr_i[7]    = nz;"
               "        ptr_i[8]    = nu;"
               "        ptr_i[9]    = 14;"
               "        ptr_ul      = (SCSUINT32_COP *) &(ptr_i[10]);"
               "      }"
               "      for (i=0;i<nu*nu2*nz;i++) {"
               "        ptr_ul[i] = 0;"
               "      }"
               "      break;"
               ""
               "    default  : /* Add a message here */"
               "               break;"
               "   }"
               ""
               "   /* Scilab variable code name */"
               "   C2F(namstr)(id,(i=33,&i),(j=1,&j),(k=0,&k));"
               ""
               "   ptr_i    = (int*) ptr->work;"
               "   ptr_i[0] = id[0];"
               "   ptr_i[1] = id[1];"
               "   ptr_i[2] = id[2];"
               "   ptr_i[3] = id[3];"
               "   ptr_i[4] = id[4];"
               "   ptr_i[5] = id[5];"
               ""
               "   /*"
               "    * cnt"
               "    */"
               "   ptr->cnt = 0;"
               ""
               "   /*"
               "    * loop"
               "    */"
               "   ptr->loop = 0;"
               " }"
               ""
               " else if (flag==5) { /* finish */"
               ""
               "   ptr = *(_work);"
               ""
               "   if (ptr!=NULL) {"
               "     /* Put file name in str */"
               "     C2F(cvstr)(&(_ipar[1]),&(_ipar[2]),str,(j=1,&j), \"
               "                 (unsigned long)strlen(str));"
               "     str[_ipar[1]] = ''\0'';"
               ""
               "     /* retrieve path of TMPDIR/workspace */"
               "     strcpy(env,getenv(""TMPDIR""));"
               "     strcat(env,sep);"
               "     strcat(env,""Workspace"");"
               "     strcat(env,sep);"
               "     strcat(env,str);"
               ""
               "     /* open tmp file */"
               "     status = ""wb""; /* ""w"" : write */"
               "                    /* ""b"" : binary (required for Windows) */"
               "     lout   = FILENAME_MAX;"
               "     C2F(cluni0)(env, filename, &out_n,1,lout);"
               "     C2F(mopen)(&fd,env,status,&swap,&res,&ierr);"
               "     if (ierr != 0) {"
               "       Coserror(""Error when opening file ''%s''.\n"",str);"
               "       scicos_free(ptr->workt);"
               "       scicos_free(ptr);"
               "       *(_work) = NULL;"
               "       /*set_block_error(-3);*/"
               "       return;"
               "     }"
               ""
               "     /* check loop */"
               ""
               "     /* we don''t are at the end of the buffer :"
               "      * only first records will be saved"
               "      */"
               "     if ((ptr->cnt==0)&&(ptr->loop==0)) { /* nothing have been stored */"
               "       ptr_i = (int*) ptr->workt;"
               "       ptr_i[6] = 1;"
               "       ptr_i[7] = 0;"
               "       ptr_i[8] = 0;"
               "       ptr_i[9] = 0;"
               "       ptr_i = (int*) ptr->work;"
               "       ptr_i[6] = 1;"
               "       ptr_i[7] = 0;"
               "       ptr_i[8] = 0;"
               "       ptr_i[9] = 0;"
               "     }"
               "     if ((ptr->cnt!=0)&&(ptr->cnt!=nz)&&(ptr->loop==0)) { /* something stored */"
               "                                                          /* but we don''t are at the end */"
               "       ptr_i    = (int*) ptr->workt;"
               "       ptr_i[7] = ptr->cnt;"
               "       ptr_i    = (int*) ptr->work;"
               "       /* hmat */"
               "       if (ismat) {"
               "         ptr_i[39] = ptr->cnt;"
               "         ptr_i[41] = ptr->cnt*nu*nu2;"
               "       }"
               "       /* vector or matrix */"
               "       else {"
               "         /* vector case */"
               "         /* adjust only done for complex numbers */"
               "         if (ptr_i[8] == 1) {"
               "           switch (ut) {"
               "             case SCSCOMPLEX_N :"
               "                for(j=0;j<ptr->cnt;j++) {"
               "                  *((double *)(&ptr_i[10]) + (j+ptr->cnt)) = \"
               "                      *((double *)(&ptr_i[10]) + (j+nz*nu));"
               "                }"
               "               break;"
               "           }"
               "         }"
               "         /* matrix case */"
               "         else {"
               "           /* */"
               "           k=nz-ptr->cnt;"
               "           /* */"
               "           switch (ut) {"
               "             case SCSREAL_N    :"
               "                for(i=0;i<ptr_i[8]-1;i++) {"
               "                  for(j=0;j<ptr->cnt;j++) {"
               "                    *((double *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \"
               "                         *((double *)(&ptr_i[10]) + (((i+1)*nz)+j));"
               "                  }"
               "                }"
               "               break;"
               ""
               "             case SCSCOMPLEX_N :"
               "                for(i=0;i<ptr_i[8]-1;i++) {"
               "                  for(j=0;j<ptr->cnt;j++) {"
               "                    *((double *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \"
               "                         *((double *)(&ptr_i[10]) + (((i+1)*nz)+j));"
               "                    *((double *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)+nz*nu) = \"
               "                         *((double *)(&ptr_i[10]) + (((i+1)*nz)+j)+nz*nu);"
               "                  }"
               "                }"
               "               break;"
               ""
               "             case SCSINT8_N :"
               "                for(i=0;i<ptr_i[8]-1;i++) {"
               "                  for(j=0;j<ptr->cnt;j++) {"
               "                    *((char *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \"
               "                         *((char *)(&ptr_i[10]) + (((i+1)*nz)+j));"
               "                  }"
               "                }"
               "               break;"
               ""
               "             case SCSINT16_N :"
               "                for(i=0;i<ptr_i[8]-1;i++) {"
               "                  for(j=0;j<ptr->cnt;j++) {"
               "                    *((short *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \"
               "                         *((short *)(&ptr_i[10]) + (((i+1)*nz)+j));"
               "                  }"
               "                }"
               "               break;"
               ""
               "             case SCSINT32_N :"
               "                for(i=0;i<ptr_i[8]-1;i++) {"
               "                  for(j=0;j<ptr->cnt;j++) {"
               "                    *((long *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \"
               "                         *((long *)(&ptr_i[10]) + (((i+1)*nz)+j));"
               "                  }"
               "                }"
               "               break;"
               ""
               "             case SCSUINT8_N :"
               "                for(i=0;i<ptr_i[8]-1;i++) {"
               "                  for(j=0;j<ptr->cnt;j++) {"
               "                    *((unsigned char *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \"
               "                         *((unsigned char *)(&ptr_i[10]) + (((i+1)*nz)+j));"
               "                  }"
               "                }"
               "               break;"
               ""
               "             case SCSUINT16_N :"
               "                for(i=0;i<ptr_i[8]-1;i++) {"
               "                  for(j=0;j<ptr->cnt;j++) {"
               "                    *((unsigned short *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \"
               "                         *((unsigned short *)(&ptr_i[10]) + (((i+1)*nz)+j));"
               "                  }"
               "                }"
               "               break;"
               ""
               "             case SCSUINT32_N :"
               "                for(i=0;i<ptr_i[8]-1;i++) {"
               "                  for(j=0;j<ptr->cnt;j++) {"
               "                    *((unsigned long *)(&ptr_i[10]) + (((i+1)*nz)+j-(i+1)*k)) = \"
               "                         *((unsigned long *)(&ptr_i[10]) + (((i+1)*nz)+j));"
               "                  }"
               "                }"
               "               break;"
               ""
               "           }"
               "         }"
               "         ptr_i[7] = ptr->cnt;"
               "       }"
               "     }"
               "     /* sort data */"
               "     else if ((ptr->cnt!=0)&&(ptr->cnt!=nz)&&(ptr->loop!=0)) {"
               "       /* shift time data */"
               "       for(i=0;i<(nz-ptr->cnt);i++) {"
               "         ptr_i = (int*) ptr->workt;"
               "         sav_t = *((double *)(&ptr_i[10])+(nz-1));"
               "         for (j=(nz-1);j>=1;j--) {"
               "           *((double *)(&ptr_i[10])+j)=*((double *)(&ptr_i[10])+(j-1));"
               "         }"
               "         *((double *)(&ptr_i[10]))=sav_t;"
               "       }"
               "       /* shift x data */"
               "       switch (ut) {"
               "        case SCSREAL_N    :"
               "          if((sav_d=(double *) scicos_malloc(nu*nu2*sizeof(double)))==NULL) {"
               "            set_block_error(-16);"
               "            scicos_free(ptr->workt);"
               "            scicos_free(ptr);"
               "            *(_work) = NULL;"
               "            return;"
               "          }"
               "          ptr_i = (int*) ptr->work;"
               "          if (ismat) {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu*nu2;k++) {"
               "                sav_d[k] = *((double *)(&ptr_i[44])+k+(nz-1)*nu*nu2);"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu*nu2;k++) {"
               "                  *((double *)(&ptr_i[44])+k+j*(nu*nu2))=*((double *)(&ptr_i[44])+k+(j-1)*(nu*nu2));"
               "                }"
               "              }"
               "              for (k=0;k<nu*nu2;k++) {"
               "                *((double *)(&ptr_i[44])+k)  = sav_d[k];"
               "              }"
               "            }"
               "          }"
               "          else {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu;k++) {"
               "                sav_d[k] = *((double *)(&ptr_i[10])+k*nz+(nz-1));"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu;k++) {"
               "                  *((double *)(&ptr_i[10])+k*nz+j)=*((double *)(&ptr_i[10])+k*nz+j-1);"
               "                }"
               "              }"
               "              for (k=0;k<nu;k++) {"
               "                *((double *)(&ptr_i[10])+k*nz)  = sav_d[k];"
               "              }"
               "            }"
               "          }"
               "          scicos_free(sav_d);"
               "          break;"
               "        case SCSCOMPLEX_N :"
               "          if((sav_d=(double *) scicos_malloc(2*nu*nu2*sizeof(double)))==NULL) {"
               "            set_block_error(-16);"
               "            scicos_free(ptr->workt);"
               "            scicos_free(ptr);"
               "            *(_work) = NULL;"
               "            return;"
               "          }"
               "          ptr_i = (int *) ptr->work;"
               "          if (ismat) {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu*nu2;k++) {"
               "                sav_d[k]        = *((double *)(&ptr_i[44])+k+(nz-1)*nu*nu2);"
               "                sav_d[k+nu*nu2] = *((double *)(&ptr_i[44])+k+(nz-1)*nu*nu2+nz*nu*nu2);"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu*nu2;k++) {"
               "                  *((double *)(&ptr_i[44])+k+j*(nu*nu2))= \"
               "                       *((double *)(&ptr_i[44])+k+(j-1)*(nu*nu2));"
               "                  *((double *)(&ptr_i[44])+k+j*(nu*nu2)+nz*nu*nu2)= \"
               "                       *((double *)(&ptr_i[44])+k+(j-1)*(nu*nu2)+nz*nu*nu2);"
               "                }"
               "              }"
               "              for (k=0;k<nu*nu2;k++) {"
               "                *((double *)(&ptr_i[44])+k)           = sav_d[k];"
               "                *((double *)(&ptr_i[44])+k+nz*nu*nu2) = sav_d[k+nu*nu2];"
               "              }"
               "            }"
               "          }"
               "          else {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu;k++) {"
               "                sav_d[k]    = *((double *)(&ptr_i[10])+k*nz+(nz-1));"
               "                sav_d[k+nu] = *((double *)(&ptr_i[10])+k*nz+(nz-1)+nz*nu);"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu;k++) {"
               "                  *((double *)(&ptr_i[10])+k*nz+j)= \"
               "                       *((double *)(&ptr_i[10])+k*nz+j-1);"
               "                  *((double *)(&ptr_i[10])+k*nz+j+nz*nu)= \"
               "                       *((double *)(&ptr_i[10])+k*nz+j-1+nz*nu);"
               "                }"
               "              }"
               "              for (k=0;k<nu;k++) {"
               "                *((double *)(&ptr_i[10])+k*nz)        = sav_d[k];"
               "                *((double *)(&ptr_i[10])+k*nz+nz*nu)  = sav_d[k+nu];"
               "              }"
               "            }"
               "          }"
               "          scicos_free(sav_d);"
               "          break;"
               "        case SCSINT8_N    :"
               "          if((sav_c=(char *) scicos_malloc(nu*nu2*sizeof(char)))==NULL) {"
               "            set_block_error(-16);"
               "            scicos_free(ptr->workt);"
               "            scicos_free(ptr);"
               "            *(_work) = NULL;"
               "            return;"
               "          }"
               "          ptr_i = (int *) ptr->work;"
               "          if (ismat) {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu*nu2;k++) {"
               "                sav_c[k] = *((char *)(&ptr_i[44])+k+(nz-1)*nu*nu2);"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu*nu2;k++) {"
               "                  *((char *)(&ptr_i[44])+k+j*(nu*nu2))=*((char *)(&ptr_i[44])+k+(j-1)*(nu*nu2));"
               "                }"
               "              }"
               "              for (k=0;k<nu*nu2;k++) {"
               "                *((char *)(&ptr_i[44])+k)  = sav_c[k];"
               "              }"
               "            }"
               "          }"
               "          else {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu;k++) {"
               "                sav_c[k] = *((char *)(&ptr_i[10])+k*nz+(nz-1));"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu;k++) {"
               "                  *((char *)(&ptr_i[10])+k*nz+j)=*((char *)(&ptr_i[10])+k*nz+j-1);"
               "                }"
               "              }"
               "              for (k=0;k<nu;k++) {"
               "                *((char *)(&ptr_i[10])+k*nz)  = sav_c[k];"
               "              }"
               "            }"
               "          }"
               "          scicos_free(sav_c);"
               "          break;"
               "        case SCSINT16_N   :"
               "          if((sav_s=(short *) scicos_malloc(nu*nu2*sizeof(short)))==NULL) {"
               "            set_block_error(-16);"
               "            scicos_free(ptr->workt);"
               "            scicos_free(ptr);"
               "            *(_work) = NULL;"
               "            return;"
               "          }"
               "          ptr_i = (int *) ptr->work;"
               "          if (ismat) {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu*nu2;k++) {"
               "                sav_s[k] = *((short *)(&ptr_i[44])+k+(nz-1)*nu*nu2);"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu*nu2;k++) {"
               "                  *((short *)(&ptr_i[44])+k+j*(nu*nu2))=*((short *)(&ptr_i[44])+k+(j-1)*(nu*nu2));"
               "                }"
               "              }"
               "              for (k=0;k<nu*nu2;k++) {"
               "                *((short *)(&ptr_i[44])+k)  = sav_s[k];"
               "              }"
               "            }"
               "          }"
               "          else {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu;k++) {"
               "                sav_s[k] = *((short *)(&ptr_i[10])+k*nz+(nz-1));"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu;k++) {"
               "                  *((short *)(&ptr_i[10])+k*nz+j)=*((short *)(&ptr_i[10])+k*nz+j-1);"
               "                }"
               "              }"
               "              for (k=0;k<nu;k++) {"
               "                *((short *)(&ptr_i[10])+k*nz)  = sav_s[k];"
               "              }"
               "            }"
               "          }"
               "          scicos_free(sav_s);"
               "          break;"
               "        case SCSINT32_N   :"
               "          if((sav_l=(long *) scicos_malloc(nu*nu2*sizeof(long)))==NULL) {"
               "            set_block_error(-16);"
               "            scicos_free(ptr->workt);"
               "            scicos_free(ptr);"
               "            *(_work) = NULL;"
               "            return;"
               "          }"
               "          ptr_i = (int *) ptr->work;"
               "          if (ismat) {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu*nu2;k++) {"
               "                sav_l[k] = *((long *)(&ptr_i[44])+k+(nz-1)*nu*nu2);"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu*nu2;k++) {"
               "                  *((long *)(&ptr_i[44])+k+j*(nu*nu2))=*((long *)(&ptr_i[44])+k+(j-1)*(nu*nu2));"
               "                }"
               "              }"
               "              for (k=0;k<nu*nu2;k++) {"
               "                *((long *)(&ptr_i[44])+k)  = sav_l[k];"
               "              }"
               "            }"
               "          }"
               "          else {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu;k++) {"
               "                sav_l[k] = *((long *)(&ptr_i[10])+k*nz+(nz-1));"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu;k++) {"
               "                  *((long *)(&ptr_i[10])+k*nz+j)=*((long *)(&ptr_i[10])+k*nz+j-1);"
               "                }"
               "              }"
               "              for (k=0;k<nu;k++) {"
               "                *((long *)(&ptr_i[10])+k*nz)  = sav_l[k];"
               "              }"
               "            }"
               "          }"
               "          scicos_free(sav_l);"
               "          break;"
               "        case SCSUINT8_N   :"
               "          if((sav_uc=(unsigned char *) scicos_malloc(nu*nu2*sizeof(unsigned char)))==NULL) {"
               "            set_block_error(-16);"
               "            scicos_free(ptr->workt);"
               "            scicos_free(ptr);"
               "            *(_work) = NULL;"
               "            return;"
               "          }"
               "          ptr_i = (int *) ptr->work;"
               "          if (ismat) {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu*nu2;k++) {"
               "                sav_uc[k] = *((unsigned char *)(&ptr_i[44])+k+(nz-1)*nu*nu2);"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu*nu2;k++) {"
               "                  *((unsigned char *)(&ptr_i[44])+k+j*(nu*nu2))=*((unsigned char *)(&ptr_i[44])+k+(j-1)*(nu*nu2));"
               "                }"
               "              }"
               "              for (k=0;k<nu*nu2;k++) {"
               "                *((unsigned char *)(&ptr_i[44])+k)  = sav_uc[k];"
               "              }"
               "            }"
               "          }"
               "          else {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu;k++) {"
               "                sav_uc[k] = *((unsigned char *)(&ptr_i[10])+k*nz+(nz-1));"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu;k++) {"
               "                  *((unsigned char *)(&ptr_i[10])+k*nz+j)=*((unsigned char *)(&ptr_i[10])+k*nz+j-1);"
               "                }"
               "              }"
               "              for (k=0;k<nu;k++) {"
               "                *((unsigned char *)(&ptr_i[10])+k*nz)  = sav_uc[k];"
               "              }"
               "            }"
               "          }"
               "          scicos_free(sav_uc);"
               "          break;"
               "        case SCSUINT16_N  :"
               "          if((sav_us=(unsigned short *) scicos_malloc(nu*nu2*sizeof(unsigned short)))==NULL) {"
               "            set_block_error(-16);"
               "            scicos_free(ptr->workt);"
               "            scicos_free(ptr);"
               "            *(_work) = NULL;"
               "            return;"
               "          }"
               "          ptr_i = (int *) ptr->work;"
               "          if (ismat) {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu*nu2;k++) {"
               "                sav_us[k] = *((unsigned short *)(&ptr_i[44])+k+(nz-1)*nu*nu2);"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu*nu2;k++) {"
               "                  *((unsigned short *)(&ptr_i[44])+k+j*(nu*nu2))=*((unsigned short *)(&ptr_i[44])+k+(j-1)*(nu*nu2));"
               "                }"
               "              }"
               "              for (k=0;k<nu*nu2;k++) {"
               "                *((unsigned short *)(&ptr_i[44])+k)  = sav_us[k];"
               "              }"
               "            }"
               "          }"
               "          else {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu;k++) {"
               "                sav_us[k] = *((unsigned short *)(&ptr_i[10])+k*nz+(nz-1));"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu;k++) {"
               "                  *((unsigned short *)(&ptr_i[10])+k*nz+j)=*((unsigned short *)(&ptr_i[10])+k*nz+j-1);"
               "                }"
               "              }"
               "              for (k=0;k<nu;k++) {"
               "                *((unsigned short *)(&ptr_i[10])+k*nz)  = sav_us[k];"
               "              }"
               "            }"
               "          }"
               "          scicos_free(sav_us);"
               "          break;"
               "        case SCSUINT32_N  :"
               "          if((sav_ul=(unsigned long *) scicos_malloc(nu*nu2*sizeof(unsigned long)))==NULL) {"
               "            set_block_error(-16);"
               "            scicos_free(ptr->workt);"
               "            scicos_free(ptr);"
               "            *(_work) = NULL;"
               "            return;"
               "          }"
               "          ptr_i = (int *) ptr->work;"
               "          if (ismat) {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu*nu2;k++) {"
               "                sav_ul[k] = *((unsigned long *)(&ptr_i[44])+k+(nz-1)*nu*nu2);"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu*nu2;k++) {"
               "                  *((unsigned long *)(&ptr_i[44])+k+j*(nu*nu2))=*((unsigned long *)(&ptr_i[44])+k+(j-1)*(nu*nu2));"
               "                }"
               "              }"
               "              for (k=0;k<nu*nu2;k++) {"
               "                *((unsigned long *)(&ptr_i[44])+k)  = sav_ul[k];"
               "              }"
               "            }"
               "          }"
               "          else {"
               "            for(i=0;i<(nz-ptr->cnt);i++) {"
               "              for (k=0;k<nu;k++) {"
               "                sav_ul[k] = *((unsigned long *)(&ptr_i[10])+k*nz+(nz-1));"
               "              }"
               "              for (j=(nz-1);j>=1;j--) {"
               "                for (k=0;k<nu;k++) {"
               "                  *((unsigned long *)(&ptr_i[10])+k*nz+j)=*((unsigned long *)(&ptr_i[10])+k*nz+j-1);"
               "                }"
               "              }"
               "              for (k=0;k<nu;k++) {"
               "                *((unsigned long *)(&ptr_i[10])+k*nz)  = sav_ul[k];"
               "              }"
               "            }"
               "          }"
               "          scicos_free(sav_ul);"
               "          break;"
               "        default  : /* Add a message here */"
               "                   break;"
               "       }"
               "     }"
               ""
               "     /* write x */"
               "     ptr_i = (int*) ptr->work;"
               "     C2F(mputnc)(&fd, &ptr_i[0], (j=nsiz,&j), fmti, &ierr); /* write sci id */"
               "     if (ierr != 0) {"
               "       Coserror(""Write error in file ''%s''.\n"",str);"
               "       scicos_free(ptr->workt);"
               "       scicos_free(ptr);"
               "       *(_work) = NULL;"
               "       /*set_block_error(-3);*/"
               "       return;"
               "     }"
               "     C2F(mputnc)(&fd, &ptr_i[6], (j=1,&j), fmti, &ierr);    /* write sci type */"
               "     if (ierr != 0) {"
               "       Coserror(""Write error in file ''%s''.\n"",str);"
               "       scicos_free(ptr->workt);"
               "       scicos_free(ptr);"
               "       *(_work) = NULL;"
               "       /*set_block_error(-3);*/"
               "       return;"
               "     }"
               "     if ((ptr->cnt==0)&&(ptr->loop==0)) {"
               "       C2F(mputnc)(&fd, &ptr_i[7], (j=3,&j), fmti, &ierr);    /* write sci header */"
               "     }"
               "     else {"
               "       if (ismat) {"
               "         C2F(mputnc)(&fd, &ptr_i[7], (j=37,&j), fmti, &ierr);    /* write sci header */"
               "       }"
               "       else {"
               "         C2F(mputnc)(&fd, &ptr_i[7], (j=3,&j), fmti, &ierr);    /* write sci header */"
               "       }"
               "     }"
               "     if (ierr != 0) {"
               "       Coserror(""Write error in file ''%s''.\n"",str);"
               "       scicos_free(ptr->workt);"
               "       scicos_free(ptr);"
               "       *(_work) = NULL;"
               "       /*set_block_error(-3);*/"
               "       return;"
               "     }"
               "     if ((ptr->cnt!=0)||(ptr->loop!=0)) {"
               "       /* write data */"
               "       switch (ut) {"
               "         case SCSREAL_N    :"
               "           if (ismat) {"
               "             C2F(mputnc)(&fd, &ptr_i[44], (j=ptr_i[37]*ptr_i[38]*ptr_i[39],&j), fmtd, &ierr);"
               "           }"
               "           else {"
               "             C2F(mputnc)(&fd, &ptr_i[10], (j=ptr_i[7]*ptr_i[8],&j), fmtd, &ierr);"
               "           }"
               "           break;"
               "         case SCSCOMPLEX_N :"
               "           if (ismat) {"
               "             C2F(mputnc)(&fd, &ptr_i[44], (j=2*ptr_i[37]*ptr_i[38]*ptr_i[39],&j), fmtd, &ierr);"
               "           }"
               "           else {"
               "             C2F(mputnc)(&fd, &ptr_i[10], (j=2*ptr_i[7]*ptr_i[8],&j), fmtd, &ierr);"
               "           }"
               "           break;"
               "         case SCSINT8_N    :"
               "           if (ismat) {"
               "             C2F(mputnc)(&fd, &ptr_i[44], (j=ptr_i[37]*ptr_i[38]*ptr_i[39],&j), fmtc, &ierr);"
               "           }"
               "           else {"
               "             C2F(mputnc)(&fd, &ptr_i[10], (j=ptr_i[7]*ptr_i[8],&j), fmtc, &ierr);"
               "           }"
               "           break;"
               "         case SCSINT16_N   :"
               "           if (ismat) {"
               "             C2F(mputnc)(&fd, &ptr_i[44], (j=ptr_i[37]*ptr_i[38]*ptr_i[39],&j), fmts, &ierr);"
               "           }"
               "           else {"
               "             C2F(mputnc)(&fd, &ptr_i[10], (j=ptr_i[7]*ptr_i[8],&j), fmts, &ierr);"
               "           }"
               "           break;"
               "         case SCSINT32_N   :"
               "           if (ismat) {"
               "             C2F(mputnc)(&fd, &ptr_i[44], (j=ptr_i[37]*ptr_i[38]*ptr_i[39],&j), fmtl, &ierr);"
               "           }"
               "           else {"
               "             C2F(mputnc)(&fd, &ptr_i[10], (j=ptr_i[7]*ptr_i[8],&j), fmtl, &ierr);"
               "           }"
               "           break;"
               "         case SCSUINT8_N   :"
               "           if (ismat) {"
               "             C2F(mputnc)(&fd, &ptr_i[44], (j=ptr_i[37]*ptr_i[38]*ptr_i[39],&j), fmtuc, &ierr);"
               "           }"
               "           else {"
               "             C2F(mputnc)(&fd, &ptr_i[10], (j=ptr_i[7]*ptr_i[8],&j), fmtuc, &ierr);"
               "           }"
               "           break;"
               "         case SCSUINT16_N  :"
               "           if (ismat) {"
               "             C2F(mputnc)(&fd, &ptr_i[44], (j=ptr_i[37]*ptr_i[38]*ptr_i[39],&j), fmtus, &ierr);"
               "           }"
               "           else {"
               "             C2F(mputnc)(&fd, &ptr_i[10], (j=ptr_i[7]*ptr_i[8],&j), fmtus, &ierr);"
               "           }"
               "           break;"
               "         case SCSUINT32_N  :"
               "           if (ismat) {"
               "             C2F(mputnc)(&fd, &ptr_i[44], (j=ptr_i[37]*ptr_i[38]*ptr_i[39],&j), fmtul, &ierr);"
               "           }"
               "           else {"
               "             C2F(mputnc)(&fd, &ptr_i[10], (j=ptr_i[7]*ptr_i[8],&j), fmtul, &ierr);"
               "           }"
               "           break;"
               "         default  : /* Add a message here */"
               "                   break;"
               "       }"
               "       if (ierr != 0) {"
               "         Coserror(""Write error in file ''%s''.\n"",str);"
               "         scicos_free(ptr->workt);"
               "         scicos_free(ptr);"
               "         *(_work) = NULL;"
               "         /*set_block_error(-3);*/"
               "         return;"
               "       }"
               "     }"
               ""
               "     /* write t */"
               "     ptr_i = (int*) ptr->workt;"
               "     C2F(mputnc)(&fd, &ptr_i[0], (j=nsiz,&j), fmti, &ierr);"
               "     if (ierr != 0) {"
               "       Coserror(""Write error in file ''%s''.\n"",str);"
               "       scicos_free(ptr->workt);"
               "       scicos_free(ptr);"
               "       *(_work) = NULL;"
               "       /*set_block_error(-3);*/"
               "       return;"
               "     }"
               "     C2F(mputnc)(&fd, &ptr_i[6], (j=1,&j), fmti, &ierr);"
               "     if (ierr != 0) {"
               "       Coserror(""Write error in file ''%s''.\n"",str);"
               "       scicos_free(ptr->workt);"
               "       scicos_free(ptr);"
               "       *(_work) = NULL;"
               "       /*set_block_error(-3);*/"
               "       return;"
               "     }"
               "     C2F(mputnc)(&fd, &ptr_i[7], (j=3,&j), fmti, &ierr);"
               "     if (ierr != 0) {"
               "       Coserror(""Write error in file ''%s''.\n"",str);"
               "       scicos_free(ptr->workt);"
               "       scicos_free(ptr);"
               "       *(_work) = NULL;"
               "       /*set_block_error(-3);*/"
               "       return;"
               "     }"
               "     if ((ptr->cnt!=0)||(ptr->loop!=0)) {"
               "       C2F(mputnc)(&fd, &ptr_i[10], (j=ptr_i[7],&j), fmtd, &ierr);"
               "       if (ierr != 0) {"
               "         Coserror(""Write error in file ''%s''.\n"",str);"
               "         scicos_free(ptr->workt);"
               "         scicos_free(ptr);"
               "         *(_work) = NULL;"
               "         /*set_block_error(-3);*/"
               "         return;"
               "       }"
               "     }"
               ""
               "     /* close tmp file */"
               "     C2F(mclose)(&fd,&res);"
               ""
               "     /* free */"
               "     scicos_free(ptr->work);"
               "     scicos_free(ptr->workt);"
               "     scicos_free(ptr);"
               "   }"
               ""
               " }"
               ""
               " else if ((flag==2)||(flag==0)) { /* update state */"
               ""
               "   ptr = *(_work);"
               ""
               "   ptr_i = (int*) ptr->work;"
               ""
               "   /* check data dimension */"
               "   if (ismat) {"
               "     if ((nz!=ptr_i[39]) || (nu!=ptr_i[37]) || (nu2!=ptr_i[38])) {"
               "       Coserror(""Size of buffer or input size have changed!\n"");"
               "       /*set_block_error(-1);*/"
               "       return;"
               "     }"
               "   }"
               "   else {"
               "     if ((nz!=ptr_i[7]) || (nu!=ptr_i[8])) {"
               "       Coserror(""Size of buffer or input size have changed!\n"");"
               "       /*set_block_error(-1);*/"
               "       return;"
               "     }"
               "   }"
               ""
               "   /*"
               "    * test on time"
               "    */"
               ""
               "   ptr_i = (int*) ptr->workt;"
               "   ptr_d = (SCSREAL_COP *) &(ptr_i[10]);"
               ""
               "   /* get current time */"
               "   t     = get_scicos_time();"
               ""
               "   /* get old time */"
               "   if (ptr->cnt==0) {"
               "     t_old = ptr_d[nz-1];"
               "   }"
               "   else {"
               "     t_old = ptr_d[ptr->cnt-1];"
               "   }"
               ""
               "   /* get current index of cnt */"
               "   while (t_old>=t) { /*decrease*/"
               "     if (ptr->cnt == 0) {"
               "       ptr->cnt = nz-1;"
               "     }"
               "     else {"
               "       ptr->cnt = ptr->cnt - 1;"
               "     }"
               ""
               "     /* get old time */"
               "     if (ptr->cnt==0) {"
               "       t_old = ptr_d[nz-1];"
               "     }"
               "     else {"
               "       t_old = ptr_d[ptr->cnt-1];"
               "     }"
               "   }"
               "   /*fprintf(stderr,""flag=%d, ptr->cnt=%d, t=%20.18f, t_old=%20.18f, t_old>=t=%d\n"",flag,ptr->cnt,t,t_old,t_old>=t);*/"
               ""
               "   /*"
               "    *store"
               "    */"
               ""
               "   ptr_i = (int*) ptr->work;"
               ""
               "   /* x */"
               "   switch (ut)"
               "   {"
               "    case SCSREAL_N    :"
               "      u_d   = GetRealInPortPtrs(block,1);"
               "      if (ismat) {"
               "        ptr_d = (SCSREAL_COP *) &(ptr_i[44]);"
               "        for (i=0;i<nu*nu2;i++) {"
               "          ptr_d[ptr->cnt*(nu*nu2)+i] = u_d[i];"
               "        }"
               "      }"
               "      else {"
               "        ptr_d = (SCSREAL_COP *) &(ptr_i[10]);"
               "        for (i=0;i<nu*nu2;i++) {"
               "          ptr_d[ptr->cnt+i*nz] = u_d[i];"
               "        }"
               "      }"
               "      break;"
               ""
               "    case SCSCOMPLEX_N :"
               "      u_d  = GetRealInPortPtrs(block,1);"
               "      u_cd = GetImagInPortPtrs(block,1);"
               "      if (ismat) {"
               "        ptr_d = (SCSREAL_COP *) &(ptr_i[44]);"
               "        for (i=0;i<nu*nu2;i++) {"
               "          ptr_d[ptr->cnt*(nu*nu2)+i] = u_d[i];"
               "          ptr_d[nz*nu*nu2+ptr->cnt*(nu*nu2)+i] = u_cd[i];"
               "        }"
               "      }"
               "      else {"
               "        ptr_d = (SCSREAL_COP *) &(ptr_i[10]);"
               "        for (i=0;i<nu;i++) {"
               "          ptr_d[ptr->cnt+i*nz]       = u_d[i];"
               "          ptr_d[nz*nu+ptr->cnt+i*nz] = u_cd[i];"
               "        }"
               "      }"
               "      break;"
               ""
               "    case SCSINT8_N    :"
               "      u_c   = Getint8InPortPtrs(block,1);"
               "      if (ismat) {"
               "        ptr_c = (SCSINT8_COP *) &(ptr_i[44]);"
               "        for (i=0;i<nu*nu2;i++) {"
               "          ptr_c[ptr->cnt*(nu*nu2)+i] = u_c[i];"
               "        }"
               "      }"
               "      else {"
               "        ptr_c = (SCSINT8_COP *) &(ptr_i[10]);"
               "        for (i=0;i<nu;i++) {"
               "          ptr_c[ptr->cnt+i*nz] = u_c[i];"
               "        }"
               "      }"
               "      break;"
               ""
               "    case SCSINT16_N   :"
               "      u_s   = Getint16InPortPtrs(block,1);"
               "      if (ismat) {"
               "        ptr_s = (SCSINT16_COP *) &(ptr_i[44]);"
               "        for (i=0;i<nu*nu2;i++) {"
               "          ptr_s[ptr->cnt*(nu*nu2)+i] = u_s[i];"
               "        }"
               "      }"
               "      else {"
               "        ptr_s = (SCSINT16_COP *) &(ptr_i[10]);"
               "        for (i=0;i<nu;i++) {"
               "          ptr_s[ptr->cnt*nu+i*nz] = u_s[i];"
               "        }"
               "      }"
               "      break;"
               ""
               "    case SCSINT32_N   :"
               "      u_l   = Getint32InPortPtrs(block,1);"
               "      if (ismat) {"
               "        ptr_l = (SCSINT32_COP *) &(ptr_i[44]);"
               "        for (i=0;i<nu*nu2;i++) {"
               "          ptr_l[ptr->cnt*(nu*nu2)+i] = u_l[i];"
               "        }"
               "      }"
               "      else {"
               "        ptr_l = (SCSINT32_COP *) &(ptr_i[10]);"
               "        for (i=0;i<nu;i++) {"
               "          ptr_l[ptr->cnt+i*nz] = u_l[i];"
               "        }"
               "      }"
               "      break;"
               ""
               "    case SCSUINT8_N   :"
               "      u_uc   = Getuint8InPortPtrs(block,1);"
               "      if (ismat) {"
               "        ptr_uc = (SCSUINT8_COP *) &(ptr_i[44]);"
               "        for (i=0;i<nu*nu2;i++) {"
               "          ptr_uc[ptr->cnt*(nu*nu2)+i] = u_uc[i];"
               "        }"
               "      }"
               "      else {"
               "        ptr_uc = (SCSUINT8_COP *) &(ptr_i[10]);"
               "        for (i=0;i<nu;i++) {"
               "          ptr_uc[ptr->cnt+i*nz] = u_uc[i];"
               "        }"
               "      }"
               "      break;"
               ""
               "    case SCSUINT16_N  :"
               "      u_us   = Getuint16InPortPtrs(block,1);"
               "      if (ismat) {"
               "        ptr_us = (SCSUINT16_COP *) &(ptr_i[44]);"
               "        for (i=0;i<nu*nu2;i++) {"
               "          ptr_us[ptr->cnt*(nu*nu2)+i] = u_us[i];"
               "        }"
               "      }"
               "      else {"
               "        ptr_us = (SCSUINT16_COP *) &(ptr_i[10]);"
               "        for (i=0;i<nu;i++) {"
               "          ptr_us[ptr->cnt+i*nz] = u_us[i];"
               "        }"
               "      }"
               "      break;"
               ""
               "    case SCSUINT32_N  :"
               "      u_ul = Getuint32InPortPtrs(block,1);"
               "      if (ismat) {"
               "        ptr_ul = (SCSUINT32_COP *) &(ptr_i[44]);"
               "        for (i=0;i<nu*nu2;i++) {"
               "          ptr_ul[ptr->cnt*(nu*nu2)+i] = u_ul[i];"
               "        }"
               "      }"
               "      else {"
               "        ptr_ul = (SCSUINT32_COP *) &(ptr_i[10]);"
               "        for (i=0;i<nu;i++) {"
               "          ptr_ul[ptr->cnt+i*nz]=u_ul[i];"
               "        }"
               "      }"
               "      break;"
               ""
               "    default  : /* Add a message here */"
               "               break;"
               "   }"
               ""
               "   /* t */"
               "   ptr_i           = (int*) ptr->workt;"
               "   ptr_d           = (SCSREAL_COP *) &(ptr_i[10]);"
               "   ptr_d[ptr->cnt]  = t;"
               ""
               "   /*"
               "    * update cnt"
               "    */"
               "   ptr->cnt++;"
               "   if (ptr->cnt==nz) {"
               "     ptr->cnt = 0;"
               "     ptr->loop++;"
               "   }"
               " }"
               "}"]

      case 'variable_delay' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               "#include ""machine.h"""
               ""
               "#ifdef WIN32"
               "#ifndef NULL"
               "#define NULL    0"
               "#endif "
               "#define max(a,b) ((a) >= (b) ? (a) : (b))"
               "#define min(a,b) ((a) <= (b) ? (a) : (b))"
               "#endif"
               ""
               "extern void sciprint __PARAMS((char *fmt,...));"
               ""
               "void variable_delay(scicos_block *block,int flag)"
               "{/*  rpar[0]=max delay, rpar[1]=init value, ipar[0]=buffer length */"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  double *_rpar=GetRparPtrs(block);"
               "  int *_ipar=GetIparPtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  double *_u2=GetRealInPortPtrs(block,2);"
               "  double* pw,del,t,td;"
               "  int* iw;"
               "  int id, i, j, k;"
               "  if (flag == 4){/* the workspace is used to store previous values */"
               "    if ((*_work="
               "         scicos_malloc(sizeof(int)+sizeof(double)* "
               "                       _ipar[0]*(1+GetInPortRows(block,1))))== NULL ) {"
               "      set_block_error(-16);"
               "      return;"
               "    }"
               "    pw=*_work; "
               "    pw[0]=-_rpar[0]*_ipar[0];"
               "    for(i=1;i< _ipar[0];i++){"
               "      pw[i]=pw[i-1]+_rpar[0];"
               "      for(j=1;j< GetInPortRows(block,1)+1;j++){"
               "        pw[i+_ipar[0]*j]=_rpar[1];"
               "      }"
               "    }"
               "    iw=(int *) (pw+_ipar[0]*(1+GetInPortRows(block,1)));"
               "    *iw=0;"
               "  }else  if (flag == 5){"
               "    scicos_free(*_work);"
               "  } else if (flag==1) {"
               "    if (get_phase_simulation()==1) do_cold_restart();"
               "    pw=*_work; "
               "    iw=(int *) (pw+_ipar[0]*(1+GetInPortRows(block,1)));"
               "    t=get_scicos_time();"
               "    id=get_fcaller_id();"
               ""
               "    del=min(max(0,_u2[0]),_rpar[0]);"
               "    td=t-del;"
               "    if(td<pw[*iw]){"
               "      sciprint(""delayed time=%f but last stored time=%f \r\n"", td, pw[*iw]);"
               "      sciprint(""Consider increasing the length of buffer in variable delay block\r\n"");"
               "    }"
               "    if (id>0) {"
               "      if (t>pw[(_ipar[0]+*iw-1)%_ipar[0]]){"
               "        for(j=1;j< GetInPortRows(block,1)+1;j++){"
               "          pw[*iw +_ipar[0]*j]=_u1[j-1];"
               "        }"
               "        pw[*iw]=t;"
               "        *iw=(*iw+1)%_ipar[0];"
               "      }else{"
               "        for(j=1;j< GetInPortRows(block,1)+1;j++){"
               "          pw[(_ipar[0]+*iw-1)%_ipar[0] +_ipar[0]*j]=_u1[j-1];"
               "        }"
               "        pw[(_ipar[0]+*iw-1)%_ipar[0]]=t;"
               "      }"
               "    }"
               "    i=0;j= _ipar[0]-1;"
               ""
               "    while (j-i>1) {"
               "      k=(i+j)/2;"
               "      if (td<pw[(k+*iw)%_ipar[0]]) {"
               "        j=k;"
               "      }else if (td>pw[(k+*iw)%_ipar[0]]) {"
               "        i=k;"
               "      }else{"
               "        i=k;"
               "        j=k;"
               "        break;"
               "      }"
               "    }"
               "    i=(i+*iw)%_ipar[0];"
               "    j=(j+*iw)%_ipar[0];"
               "    del=pw[j]-pw[i];"
               "    if(del!=0.0){"
               "      for (k=1;k<GetInPortRows(block,1)+1;k++){"
               "        _y1[k-1]=((pw[j]-td)*pw[i+_ipar[0]*k] +"
               "                               (td-pw[i])*pw[j+_ipar[0]*k])/del;"
               "      }"
               "    }else{"
               "      for (k=1;k<GetInPortRows(block,1)+1;k++){"
               "        _y1[k-1]=pw[i+_ipar[0]*k];"
               "      }"
               "    }"
               "  }"
               "}"]

      case 'whileiterator' then
        txt = ["#include ""scicos_block4.h"""
               "#include <memory.h>"
               "/*typedef struct{"
               "  int so;"
               "  void **mem;"
               "  }foriter;*/"
               ""
               "void whileiterator(scicos_block *block,int flag)"
               "{ "
               "  void *y,*z;"
               "  int so;"
               "  z=GetOzPtrs(block,1);"
               "  so=GetSizeOfOut(block,1);"
               "  if (flag==1) {"
               "    y=GetOutPortPtrs(block,1);"
               "    memcpy(y,z,so);"
               "  }else if (flag==2){"
               "    if (so==1){"
               "      char *inp;"
               "      inp=(char *)z;"
               "      *inp=*inp+1;"
               "    }else if (so==2){"
               "      short *inp;"
               "      inp=(short *)z;"
               "      *inp=*inp+1;"
               "    }else if (so==4){"
               "      long *inp;"
               "      inp=(long *)z;"
               "      *inp=*inp+1;"
               "    }else if (so==8){"
               "      double *inp;"
               "      inp=(double *)z;"
               "      *inp=*inp+1;"
               "    }"
               "  }"
               "}"
               ""
               ""
               ""
               "  "]

      case 'absolute_value' then
        txt = ["#include ""scicos_block4.h"""
               "#include <math.h>"
               ""
               ""
               "void  absolute_value(scicos_block *block,int flag)"
               "{"
               "  int _ng=GetNg(block);"
               "  double *_g=GetGPtrs(block);"
               "  int *_mode=GetModePtrs(block);"
               "  double *_u1=GetRealInPortPtrs(block,1);"
               "  double *_y1=GetRealOutPortPtrs(block,1);"
               "  int i,j;"
               "  if (flag==1){"
               "    if( _ng>0){"
               "      for(i=0;i<GetInPortRows(block,1);++i){"
               "        if (get_phase_simulation()==1) {"
               "          if (_u1[i]<0){"
               "            j=2;"
               "          } else{"
               "            j=1;"
               "          }"
               "        }else {"
               "          j=_mode[i];"
               "        }"
               "        if (j==1){"
               "          _y1[i]=_u1[i];"
               "        } else{"
               "          _y1[i]=-_u1[i];"
               "        }"
               "      }"
               "    }else{"
               "      for(i=0;i<GetInPortRows(block,1);++i){"
               "        if (_u1[i]<0){"
               "          _y1[i]=-_u1[i];"
               "        }else{"
               "          _y1[i]=_u1[i];"
               "        }"
               "      }"
               "    }"
               "  }else if (flag==9){"
               "    for(i=0;i<GetInPortRows(block,1);++i){"
               "      _g[i]=_u1[i];"
               "      if (get_phase_simulation()==1) {"
               "        if(_g[i]<0){"
               "          _mode[i]=2;"
               "        }else{"
               "          _mode[i]=1;"
               "        }"
               "      }"
               "    }"
               "  }"
               "}"]

      case 'assignment' then
        txt = ["#include ""scicos_block4.h"""
               "#include <stdio.h>"
               "#include <memory.h>"
               ""
               "void assignment(scicos_block *block,int flag)"
               "{"
               "  void **_work=GetPtrWorkPtrs(block);"
               "  int my,ny,so;"
               "  double *out0;"
               "  my=GetOutPortRows(block,1);"
               "  ny=GetOutPortCols(block,1);"
               "  out0=GetRealOparPtrs(block,6);"
               "  so=GetSizeOfOut(block,1);  "
               "  if (flag==4){"
               "    /*array that contains "
               "      1 - the size of the indx1"
               "      2 - indx1"
               "      3 - the size of index2"
               "      4 - index2"
               "    */"
               "    if((*(_work)=scicos_malloc((my+ny+2)*sizeof(int)))==NULL)"
               "      {set_block_error(-16);"
               "        return;}"
               ""
               "  }"
               ""
               "  else if (flag==1){"
               "    double *otsz, *indxopt, *indxb, *indx1, *indx2;"
               "    int typ,i,j,nev;"
               "    int *tempind1,*tempind2;"
               "    tempind1=(int *)*(_work);"
               "    tempind2=tempind1+(my+1);"
               "    otsz=GetRealOparPtrs(block,5);"
               "    indx2=GetRealOparPtrs(block,4);"
               "    indx1=GetRealOparPtrs(block,3);"
               "    indxopt=GetRealOparPtrs(block,2);"
               "    indxb=GetRealOparPtrs(block,1);"
               "    typ=GetOutType(block,1);"
               "    nev=GetNevIn(block);"
               "    if (nev%2==1){"
               "      if (*out0==1){ /* initilize to the first input*/"
               "        void *y0,*y;"
               "        y=GetOutPortPtrs(block,1);"
               "        y0=GetInPortPtrs(block,1);"
               "        memcpy(y,y0,my*ny*so);"
               "      }"
               "    }"
               "    if ((*indxopt==3)|(*indxopt==5)){"
               "      if ((typ==SCSREAL_N)|(typ==SCSCOMPLEX_N)) {"
               "        double *ind1;"
               "        ind1=GetRealInPortPtrs(block,2+(int)*out0);"
               "        *tempind1=1;"
               "        *(tempind1+1)=max(min((int)(*ind1),my-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "      }"
               "      else if ((typ==SCSINT8_N)|(typ==SCSUINT8_N)){"
               "        char  *ind1;"
               "        ind1=Getint8InPortPtrs(block,2+(int)*out0);"
               "        *tempind1=1;"
               "        *(tempind1+1)=max(min((int)(*ind1),my-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "      }"
               "      else if ((typ==SCSINT16_N)|(typ==SCSUINT16_N)){"
               "        short *ind1;"
               "        ind1=Getint16InPortPtrs(block,2+(int)*out0);"
               "        *tempind1=1;"
               "        *(tempind1+1)=max(min((int)(*ind1),my-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "      }"
               "      else if ((typ==SCSINT32_N)|(typ==SCSUINT32_N)){"
               "        long *ind1;"
               "        ind1=Getint32InPortPtrs(block,2+(int)*out0);"
               "        *tempind1=1;"
               "        *(tempind1+1)=max(min((int)(*ind1),my-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "      }"
               "    }"
               "    else if ((*indxopt==2)|(*indxopt==4)){"
               "      *tempind1=GetOparSize(block,3,1)*GetOparSize(block,3,2);"
               "      for (i=0;i<*tempind1;i++)"
               "        *(tempind1+1+i)=max(min((int)(*(indx1+i)),my-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "    }"
               "    else {"
               "      *tempind1=my;"
               "      for (i=0;i<my;i++)"
               "        *(tempind1+1+i)=i;"
               "    }"
               "    if (ny==1){"
               "      *tempind2=1;"
               "      *(tempind2+1)=0;"
               "    }"
               "    else { /*matrix case */"
               "      if (((*(indxopt+1)==3)|(*(indxopt+1)==5))&((*indxopt==3)|(*indxopt==5))){"
               "        if ((typ==SCSREAL_N)|(typ==SCSCOMPLEX_N)) {"
               "          double *ind2;   "
               "          ind2=GetRealInPortPtrs(block,3+(int)*out0);"
               "          *tempind2=1;"
               "          *(tempind2+1)=max(min((int)(*ind2),ny-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "        }"
               "        else if ((typ==SCSINT8_N)|(typ==SCSUINT8_N)){"
               "          char  *ind2;"
               "          ind2=Getint8InPortPtrs(block,3+(int)*out0);"
               "          *tempind2=1;"
               "          *(tempind2+1)=max(min((int)(*ind2),ny-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "        }"
               "        else if ((typ==SCSINT16_N)|(typ==SCSUINT16_N)){"
               "          short *ind2;"
               "          ind2=Getint16InPortPtrs(block,3+(int)*out0);"
               "          *tempind2=1;"
               "          *(tempind2+1)=max(min((int)(*ind2),ny-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "        }"
               "        else if ((typ==SCSINT32_N)|(typ==SCSUINT32_N)){"
               "          long *ind2;"
               "          ind2=Getint32InPortPtrs(block,3+(int)*out0);"
               "          *tempind2=1;"
               "          *(tempind2+1)=max(min((int)(*ind2),ny-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "        }"
               "      }"
               "      else if (((*(indxopt+1)==3)|(*(indxopt+1)==5))&(!((*indxopt==3)|(*indxopt==5)))){"
               "        if ((typ==SCSREAL_N)|(typ==SCSCOMPLEX_N)) {"
               "          double *ind2;   "
               "          ind2=GetRealInPortPtrs(block,2+(int)*out0);"
               "          *tempind2=1;"
               "          *(tempind2+1)=max(min((int)(*ind2),ny-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "        }"
               "        else if ((typ==SCSINT8_N)|(typ==SCSUINT8_N)){"
               "          char  *ind2;"
               "          ind2=Getint8InPortPtrs(block,2+(int)*out0);"
               "          *tempind2=1;"
               "          *(tempind2+1)=max(min((int)(*ind2),ny-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "        }"
               "        else if ((typ==SCSINT16_N)|(typ==SCSUINT16_N)){"
               "          short *ind2;"
               "          ind2=Getint16InPortPtrs(block,2+(int)*out0);"
               "          *tempind2=1;"
               "          *(tempind2+1)=max(min((int)(*ind2),ny-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "        }"
               "        else if ((typ==SCSINT32_N)|(typ==SCSUINT32_N)){"
               "          long *ind2;"
               "          ind2=Getint32InPortPtrs(block,2+(int)*out0);"
               "          *tempind2=1;"
               "          *(tempind2+1)=max(min((int)(*ind2),ny-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "        }"
               "      }"
               "      else if ((*(indxopt+1)==2)|(*(indxopt+1)==4)){"
               "        *tempind2=GetOparSize(block,4,1)*GetOparSize(block,4,2);"
               "        for (i=0;i<*tempind2;i++)"
               "          *(tempind2+1+i)=max(min((int)(*(indx2+i)),ny-(1-(int)(*indxb)))-(int)(*indxb),0);"
               "      }"
               "      else {"
               "        *tempind1=ny;"
               "        for (i=0;i<ny;i++)"
               "          *(tempind2+1+i)=i;"
               "      }"
               "    }"
               "    void *y,*u;"
               "    y=GetOutPortPtrs(block,1);"
               "    u=GetInPortPtrs(block,1+(int)*out0);"
               "    for (j=0;j<tempind2[0];j++) {"
               "      for (i=0;i<tempind1[0];i++) {"
               "        memcpy((y+((*(tempind2+1+j)*(my))+(*(tempind1+1+i)))*so),u,so);"
               "      }"
               "    }      "
               "  }"
               "  else if (flag==5) {"
               "    if (*(_work)!=0) scicos_free(*(_work));"
               "  } "
               "}"]

      case 'automat' then
        txt = ["#include ""scicos_block4.h"""
               "# include ""machine.h"""
               ""
               "/* A swithcing mechansim for building hybrid automata */"
               "/* Masoud Najafi, 2007, INRIA */"
               ""
               "void automat(scicos_block *block,int flag)"
               "{"
               "  "
               "  double * y0, *y1, *ui;"
               "  double* g=GetGPtrs(block);"
               "  double* x=GetState(block);"
               "  double* xd=GetDerState(block);"
               "  double* res=GetResState(block); "
               "  void**   work=GetPtrWorkPtrs(block);"
               "  double* rpar=GetRparPtrs(block);"
               "  double* evout= GetNevOutPtrs(block);"
               ""
               "  int* ipar=GetIparPtrs(block);"
               "  int* jroot=GetJrootPtrs(block);"
               "  int  nevprt=GetNevIn(block);"
               "  int ng=GetNg(block);"
               ""
               "  int* Mode;"
               "  int  NMode, NX, Minitial,i,j,k,Mi,Mf,indice;"
               "  int* property=GetXpropPtrs(block);"
               "  int* iparXp;"
               "  int* iparCx;"
               "  double* rparX0;"
               "  int test;"
               "  NMode=ipar[0];"
               "  Minitial=ipar[1];"
               "  NX=ipar[2];"
               "  iparXp=ipar+3;"
               "  iparCx=iparXp+NX*NMode;"
               "  rparX0=rpar;"
               ""
               ""
               "  if (flag ==4){/*----------------------------------------------------------*/"
               "    if ((*work=scicos_malloc(sizeof(int)*(2)))== NULL ) {set_block_error(-16); return; }"
               "    Mode=*work;"
               "    Mode[0]=Minitial;/*Current Mode;*/"
               "    Mode[1]=Minitial;/* Previous Mode*/"
               "    for (i=0;i<NX;i++) property[i]=0; /* xproperties*/"
               "    for (i=0;i<NX;i++) x[i]=rparX0[i];"
               ""
               "  }else if (flag ==5){/**----------------------------------------------------------*/"
               "    scicos_free(*work);"
               "  }else if  (flag ==1 || flag ==6){/*----------------------------------------------------------*/"
               "    y0=GetRealOutPortPtrs(block,1);"
               "    y1=GetRealOutPortPtrs(block,2);"
               ""
               "    Mode=*work;"
               "    Mi=Mode[0];"
               "    y0[0]=Mi;/*current Mode*/"
               "    y0[1]=Mode[1];/*prevous Mode*/"
               "    for (i=0;i<NX;i++){"
               "      y1[i]=x[i];"
               "      y1[i+NX]=xd[i];"
               "    }"
               "  }else if (flag==0){ /*----------------------------------------------------------*/"
               "    Mode=*work;"
               "    Mi=Mode[0];"
               "    ui=GetRealInPortPtrs(block,Mi);"
               "    for (i=0;i<NX;i++)"
               "      res[i]= ui[i];"
               ""
               "  }else if (flag==7){/*----------------------------------------------------------*/"
               "    Mode=*work;"
               "    Mi=Mode[0];"
               "    for (i=0;i<NX;i++)"
               "      property[i] = iparXp[(Mi-1)*NX+i];"
               ""
               "  }else if (flag==9){/*----------------------------------------------------------*/"
               "    Mode=*work;"
               "    Mi=Mode[0];"
               "    ui=GetRealInPortPtrs(block,Mi);"
               ""
               "    for (j=0;j<ng;j++) g[j]=0;"
               "    for (j=0;j<GetInPortRows(block,Mi-1+1)-2*NX;j++) {"
               "      g[j]=ui[j+2*NX];"
               "      }"
               ""
               "  }else if ((flag==3)&&(nevprt<0)){"
               "    Mode=*work;"
               "    Mi=Mode[0];"
               "    indice=0;"
               "    for (i=1;i<Mi;i++)  "
               "      indice+=GetInPortRows(block,i-1+1)-2*NX; /*number of modes before Mi_th Mode */"
               "    for (k=0;k<GetInPortRows(block,Mi-1+1)-2*NX;k++)"
               "      if(jroot[k]==1){"
               "        evout[0]=0.0;"
               "        break;"
               "      }"
               "  }else if ((flag==2)&&(nevprt<0)){/*----------------------------------------------------------*/"
               "    Mode=*work;"
               "    Mi=Mode[0];"
               "    indice=0;"
               "    Mf=Mi;/* in case where the user has defined a wrong mode destination or ZC direction.*/"
               "    for (i=1;i<Mi;i++)  "
               "      indice+=GetInPortRows(block,i-1+1)-2*NX; /*number of modes before Mi_th Mode*/"
               "    test=0;"
               "    for (k=0;k<GetInPortRows(block,Mi-1+1)-2*NX;k++){"
               "      if(jroot[k]==1){"
               "        Mf=iparCx[indice+k]; "
               "        Mode[0]=Mf;/* saving the new Mode*/"
               "        Mode[1]=Mi;/* saving the previous Mode*/"
               "        test=1;"
               "        break;"
               "      }"
               "    }"
               "    if (test==0){"
               "      for (k=0;k<GetInPortRows(block,Mi-1+1)-2*NX;k++) if(jroot[k]==-1) break;"
               "      /*      sciprint(""\n\r Warning!: In Mode=%d, the jump condition #%d has crossed zero in negative direction"",Mi,k+1); */"
               "    }"
               "    ui=GetRealInPortPtrs(block,Mf);"
               "    for (i=0;i<NX;i++)"
               "      x[i]=ui[i+NX]; /*reinitialize the states*/    "
               "  }"
               "}"
               ""]

  end
endfunction

function [txt]=get_solver_file_code(name)
//Copyright (c) 1989-2010 Metalau project INRIA
//
//@@ get_solver_file_code : extract code of solver
//
// Input : name : name of a solver file
//
// Output : txt : the output code

  txt=[];

  select name
      case 'cvode_dense.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * ----------------------------------------------------------------- "
               " * Programmer(s): Scott D. Cohen, Alan C. Hindmarsh and"
               " *                Radu Serban @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * This is the header file for the CVODE dense linear solver, CVDENSE."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _CVDENSE_H"
               "#define _CVDENSE_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include ""sundials_dense.h"""
               "#include ""sundials_nvector.h"""
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * CVDENSE solver constants"
               " * -----------------------------------------------------------------"
               " * CVD_MSBJ : maximum number of steps between dense Jacobian"
               " *            evaluations"
               " *"
               " * CVD_DGMAX : maximum change in gamma between dense Jacobian"
               " *             evaluations"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#define CVD_MSBJ  50"
               "#define CVD_DGMAX RCONST(0.2)"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Type : CVDenseJacFn"
               " * -----------------------------------------------------------------"
               " * A dense Jacobian approximation function Jac must have the"
               " * prototype given below. Its parameters are:"
               " *"
               " * N is the problem size."
               " *"
               " * J is the dense matrix (of type DenseMat) that will be loaded"
               " * by a CVDenseJacFn with an approximation to the Jacobian matrix"
               " * J = (df_i/dy_j) at the point (t,y)."
               " * J is preset to zero, so only the nonzero elements need to be"
               " * loaded. Two efficient ways to load J are:"
               " *"
               " * (1) (with macros - no explicit data structure references)"
               " *     for (j=0; j < n; j++) {"
               " *       col_j = DENSE_COL(J,j);"
               " *       for (i=0; i < n; i++) {"
               " *         generate J_ij = the (i,j)th Jacobian element"
               " *         col_j[i] = J_ij;"
               " *       }"
               " *     }"
               " *"
               " * (2) (without macros - explicit data structure references)"
               " *     for (j=0; j < n; j++) {"
               " *       col_j = (J->data)[j];"
               " *       for (i=0; i < n; i++) {"
               " *         generate J_ij = the (i,j)th Jacobian element"
               " *         col_j[i] = J_ij;"
               " *       }"
               " *     }"
               " *"
               " * The DENSE_ELEM(A,i,j) macro is appropriate for use in small"
               " * problems in which efficiency of access is NOT a major concern."
               " *"
               " * t is the current value of the independent variable."
               " *"
               " * y is the current value of the dependent variable vector,"
               " *   namely the predicted value of y(t)."
               " *"
               " * fy is the vector f(t,y)."
               " *"
               " * jac_data is a pointer to user data - the same as the jac_data"
               " *          parameter passed to CVDense."
               " *"
               " * NOTE: If the user''s Jacobian routine needs other quantities,"
               " *       they are accessible as follows: hcur (the current stepsize)"
               " *       and ewt (the error weight vector) are accessible through"
               " *       CVodeGetCurrentStep and CVodeGetErrWeights, respectively"
               " *       (see cvode.h). The unit roundoff is available as"
               " *       UNIT_ROUNDOFF defined in sundials_types.h."
               " *"
               " * tmp1, tmp2, and tmp3 are pointers to memory allocated for"
               " * vectors of length N which can be used by a CVDenseJacFn"
               " * as temporary storage or work space."
               " *"
               " * A CVDenseJacFn should return 0 if successful, a positive value if "
               " * a recoverable error occurred, and a negative value if an "
               " * unrecoverable error occurred."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "typedef int (*CVDenseJacFn)(long int N, DenseMat J, realtype t,"
               "                            N_Vector y, N_Vector fy, void *jac_data,"
               "                            N_Vector tmp1, N_Vector tmp2, N_Vector tmp3);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : CVDense"
               " * -----------------------------------------------------------------"
               " * A call to the CVDense function links the main integrator with"
               " * the CVDENSE linear solver."
               " *"
               " * cvode_mem is the pointer to the integrator memory returned by"
               " *           CVodeCreate."
               " *"
               " * N is the size of the ODE system."
               " *"
               " * The return value of CVDense is one of:"
               " *    CVDENSE_SUCCESS   if successful"
               " *    CVDENSE_MEM_NULL  if the cvode memory was NULL"
               " *    CVDENSE_MEM_FAIL  if there was a memory allocation failure"
               " *    CVDENSE_ILL_INPUT if a required vector operation is missing"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "int CVDense(void *cvode_mem, long int N);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Optional inputs to the CVDENSE linear solver"
               " * -----------------------------------------------------------------"
               " *"
               " * CVDenseSetJacFn specifies the dense Jacobian approximation"
               " *                 routine to be used. A user-supplied djac routine"
               " *                 must be of type CVDenseJacFn. By default, a"
               " *                 difference quotient routine CVDenseDQJac, supplied"
               " *                 with this solver is used.                     "
               " *                 It also specifies a pointer to user data which is"
               " *                 passed to the djac routine every time it is called."
               " *"
               " * The return value of CVDenseSet* is one of:"
               " *    CVDENSE_SUCCESS   if successful"
               " *    CVDENSE_MEM_NULL  if the cvode memory was NULL"
               " *    CVDENSE_LMEM_NULL if the cvdense memory was NULL"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "int CVDenseSetJacFn(void *cvode_mem, CVDenseJacFn djac, void *jac_data);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Optional outputs from the CVDENSE linear solver"
               " * -----------------------------------------------------------------"
               " *"
               " * CVDenseGetWorkSpace returns the real and integer workspace used"
               " *                     by CVDENSE."
               " * CVDenseGetNumJacEvals returns the number of calls made to the"
               " *                       Jacobian evaluation routine djac."
               " * CVDenseGetNumRhsEvals returns the number of calls to the user"
               " *                       f routine due to finite difference Jacobian"
               " *                       evaluation."
               " * CVDenseGetLastFlag returns the last error flag set by any of"
               " *                    the CVDENSE interface functions."
               " *"
               " * The return value of CVDenseGet* is one of:"
               " *    CVDENSE_SUCCESS   if successful"
               " *    CVDENSE_MEM_NULL  if the cvode memory was NULL"
               " *    CVDENSE_LMEM_NULL if the cvdense memory was NULL"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "int CVDenseGetWorkSpace(void *cvode_mem, long int *lenrwLS, long int *leniwLS);"
               "int CVDenseGetNumJacEvals(void *cvode_mem, long int *njevals);"
               "int CVDenseGetNumRhsEvals(void *cvode_mem, long int *nfevalsLS);"
               "int CVDenseGetLastFlag(void *cvode_mem, int *flag);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * The following function returns the name of the constant "
               " * associated with a CVDENSE return flag"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "char *CVDenseGetReturnFlagName(int flag);"
               ""
               ""
               "/* CVDENSE return values */"
               ""
               "#define CVDENSE_SUCCESS           0"
               "#define CVDENSE_MEM_NULL         -1"
               "#define CVDENSE_LMEM_NULL        -2"
               "#define CVDENSE_ILL_INPUT        -3"
               "#define CVDENSE_MEM_FAIL         -4"
               ""
               "/* Additional last_flag values */"
               ""
               "#define CVDENSE_JACFUNC_UNRECVR  -5"
               "#define CVDENSE_JACFUNC_RECVR    -6"
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'cvode_dense_impl.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * ----------------------------------------------------------------- "
               " * Programmer(s): Scott D. Cohen, Alan C. Hindmarsh and"
               " *                Radu Serban @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * Implementation header file for the dense linear solver, CVDENSE."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _CVDENSE_IMPL_H"
               "#define _CVDENSE_IMPL_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include ""cvode_dense.h"""
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Types : CVDenseMemRec, CVDenseMem                             "
               " * -----------------------------------------------------------------"
               " * The type CVDenseMem is pointer to a CVDenseMemRec."
               " * This structure contains CVDense solver-specific data. "
               " * -----------------------------------------------------------------"
               " */"
               ""
               "typedef struct {"
               ""
               "  long int d_n;        /* problem dimension                       */"
               ""
               "  CVDenseJacFn d_jac;  /* jac = Jacobian routine to be called     */"
               ""
               "  DenseMat d_M;        /* M = I - gamma J, gamma = h / l1         */"
               "  "
               "  long int *d_pivots;  /* pivots = pivot array for PM = LU        */"
               "  "
               "  DenseMat d_savedJ;   /* savedJ = old Jacobian                   */"
               "  "
               "  long int  d_nstlj;   /* nstlj = nst at last Jacobian eval.      */"
               "  "
               "  long int d_nje;      /* nje = no. of calls to jac               */"
               ""
               "  long int d_nfeD;     /* nfeD = no. of calls to f due to"
               "                          difference quotient approximation of J  */"
               "  "
               "  void *d_J_data;      /* J_data is passed to jac                 */"
               ""
               "  int d_last_flag;     /* last error return flag                  */"
               "  "
               "} CVDenseMemRec, *CVDenseMem;"
               ""
               "/* Error Messages */"
               ""
               "#define MSGDS_CVMEM_NULL ""Integrator memory is NULL."""
               "#define MSGDS_BAD_NVECTOR ""A required vector operation is not implemented."""
               "#define MSGDS_MEM_FAIL ""A memory request failed."""
               "#define MSGDS_LMEM_NULL ""CVDENSE memory is NULL."""
               "#define MSGDS_JACFUNC_FAILED ""The Jacobian routine failed in an unrecoverable manner."""
               ""
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'cvode.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * ----------------------------------------------------------------- "
               " * Programmer(s): Scott D. Cohen, Alan C. Hindmarsh, Radu Serban"
               " *                and Dan Shumaker @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * This is the interface file for the main CVODE integrator."
               " * -----------------------------------------------------------------"
               " *"
               " * CVODE is used to solve numerically the ordinary initial value"
               " * problem:"
               " *"
               " *                 y'' = f(t,y),"
               " *                 y(t0) = y0,"
               " *"
               " * where t0, y0 in R^N, and f: R x R^N -> R^N are given."
               " *"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _CVODE_H"
               "#define _CVODE_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include <stdio.h>"
               ""
               "#include ""sundials_nvector.h"""
               ""
               "  /*"
               "   * ================================================================="
               "   *              C V O D E     C O N S T A N T S"
               "   * ================================================================="
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Enumerations for inputs to CVodeCreate, CVodeMalloc,"
               "   * CVodeReInit, and CVode."
               "   * -----------------------------------------------------------------"
               "   * Symbolic constants for the lmm, iter, and itol input"
               "   * parameters to CVodeMalloc and CVodeReInit, as well as the"
               "   * input parameter itask to CVode, are given below."
               "   *"
               "   * lmm:   The user of the CVODE package specifies whether to use the"
               "   *        CV_ADAMS (Adams-Moulton) or CV_BDF (Backward Differentiation"
               "   *        Formula) linear multistep method. The BDF method is"
               "   *        recommended for stiff problems, and the CV_ADAMS method is"
               "   *        recommended for nonstiff problems."
               "   *"
               "   * iter:  At each internal time step, a nonlinear equation must"
               "   *        be solved. The user can specify either CV_FUNCTIONAL"
               "   *        iteration, which does not require linear algebra, or a"
               "   *        CV_NEWTON iteration, which requires the solution of linear"
               "   *        systems. In the CV_NEWTON case, the user also specifies a"
               "   *        CVODE linear solver. CV_NEWTON is recommended in case of"
               "   *        stiff problems."
               "   *"
               "   * itol:  This parameter specifies the relative and absolute"
               "   *        tolerance types to be used. The CV_SS tolerance type means"
               "   *        a scalar relative and absolute tolerance. The CV_SV"
               "   *        tolerance type means a scalar relative tolerance and a"
               "   *        vector absolute tolerance (a potentially different"
               "   *        absolute tolerance for each vector component). The CV_WF"
               "   *        tolerance type means that the user provides a function"
               "   *        (of type CVEwtFn) to set the error weight vector."
               "   *"
               "   * itask: The itask input parameter to CVode indicates the job"
               "   *        of the solver for the next user step. The CV_NORMAL"
               "   *        itask is to have the solver take internal steps until"
               "   *        it has reached or just passed the user specified tout"
               "   *        parameter. The solver then interpolates in order to"
               "   *        return an approximate value of y(tout). The CV_ONE_STEP"
               "   *        option tells the solver to just take one internal step"
               "   *        and return the solution at the point reached by that"
               "   *        step. The CV_NORMAL_TSTOP and CV_ONE_STEP_TSTOP modes are"
               "   *        similar to CV_NORMAL and CV_ONE_STEP, respectively, except"
               "   *        that the integration never proceeds past the value"
               "   *        tstop (specified through the routine CVodeSetStopTime)."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  /* lmm */"
               "#define CV_ADAMS 1"
               "#define CV_BDF   2"
               ""
               "  /* iter */"
               "#define CV_FUNCTIONAL 1"
               "#define CV_NEWTON     2"
               ""
               "  /* itol */"
               "#define CV_SS 1"
               "#define CV_SV 2"
               "#define CV_WF 3"
               ""
               "  /* itask */"
               "#define CV_NORMAL         1"
               "#define CV_ONE_STEP       2"
               "#define CV_NORMAL_TSTOP   3"
               "#define CV_ONE_STEP_TSTOP 4"
               ""
               "  /*"
               "   * ----------------------------------------"
               "   * CVODE return flags"
               "   * ----------------------------------------"
               "   */"
               ""
               "#define CV_SUCCESS               0"
               "#define CV_TSTOP_RETURN          1"
               "#define CV_ROOT_RETURN           2"
               "#define CV_ZERO_DETACH_RETURN    3"
               ""
               "#define CV_WARNING              99"
               ""
               "#define CV_TOO_MUCH_WORK        -1"
               "#define CV_TOO_MUCH_ACC         -2"
               "#define CV_ERR_FAILURE          -3"
               "#define CV_CONV_FAILURE         -4"
               ""
               "#define CV_LINIT_FAIL           -5"
               "#define CV_LSETUP_FAIL          -6"
               "#define CV_LSOLVE_FAIL          -7"
               "#define CV_RHSFUNC_FAIL         -8"
               "#define CV_FIRST_RHSFUNC_ERR    -9"
               "#define CV_REPTD_RHSFUNC_ERR    -10"
               "#define CV_UNREC_RHSFUNC_ERR    -11"
               "#define CV_RTFUNC_FAIL          -12"
               ""
               "#define CV_MEM_FAIL             -20"
               "#define CV_MEM_NULL             -21"
               "#define CV_ILL_INPUT            -22"
               "#define CV_NO_MALLOC            -23"
               "#define CV_BAD_K                -24"
               "#define CV_BAD_T                -25"
               "#define CV_BAD_DKY              -26"
               "#define CV_TOO_CLOSE            -27"
               "  /* added by masoud*/"
               "#define CV_YOUT_NULL            -28"
               "#define CV_TRET_NULL            -29"
               "#define CV_BAD_ITASK            -30"
               "#define CV_NO_TSTOP             -31"
               "#define CV_BAD_H0               -32"
               "#define CV_BAD_TSTOP            -33"
               "#define CV_BAD_INIT_ROOT        -34"
               "#define CV_NO_EFUN              -35"
               "#define CV_EWT_FAIL             -36"
               "#define CV_BAD_EWT              -37"
               "#define CV_LSOLVE_NULL          -38"
               "#define CV_NULL_Y0              -39"
               "#define CV_BAD_ITOL             -40"
               "#define CV_NULL_F               -41"
               "#define CV_BAD_NVECTOR          -42"
               "#define CV_NULL_ABSTOL          -43"
               "#define CV_BAD_RELTOL           -44"
               "#define CV_BAD_ABSTOL           -45"
               "#define CV_NULL_G               -46"
               "#define CV_BAD_TOUT             -47"
               "#define CV_CLOSE_ROOTS          -48"
               ""
               "#define LSODAR_NOTHING_DONE       201"
               "#define LSODAR_SUCCESS            202"
               "#define LSODAR_ROOT_RETURN        203"
               "#define LSODAR_ZERO_DETACH_RETURN 204"
               ""
               "#define LSODAR_TOO_MUCH_WORK    -201"
               "#define LSODAR_TOO_MUCH_ACC     -202"
               "#define LSODAR_ILL_INPUT        -203"
               "#define LSODAR_ERR_FAILURE      -204 "
               "#define LSODAR_CONV_FAILURE     -205"
               "#define LSODAR_BAD_EWT          -206"
               "#define LSODAR_I_R_HOT_SHORT    -207"
               ""
               ""
               ""
               ""
               "  /*"
               "   * ================================================================="
               "   *              F U N C T I O N   T Y P E S"
               "   * ================================================================="
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Type : CVRhsFn"
               "   * -----------------------------------------------------------------"
               "   * The f function which defines the right hand side of the ODE"
               "   * system y'' = f(t,y) must have type CVRhsFn."
               "   * f takes as input the independent variable value t, and the"
               "   * dependent variable vector y.  It stores the result of f(t,y)"
               "   * in the vector ydot.  The y and ydot arguments are of type"
               "   * N_Vector."
               "   * (Allocation of memory for ydot is handled within CVODE)"
               "   * The f_data parameter is the same as the f_data"
               "   * parameter set by the user through the CVodeSetFdata routine."
               "   * This user-supplied pointer is passed to the user''s f function"
               "   * every time it is called."
               "   *"
               "   * A CVRhsFn should return 0 if successful, a negative value if"
               "   * an unrecoverable error occured, and a positive value if a "
               "   * recoverable error (e.g. invalid y values) occured. "
               "   * If an unrecoverable occured, the integration is halted. "
               "   * If a recoverable error occured, then (in most cases) CVODE"
               "   * will try to correct and retry."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef int (*CVRhsFn)(realtype t, N_Vector y,"
               "                         N_Vector ydot, void *f_data);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Type : CVRootFn"
               "   * -----------------------------------------------------------------"
               "   * A function g, which defines a set of functions g_i(t,y) whose"
               "   * roots are sought during the integration, must have type CVRootFn."
               "   * The function g takes as input the independent variable value"
               "   * t, and the dependent variable vector y.  It stores the nrtfn"
               "   * values g_i(t,y) in the realtype array gout."
               "   * (Allocation of memory for gout is handled within CVODE.)"
               "   * The g_data parameter is the same as that passed by the user"
               "   * to the CVodeRootInit routine.  This user-supplied pointer is"
               "   * passed to the user''s g function every time it is called."
               "   *"
               "   * A CVRootFn should return 0 if successful or a non-zero value"
               "   * if an error occured (in which case the integration will be halted)."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef int (*CVRootFn)(realtype t, N_Vector y, realtype *gout,"
               "                          void *g_data);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Type : CVEwtFn"
               "   * -----------------------------------------------------------------"
               "   * A function e, which sets the error weight vector ewt, must have"
               "   * type CVEwtFn."
               "   * The function e takes as input the current dependent variable y."
               "   * It must set the vector of error weights used in the WRMS norm:"
               "   * "
               "   *   ||y||_WRMS = sqrt [ 1/N * sum ( ewt_i * y_i)^2 ]"
               "   *"
               "   * Typically, the vector ewt has components:"
               "   * "
               "   *   ewt_i = 1 / (reltol * |y_i| + abstol_i)"
               "   *"
               "   * The e_data parameter is the same as that passed by the user"
               "   * to the CVodeSetEwtFn routine.  This user-supplied pointer is"
               "   * passed to the user''s e function every time it is called."
               "   * A CVEwtFn e must return 0 if the error weight vector has been"
               "   * successfuly set and a non-zero value otherwise."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef int (*CVEwtFn)(N_Vector y, N_Vector ewt, void *e_data);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Type : CVErrHandlerFn"
               "   * -----------------------------------------------------------------"
               "   * A function eh, which handles error messages, must have type"
               "   * CVErrHandlerFn."
               "   * The function eh takes as input the error code, the name of the"
               "   * module reporting the error, the error message, and a pointer to"
               "   * user data, the same as that passed to CVodeSetErrHandlerFn."
               "   * "
               "   * All error codes are negative, except CV_WARNING which indicates "
               "   * a warning (the solver continues)."
               "   *"
               "   * A CVErrHandlerFn has no return value."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef void (*CVErrHandlerFn)(int error_code, "
               "                                 const char *module, const char *function, "
               "                                 char *msg, void *eh_data); "
               ""
               "  /*"
               "   * ================================================================="
               "   *          U S E R - C A L L A B L E   R O U T I N E S"
               "   * ================================================================="
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : CVodeCreate"
               "   * -----------------------------------------------------------------"
               "   * CVodeCreate creates an internal memory block for a problem to"
               "   * be solved by CVODE."
               "   *"
               "   * lmm   is the type of linear multistep method to be used."
               "   *       The legal values are CV_ADAMS and CV_BDF (see previous"
               "   *       description)."
               "   *"
               "   * iter  is the type of iteration used to solve the nonlinear"
               "   *       system that arises during each internal time step."
               "   *       The legal values are CV_FUNCTIONAL and CV_NEWTON."
               "   *"
               "   * If successful, CVodeCreate returns a pointer to initialized"
               "   * problem memory. This pointer should be passed to CVodeMalloc."
               "   * If an initialization error occurs, CVodeCreate prints an error"
               "   * message to standard err and returns NULL."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void *CVodeCreate(int lmm, int iter);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Integrator optional input specification functions"
               "   * -----------------------------------------------------------------"
               "   * The following functions can be called to set optional inputs"
               "   * to values other than the defaults given below:"
               "   *"
               "   * Function                |  Optional input / [ default value ]"
               "   * -----------------------------------------------------------------"
               "   *                         |"
               "   * CVodeSetErrHandlerFn    | user-provided ErrHandler function."
               "   *                         | [internal]"
               "   *                         |"
               "   * CVodeSetErrFile         | the file pointer for an error file"
               "   *                         | where all CVODE warning and error"
               "   *                         | messages will be written if the default"
               "   *                         | internal error handling function is used. "
               "   *                         | This parameter can be stdout (standard "
               "   *                         | output), stderr (standard error), or a "
               "   *                         | file pointer (corresponding to a user "
               "   *                         | error file opened for writing) returned "
               "   *                         | by fopen."
               "   *                         | If not called, then all messages will"
               "   *                         | be written to the standard error stream."
               "   *                         | [stderr]"
               "   *                         |"
               "   * CVodeSetFdata           | a pointer to user data that will be"
               "   *                         | passed to the user''s f function every"
               "   *                         | time f is called."
               "   *                         | [NULL]"
               "   *                         |"
               "   * CVodeSetEwtFn           | user-provide EwtSet function e and "
               "   *                         | a pointer to user data that will be"
               "   *                         | passed to the user''s e function every"
               "   *                         | time e is called."
               "   *                         | [NULL]"
               "   *                         | [NULL]"
               "   *                         |"
               "   * CVodeSetMaxOrd          | maximum lmm order to be used by the"
               "   *                         | solver."
               "   *                         | [12 for Adams , 5 for BDF]"
               "   *                         |"
               "   * CVodeSetMaxNumSteps     | maximum number of internal steps to be"
               "   *                         | taken by the solver in its attempt to"
               "   *                         | reach tout."
               "   *                         | [500]"
               "   *                         |"
               "   * CVodeSetMaxHnilWarns    | maximum number of warning messages"
               "   *                         | issued by the solver that t+h==t on the"
               "   *                         | next internal step. A value of -1 means"
               "   *                         | no such messages are issued."
               "   *                         | [10]"
               "   *                         |"
               "   * CVodeSetStabLimDet      | flag to turn on/off stability limit"
               "   *                         | detection (TRUE = on, FALSE = off)."
               "   *                         | When BDF is used and order is 3 or"
               "   *                         | greater, CVsldet is called to detect"
               "   *                         | stability limit.  If limit is detected,"
               "   *                         | the order is reduced."
               "   *                         | [FALSE]"
               "   *                         |"
               "   * CVodeSetInitStep        | initial step size."
               "   *                         | [estimated by CVODE]"
               "   *                         |"
               "   * CVodeSetMinStep         | minimum absolute value of step size"
               "   *                         | allowed."
               "   *                         | [0.0]"
               "   *                         |"
               "   * CVodeSetMaxStep         | maximum absolute value of step size"
               "   *                         | allowed."
               "   *                         | [infinity]"
               "   *                         |"
               "   * CVodeSetStopTime        | the independent variable value past"
               "   *                         | which the solution is not to proceed."
               "   *                         | [infinity]"
               "   *                         |"
               "   * CVodeSetMaxErrTestFails | Maximum number of error test failures"
               "   *                         | in attempting one step."
               "   *                         | [7]"
               "   *                         |"
               "   * CVodeSetMaxNonlinIters  | Maximum number of nonlinear solver"
               "   *                         | iterations at one solution."
               "   *                         | [3]"
               "   *                         |"
               "   * CVodeSetMaxConvFails    | Maximum number of convergence failures"
               "   *                         | allowed in attempting one step."
               "   *                         | [10]"
               "   *                         |"
               "   * CVodeSetNonlinConvCoef  | Coefficient in the nonlinear"
               "   *                         | convergence test."
               "   *                         | [0.1]"
               "   *                         |"
               "   * -----------------------------------------------------------------"
               "   *                         |"
               "   * CVodeSetIterType        | Changes the current nonlinear iteration"
               "   *                         | type."
               "   *                         | [set by CVodecreate]"
               "   *                         |"
               "   * CVodeSetTolerances      | Changes the integration tolerances"
               "   *                         | between calls to CVode()."
               "   *                         | [set by CVodeMalloc/CVodeReInit]"
               "   *                         |"
               "   * -----------------------------------------------------------------"
               "   * Return flag:"
               "   *   CV_SUCCESS   if successful"
               "   *   CV_MEM_NULL  if the cvode memory is NULL"
               "   *   CV_ILL_INPUT if an argument has an illegal value"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int CVodeSetErrHandlerFn(void *cvode_mem, CVErrHandlerFn ehfun, void *eh_data);"
               "  int CVodeSetErrFile(void *cvode_mem, FILE *errfp);"
               "  int CVodeSetFdata(void *cvode_mem, void *f_data);"
               "  int CVodeSetEwtFn(void *cvode_mem, CVEwtFn efun, void *e_data);"
               "  int CVodeSetMaxOrd(void *cvode_mem, int maxord);"
               "  int CVodeSetMaxNumSteps(void *cvode_mem, long int mxsteps);"
               "  int CVodeSetMaxHnilWarns(void *cvode_mem, int mxhnil);"
               "  int CVodeSetStabLimDet(void *cvode_mem, booleantype stldet);"
               "  int CVodeSetInitStep(void *cvode_mem, realtype hin);"
               "  int CVodeSetMinStep(void *cvode_mem, realtype hmin);"
               "  int CVodeSetMaxStep(void *cvode_mem, realtype hmax);"
               "  int CVodeSetStopTime(void *cvode_mem, realtype tstop);"
               "  int CVodeSetMaxErrTestFails(void *cvode_mem, int maxnef);"
               "  int CVodeSetMaxNonlinIters(void *cvode_mem, int maxcor);"
               "  int CVodeSetMaxConvFails(void *cvode_mem, int maxncf);"
               "  int CVodeSetNonlinConvCoef(void *cvode_mem, realtype nlscoef);"
               ""
               "  int CVodeSetIterType(void *cvode_mem, int iter);"
               "  int CVodeSetTolerances(void *cvode_mem,"
               "                         int itol, realtype reltol, void *abstol);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : CVodeMalloc"
               "   * -----------------------------------------------------------------"
               "   * CVodeMalloc allocates and initializes memory for a problem to"
               "   * to be solved by CVODE."
               "   *"
               "   * cvode_mem is pointer to CVODE memory returned by CVodeCreate."
               "   *"
               "   * f       is the name of the C function defining the right-hand"
               "   *         side function in y'' = f(t,y)."
               "   *"
               "   * t0      is the initial value of t."
               "   *"
               "   * y0      is the initial condition vector y(t0)."
               "   *"
               "   * itol    is the type of tolerances to be used."
               "   *         The legal values are:"
               "   *            CV_SS (scalar relative and absolute tolerances),"
               "   *            CV_SV (scalar relative tolerance and vector"
               "   *                absolute tolerance)."
               "   *            CV_WF (indicates that the user will provide a"
               "   *                function to evaluate the error weights."
               "   *                In this case, reltol and abstol are ignored.)"
               "   *"
               "   * reltol  is the relative tolerance scalar."
               "   *"
               "   * abstol  is a pointer to the absolute tolerance scalar or"
               "   *         an N_Vector of absolute tolerances."
               "   *"
               "   * The parameters itol, reltol, and abstol define a vector of"
               "   * error weights, ewt, with components"
               "   *   ewt[i] = 1/(reltol*abs(y[i]) + abstol)   (if itol = CV_SS), or"
               "   *   ewt[i] = 1/(reltol*abs(y[i]) + abstol[i])   (if itol = CV_SV)."
               "   * This vector is used in all error and convergence tests, which"
               "   * use a weighted RMS norm on all error-like vectors v:"
               "   *    WRMSnorm(v) = sqrt( (1/N) sum(i=1..N) (v[i]*ewt[i])^2 ),"
               "   * where N is the problem dimension."
               "   *"
               "   * Return flag:"
               "   *  CV_SUCCESS if successful"
               "   *  CV_MEM_NULL if the cvode memory was NULL"
               "   *  CV_MEM_FAIL if a memory allocation failed"
               "   *  CV_ILL_INPUT f an argument has an illegal value."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int CVodeMalloc(void *cvode_mem, CVRhsFn f, realtype t0, N_Vector y0,"
               "                  int itol, realtype reltol, void *abstol);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : CVodeReInit"
               "   * -----------------------------------------------------------------"
               "   * CVodeReInit re-initializes CVode for the solution of a problem,"
               "   * where a prior call to CVodeMalloc has been made with the same"
               "   * problem size N. CVodeReInit performs the same input checking"
               "   * and initializations that CVodeMalloc does."
               "   * But it does no memory allocation, assuming that the existing"
               "   * internal memory is sufficient for the new problem."
               "   *"
               "   * The use of CVodeReInit requires that the maximum method order,"
               "   * maxord, is no larger for the new problem than for the problem"
               "   * specified in the last call to CVodeMalloc.  This condition is"
               "   * automatically fulfilled if the multistep method parameter lmm"
               "   * is unchanged (or changed from CV_ADAMS to CV_BDF) and the default"
               "   * value for maxord is specified."
               "   *"
               "   * All of the arguments to CVodeReInit have names and meanings"
               "   * identical to those of CVodeMalloc."
               "   *"
               "   * The return value of CVodeReInit is equal to CV_SUCCESS = 0 if"
               "   * there were no errors; otherwise it is a negative int equal to:"
               "   *   CV_MEM_NULL      indicating cvode_mem was NULL (i.e.,"
               "   *                    CVodeCreate has not been called)."
               "   *   CV_NO_MALLOC     indicating that cvode_mem has not been"
               "   *                    allocated (i.e., CVodeMalloc has not been"
               "   *                    called)."
               "   *   CV_ILL_INPUT     indicating an input argument was illegal"
               "   *                    (including an attempt to increase maxord)."
               "   * In case of an error return, an error message is also printed."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int CVodeReInit(void *cvode_mem, CVRhsFn f, realtype t0, N_Vector y0,"
               "                  int itol, realtype reltol, void *abstol);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : CVodeRootInit"
               "   * -----------------------------------------------------------------"
               "   * CVodeRootInit initializes a rootfinding problem to be solved"
               "   * during the integration of the ODE system.  It must be called"
               "   * after CVodeCreate, and before CVode.  The arguments are:"
               "   *"
               "   * cvode_mem = pointer to CVODE memory returned by CVodeCreate."
               "   *"
               "   * nrtfn     = number of functions g_i, an int >= 0."
               "   *"
               "   * g         = name of user-supplied function, of type CVRootFn,"
               "   *             defining the functions g_i whose roots are sought."
               "   *"
               "   * g_data    = a pointer to user data that will be passed to the "
               "   *             user''s g function every time g is called."
               "   *"
               "   * If a new problem is to be solved with a call to CVodeReInit,"
               "   * where the new problem has no root functions but the prior one"
               "   * did, then call CVodeRootInit with nrtfn = 0."
               "   *"
               "   * The return value of CVodeRootInit is CV_SUCCESS = 0 if there were"
               "   * no errors; otherwise it is a negative int equal to:"
               "   *   CV_MEM_NULL     indicating cvode_mem was NULL, or"
               "   *   CV_MEM_FAIL     indicating a memory allocation failed."
               "   *                    (including an attempt to increase maxord)."
               "   *   CV_ILL_INPUT   indicating nrtfn > 0 but g = NULL."
               "   * In case of an error return, an error message is also printed."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int CVodeRootInit(void *cvode_mem, int nrtfn, CVRootFn g, void *g_data);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : CVode"
               "   * -----------------------------------------------------------------"
               "   * CVode integrates the ODE over an interval in t."
               "   * If itask is CV_NORMAL, then the solver integrates from its"
               "   * current internal t value to a point at or beyond tout, then"
               "   * interpolates to t = tout and returns y(tout) in the user-"
               "   * allocated vector yout. If itask is CV_ONE_STEP, then the solver"
               "   * takes one internal time step and returns in yout the value of"
               "   * y at the new internal time. In this case, tout is used only"
               "   * during the first call to CVode to determine the direction of"
               "   * integration and the rough scale of the t variable.  If itask is"
               "   * CV_NORMAL_TSTOP or CV_ONE_STEP_TSTOP, then CVode returns the"
               "   * solution at tstop if that comes sooner than tout or the end of"
               "   * the next internal step, respectively.  In any case,"
               "   * the time reached by the solver is placed in (*tret). The"
               "   * user is responsible for allocating the memory for this value."
               "   *"
               "   * cvode_mem is the pointer to CVODE memory returned by"
               "   *           CVodeCreate."
               "   *"
               "   * tout  is the next time at which a computed solution is desired."
               "   *"
               "   * yout  is the computed solution vector. In CV_NORMAL mode with no"
               "   *       errors and no roots found, yout=y(tout)."
               "   *"
               "   * tret  is a pointer to a real location. CVode sets (*tret) to"
               "   *       the time reached by the solver and returns"
               "   *       yout=y(*tret)."
               "   *"
               "   * itask is CV_NORMAL, CV_ONE_STEP, CV_NORMAL_TSTOP, or CV_ONE_STEP_TSTOP."
               "   *       These four modes are described above."
               "   *"
               "   * Here is a brief description of each return value:"
               "   *"
               "   * CV_SUCCESS:      CVode succeeded and no roots were found."
               "   *"
               "   * CV_ROOT_RETURN:  CVode succeeded, and found one or more roots."
               "   *                  If nrtfn > 1, call CVodeGetRootInfo to see"
               "   *                  which g_i were found to have a root at (*tret)."
               "   *"
               "   * CV_TSTOP_RETURN: CVode succeeded and returned at tstop."
               "   *"
               "   * CV_MEM_NULL:     The cvode_mem argument was NULL."
               "   *"
               "   * CV_NO_MALLOC:    cvode_mem was not allocated."
               "   *"
               "   * CV_ILL_INPUT:    One of the inputs to CVode is illegal. This"
               "   *                  includes the situation when a component of the"
               "   *                  error weight vectors becomes < 0 during"
               "   *                  internal time-stepping.  It also includes the"
               "   *                  situation where a root of one of the root"
               "   *                  functions was found both at t0 and very near t0."
               "   *                  The ILL_INPUT flag will also be returned if the"
               "   *                  linear solver routine CV--- (called by the user"
               "   *                  after calling CVodeCreate) failed to set one of"
               "   *                  the linear solver-related fields in cvode_mem or"
               "   *                  if the linear solver''s init routine failed. In"
               "   *                  any case, the user should see the printed"
               "   *                  error message for more details."
               "   *"
               "   * CV_TOO_MUCH_WORK: The solver took mxstep internal steps but"
               "   *                  could not reach tout. The default value for"
               "   *                  mxstep is MXSTEP_DEFAULT = 500."
               "   *"
               "   * CV_TOO_MUCH_ACC: The solver could not satisfy the accuracy"
               "   *                  demanded by the user for some internal step."
               "   *"
               "   * CV_ERR_FAILURE:  Error test failures occurred too many times"
               "   *                  (= MXNEF = 7) during one internal time step or"
               "   *                  occurred with |h| = hmin."
               "   *"
               "   * CV_CONV_FAILURE: Convergence test failures occurred too many"
               "   *                  times (= MXNCF = 10) during one internal time"
               "   *                  step or occurred with |h| = hmin."
               "   *"
               "   * CV_LINIT_FAIL:   The linear solver''s initialization function "
               "   *                  failed."
               "   *"
               "   * CV_LSETUP_FAIL:  The linear solver''s setup routine failed in an"
               "   *                  unrecoverable manner."
               "   *"
               "   * CV_LSOLVE_FAIL:  The linear solver''s solve routine failed in an"
               "   *                  unrecoverable manner."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int CVode(void *cvode_mem, realtype tout, N_Vector yout,"
               "            realtype *tret, int itask);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : CVodeGetDky"
               "   * -----------------------------------------------------------------"
               "   * CVodeGetDky computes the kth derivative of the y function at"
               "   * time t, where tn-hu <= t <= tn, tn denotes the current"
               "   * internal time reached, and hu is the last internal step size"
               "   * successfully used by the solver. The user may request"
               "   * k=0, 1, ..., qu, where qu is the order last used. The"
               "   * derivative vector is returned in dky. This vector must be"
               "   * allocated by the caller. It is only legal to call this"
               "   * function after a successful return from CVode."
               "   *"
               "   * cvode_mem is the pointer to CVODE memory returned by"
               "   *           CVodeCreate."
               "   *"
               "   * t   is the time at which the kth derivative of y is evaluated."
               "   *     The legal range for t is [tn-hu,tn] as described above."
               "   *"
               "   * k   is the order of the derivative of y to be computed. The"
               "   *     legal range for k is [0,qu] as described above."
               "   *"
               "   * dky is the output derivative vector [((d/dy)^k)y](t)."
               "   *"
               "   * The return value for CVodeGetDky is one of:"
               "   *"
               "   *   CV_SUCCESS:  CVodeGetDky succeeded."
               "   *"
               "   *   CV_BAD_K:    k is not in the range 0, 1, ..., qu."
               "   *"
               "   *   CV_BAD_T:    t is not in the interval [tn-hu,tn]."
               "   *"
               "   *   CV_BAD_DKY:  The dky argument was NULL."
               "   *"
               "   *   CV_MEM_NULL: The cvode_mem argument was NULL."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int CVodeGetDky(void *cvode_mem, realtype t, int k, N_Vector dky);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Integrator optional output extraction functions"
               "   * -----------------------------------------------------------------"
               "   * The following functions can be called to get optional outputs"
               "   * and statistics related to the main integrator."
               "   * -----------------------------------------------------------------"
               "   * CVodeGetWorkSpace returns the CVODE real and integer workspaces"
               "   * CVodeGetNumSteps returns the cumulative number of internal"
               "   *                  steps taken by the solver"
               "   * CVodeGetNumRhsEvals returns the number of calls to the user''s"
               "   *                     f function"
               "   * CVodeGetNumLinSolvSetups returns the number of calls made to"
               "   *                          the linear solver''s setup routine"
               "   * CVodeGetNumErrTestFails returns the number of local error test"
               "   *                         failures that have occured"
               "   * CVodeGetLastOrder returns the order used during the last"
               "   *                   internal step"
               "   * CVodeGetCurrentOrder returns the order to be used on the next"
               "   *                      internal step"
               "   * CVodeGetNumStabLimOrderReds returns the number of order"
               "   *                             reductions due to stability limit"
               "   *                             detection"
               "   * CVodeGetActualInitStep returns the actual initial step size"
               "   *                        used by CVODE"
               "   * CVodeGetLastStep returns the step size for the last internal"
               "   *                  step"
               "   * CVodeGetCurrentStep returns the step size to be attempted on"
               "   *                     the next internal step"
               "   * CVodeGetCurrentTime returns the current internal time reached"
               "   *                     by the solver"
               "   * CVodeGetTolScaleFactor returns a suggested factor by which the"
               "   *                        user''s tolerances should be scaled when"
               "   *                        too much accuracy has been requested for"
               "   *                        some internal step"
               "   * CVodeGetErrWeights returns the current error weight vector."
               "   *                    The user must allocate space for eweight."
               "   * CVodeGetEstLocalErrors returns the vector of estimated local"
               "   *                        errors. The user must allocate space"
               "   *                        for ele."
               "   * CVodeGetNumGEvals returns the number of calls to the user''s"
               "   *                   g function (for rootfinding)"
               "   * CVodeGetRootInfo returns the indices for which g_i was found to "
               "   *                  have a root. The user must allocate space for "
               "   *                  rootsfound. For i = 0 ... nrtfn-1, "
               "   *                  rootsfound[i] = 1 if g_i has a root, and = 0 if not."
               "   *"
               "   * CVodeGet* return values:"
               "   *   CV_SUCCESS   if succesful"
               "   *   CV_MEM_NULL  if the cvode memory was NULL"
               "   *   CV_NO_SLDET  if stability limit was not turned on"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int CVodeGetWorkSpace(void *cvode_mem, long int *lenrw, long int *leniw);"
               "  int CVodeGetNumSteps(void *cvode_mem, long int *nsteps);"
               "  int CVodeGetNumRhsEvals(void *cvode_mem, long int *nfevals);"
               "  int CVodeGetNumLinSolvSetups(void *cvode_mem, long int *nlinsetups);"
               "  int CVodeGetNumErrTestFails(void *cvode_mem, long int *netfails);"
               "  int CVodeGetLastOrder(void *cvode_mem, int *qlast);"
               "  int CVodeGetCurrentOrder(void *cvode_mem, int *qcur);"
               "  int CVodeGetNumStabLimOrderReds(void *cvode_mem, long int *nslred);"
               "  int CVodeGetActualInitStep(void *cvode_mem, realtype *hinused);"
               "  int CVodeGetLastStep(void *cvode_mem, realtype *hlast);"
               "  int CVodeGetCurrentStep(void *cvode_mem, realtype *hcur);"
               "  int CVodeGetCurrentTime(void *cvode_mem, realtype *tcur);"
               "  int CVodeGetTolScaleFactor(void *cvode_mem, realtype *tolsfac);"
               "  int CVodeGetErrWeights(void *cvode_mem, N_Vector eweight);"
               "  int CVodeGetEstLocalErrors(void *cvode_mem, N_Vector ele);"
               "  int CVodeGetNumGEvals(void *cvode_mem, long int *ngevals);"
               "  int CVodeGetRootInfo(void *cvode_mem, int *rootsfound);"
               "  int CVodeGetfcallerid(void *cvode_mem,  int *fcallerid);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * As a convenience, the following functions provides the"
               "   * optional outputs in one group."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int CVodeGetIntegratorStats(void *cvode_mem, long int *nsteps,"
               "                              long int *nfevals, long int *nlinsetups,"
               "                              long int *netfails, int *qlast,"
               "                              int *qcur, realtype *hinused, realtype *hlast,"
               "                              realtype *hcur, realtype *tcur);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Nonlinear solver optional output extraction functions"
               "   * -----------------------------------------------------------------"
               "   * The following functions can be called to get optional outputs"
               "   * and statistics related to the nonlinear solver."
               "   * -----------------------------------------------------------------"
               "   * CVodeGetNumNonlinSolvIters returns the number of nonlinear"
               "   *                            solver iterations performed."
               "   * CVodeGetNumNonlinSolvConvFails returns the number of nonlinear"
               "   *                                convergence failures."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int CVodeGetNumNonlinSolvIters(void *cvode_mem, long int *nniters);"
               "  int CVodeGetNumNonlinSolvConvFails(void *cvode_mem, long int *nncfails);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * As a convenience, the following function provides the"
               "   * nonlinear solver optional outputs in a group."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int CVodeGetNonlinSolvStats(void *cvode_mem, long int *nniters,"
               "                              long int *nncfails);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * The following function returns the name of the constant "
               "   * associated with a CVODE return flag"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  char *CVodeGetReturnFlagName(int flag);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : CVodeFree"
               "   * -----------------------------------------------------------------"
               "   * CVodeFree frees the problem memory cvode_mem allocated by"
               "   * CVodeCreate and CVodeMalloc.  Its only argument is the pointer"
               "   * cvode_mem returned by CVodeCreate."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void CVodeFree(void **cvode_mem);"
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'cvode_impl.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * -----------------------------------------------------------------"
               " * Programmer(s): Scott D. Cohen, Alan C. Hindmarsh, Radu Serban"
               " *                and Dan Shumaker @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * Implementation header file for the main CVODE integrator."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _CVODE_IMPL_H"
               "#define _CVODE_IMPL_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include <stdarg.h>"
               ""
               "#include ""cvode.h"""
               ""
               "  /*"
               "   * ================================================================="
               "   *   M A I N    I N T E G R A T O R    M E M O R Y    B L O C K"
               "   * ================================================================="
               "   */"
               ""
               "  /* Basic CVODE constants */"
               ""
               "#define ADAMS_Q_MAX 12     /* max value of q for lmm == ADAMS     */"
               "#define BDF_Q_MAX    5     /* max value of q for lmm == BDF       */"
               "#define Q_MAX  ADAMS_Q_MAX /* max value of q for either lmm       */"
               "#define L_MAX  (Q_MAX+1)   /* max value of L for either lmm       */"
               "#define NUM_TESTS    5     /* number of error test quantities     */"
               ""
               "#define HMIN_DEFAULT     RCONST(0.0)    /* hmin default value     */"
               "#define HMAX_INV_DEFAULT RCONST(0.0)    /* hmax_inv default value */"
               "#define MXHNIL_DEFAULT   10             /* mxhnil default value   */"
               "#define MXSTEP_DEFAULT   500            /* mxstep default value   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Types : struct CVodeMemRec, CVodeMem"
               "   * -----------------------------------------------------------------"
               "   * The type CVodeMem is type pointer to struct CVodeMemRec."
               "   * This structure contains fields to keep track of problem state."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef struct CVodeMemRec {"
               ""
               "    realtype cv_uround;    /* machine unit roundoff */"
               ""
               "    /*-------------------------- "
               "      Problem Specification Data "
               "      --------------------------*/"
               ""
               "    CVRhsFn cv_f;        /* y'' = f(t,y(t))                    */"
               "    void *cv_f_data;     /* user pointer passed to f          */"
               "    int cv_lmm;          /* lmm = CV_ADAMS or CV_BDF          */"
               "    int cv_iter;         /* iter = CV_FUNCTIONAL or CV_NEWTON */"
               "    int cv_itol;         /* itol = CV_SS or CV_SV             */"
               ""
               "    realtype cv_reltol;  /* relative tolerance                */"
               "    realtype cv_Sabstol; /* scalar absolute tolerance         */"
               "    N_Vector cv_Vabstol; /* vector absolute tolerance         */"
               "    CVEwtFn cv_efun;     /* function to set ewt               */"
               "    void *cv_e_data;     /* user pointer passed to efun       */"
               ""
               "    /*-----------------------"
               "      Nordsieck History Array "
               "      -----------------------*/"
               ""
               "    N_Vector cv_zn[L_MAX];  /* Nordsieck array, of size N x (q+1).         */"
               "    /* zn[j] is a vector of length N (j=0,...,q)   */"
               "    /* zn[j] = [1/factorial(j)] * h^j * (jth       */ "
               "    /* derivative of the interpolating polynomial  */"
               ""
               "    /*--------------------------"
               "      other vectors of length N "
               "      -------------------------*/"
               ""
               "    N_Vector cv_ewt;     /* error weight vector                          */"
               "    N_Vector cv_y;       /* y is used as temporary storage by the solver */"
               "    /* The memory is provided by the user to CVode  */"
               "    /* where the vector is named yout.              */"
               "    N_Vector cv_acor;    /* In the context of the solution of the        */"
               "    /* nonlinear equation, acor = y_n(m) - y_n(0).  */"
               "    /* On return, this vector is scaled to give     */"
               "    /* the estimated local error in y.              */"
               "    N_Vector cv_tempv;   /* temporary storage vector                     */"
               "    N_Vector cv_ftemp;   /* temporary storage vector                     */"
               ""
               "    /*-----------------"
               "      Tstop information"
               "      -----------------*/"
               "    booleantype cv_tstopset;"
               "    booleantype cv_istop;"
               "    realtype cv_tstop;"
               ""
               "    /*---------"
               "      Step Data "
               "      ---------*/  "
               ""
               "    int cv_q;         /* current order                           */"
               "    int cv_qprime;    /* order to be used on the next step       */ "
               "    /* = q-1, q, or q+1                        */"
               "    int cv_next_q;    /* order to be used on the next step       */"
               "    int cv_qwait;     /* number of internal steps to wait before */"
               "    /* considering a change in q               */"
               "    int cv_L;         /* L = q + 1                               */"
               ""
               "    realtype cv_hin;    /* initial step size                      */"
               "    realtype cv_h;      /* current step size                      */"
               "    realtype cv_hprime; /* step size to be used on the next step  */ "
               "    realtype cv_next_h; /* step size to be used on the next step  */ "
               "    realtype cv_eta;    /* eta = hprime / h                       */"
               "    realtype cv_hscale; /* value of h used in zn                  */"
               "    realtype cv_tn;     /* current internal value of t            */"
               "    realtype cv_tretlast; /* value of tret last returned by CVode */"
               ""
               "    realtype cv_tau[L_MAX+1];    /* array of previous q+1 successful step     */"
               "    /* sizes indexed from 1 to q+1               */"
               "    realtype cv_tq[NUM_TESTS+1]; /* array of test quantities indexed from     */"
               "    /* 1 to NUM_TESTS(=5)                        */"
               "    realtype cv_l[L_MAX];        /* coefficients of l(x) (degree q poly)      */"
               ""
               "    realtype cv_rl1;     /* the scalar 1/l[1]            */"
               "    realtype cv_gamma;   /* gamma = h * rl1              */"
               "    realtype cv_gammap;  /* gamma at the last setup call */"
               "    realtype cv_gamrat;  /* gamma / gammap               */"
               ""
               "    realtype cv_crate;   /* estimated corrector convergence rate     */"
               "    realtype cv_acnrm;   /* | acor | wrms                            */"
               "    realtype cv_nlscoef; /* coeficient in nonlinear convergence test */"
               "    int  cv_mnewt;       /* Newton iteration counter                 */"
               ""
               "    /*------"
               "      Limits "
               "      ------*/"
               ""
               "    int cv_qmax;        /* q <= qmax                                          */"
               "    long int cv_mxstep; /* maximum number of internal steps for one user call */"
               "    int cv_maxcor;      /* maximum number of corrector iterations for the     */"
               "    /* solution of the nonlinear equation                 */"
               "    int cv_mxhnil;      /* maximum number of warning messages issued to the   */"
               "    /* user that t + h == t for the next internal step    */"
               "    int cv_maxnef;      /* maximum number of error test failures              */"
               "    int cv_maxncf;      /* maximum number of nonlinear convergence failures   */"
               ""
               "    realtype cv_hmin;     /* |h| >= hmin       */"
               "    realtype cv_hmax_inv; /* |h| <= 1/hmax_inv */"
               "    realtype cv_etamax;   /* eta <= etamax     */"
               ""
               "    /*--------"
               "      Counters "
               "      --------*/"
               ""
               "    long int cv_nst;              /* number of internal steps taken             */"
               "    long int cv_nfe;              /* number of f calls                          */"
               "    long int cv_ncfn;             /* number of corrector convergence failures   */"
               "    long int cv_netf;             /* number of error test failures              */"
               "    long int cv_nni;              /* number of Newton iterations performed      */"
               "    long int cv_nsetups;          /* number of setup calls                      */"
               "    int cv_nhnil;                 /* number of messages issued to the user that */"
               "    /* t + h == t for the next iternal step       */"
               ""
               "    realtype cv_etaqm1;      /* ratio of new to old h for order q-1        */"
               "    realtype cv_etaq;        /* ratio of new to old h for order q          */"
               "    realtype cv_etaqp1;      /* ratio of new to old h for order q+1        */"
               ""
               "    /*----------------------------"
               "      Space requirements for CVODE "
               "      ----------------------------*/"
               ""
               "    long int cv_lrw1;        /* no. of realtype words in 1 N_Vector         */ "
               "    long int cv_liw1;        /* no. of integer words in 1 N_Vector          */ "
               "    long int cv_lrw;         /* no. of realtype words in CVODE work vectors */"
               "    long int cv_liw;         /* no. of integer words in CVODE work vectors  */"
               ""
               "    /*------------------"
               "      Linear Solver Data "
               "      ------------------*/"
               ""
               "    /* Linear Solver functions to be called */"
               ""
               "    int (*cv_linit)(struct CVodeMemRec *cv_mem);"
               ""
               "    int (*cv_lsetup)(struct CVodeMemRec *cv_mem, int convfail, N_Vector ypred,"
               "                     N_Vector fpred, booleantype *jcurPtr, N_Vector vtemp1,"
               "                     N_Vector vtemp2, N_Vector vtemp3); "
               ""
               "    int (*cv_lsolve)(struct CVodeMemRec *cv_mem, N_Vector b, N_Vector weight,"
               "                     N_Vector ycur, N_Vector fcur);"
               ""
               "    void (*cv_lfree)(struct CVodeMemRec *cv_mem);"
               ""
               "    /* Linear Solver specific memory */"
               ""
               "    void *cv_lmem;           "
               ""
               "    /*------------"
               "      Saved Values"
               "      ------------*/"
               ""
               "    int cv_qu;             /* last successful q value used                        */"
               "    long int cv_nstlp;     /* step number of last setup call                      */"
               "    realtype cv_h0u;       /* actual initial stepsize                             */"
               "    realtype cv_hu;        /* last successful h value used                        */"
               "    realtype cv_saved_tq5; /* saved value of tq[5]                                */"
               "    booleantype cv_jcur;   /* Is the Jacobian info used by linear solver current? */"
               "    realtype cv_tolsf;     /* tolerance scale factor                              */"
               "    int cv_qmax_alloc;     /* value of qmax used when allocating memory           */"
               "    int cv_indx_acor;      /* index of the zn vector in which acor is saved       */"
               "    booleantype cv_setupNonNull; /* Does setup do something?                      */"
               ""
               "    booleantype cv_VabstolMallocDone;"
               "    booleantype cv_MallocDone;  "
               ""
               "    /*-------------------------------------------"
               "      Error handler function and error ouput file "
               "      -------------------------------------------*/"
               ""
               "    CVErrHandlerFn cv_ehfun;    /* Error messages are handled by ehfun     */"
               "    void *cv_eh_data;           /* user pointer passed to ehfun            */"
               "    FILE *cv_errfp;             /* CVODE error messages are sent to errfp  */"
               ""
               "    /*-------------------------"
               "      Stability Limit Detection"
               "      -------------------------*/"
               ""
               "    booleantype cv_sldeton;     /* Is Stability Limit Detection on?         */"
               "    realtype cv_ssdat[6][4];    /* scaled data array for STALD              */"
               "    int cv_nscon;               /* counter for STALD method                 */"
               "    long int cv_nor;            /* counter for number of order reductions   */"
               ""
               "    /*----------------"
               "      Rootfinding Data"
               "      ----------------*/"
               ""
               "    CVRootFn cv_gfun;     /* Function g for roots sought                     */"
               "    int cv_nrtfn;         /* number of components of g                       */"
               "    void *cv_g_data;      /* pointer to user data for g                      */"
               "    int *cv_iroots;       /* int array for root information                  */"
               "    realtype cv_tlo;      /* nearest endpoint of interval in root search     */"
               "    realtype cv_thi;      /* farthest endpoint of interval in root search    */"
               "    realtype cv_trout;    /* t value returned by rootfinding routine         */"
               "    realtype *cv_glo;     /* saved array of g values at t = tlo              */"
               "    realtype *cv_ghi;     /* saved array of g values at t = thi              */"
               "    realtype *cv_grout;   /* array of g values at t = trout                  */"
               "    realtype cv_toutc;    /* copy of tout (if NORMAL mode)                   */"
               "    realtype cv_ttol;     /* tolerance on root location                      */"
               "    int cv_taskc;         /* copy of parameter task                          */"
               "    int cv_irfnd;         /* flag showing whether last step had a root       */"
               "    long int cv_nge;      /* counter for g evaluations                       */"
               "    int cv_fcallerid;     /* indicates the ID of the function invoking the user supplied function  */"
               ""
               "  } *CVodeMem;"
               ""
               "  /*"
               "   * ================================================================="
               "   *     I N T E R F A C E   T O    L I N E A R   S O L V E R S"
               "   * ================================================================="
               "   */"
               "  "
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Communication between CVODE and a CVODE Linear Solver"
               "   * -----------------------------------------------------------------"
               "   * convfail (input to cv_lsetup)"
               "   *"
               "   * CV_NO_FAILURES : Either this is the first cv_setup call for this"
               "   *                  step, or the local error test failed on the"
               "   *                  previous attempt at this step (but the Newton"
               "   *                  iteration converged)."
               "   *"
               "   * CV_FAIL_BAD_J  : This value is passed to cv_lsetup if"
               "   *"
               "   *                  (a) The previous Newton corrector iteration"
               "   *                      did not converge and the linear solver''s"
               "   *                      setup routine indicated that its Jacobian-"
               "   *                      related data is not current"
               "   *                                   or"
               "   *                  (b) During the previous Newton corrector"
               "   *                      iteration, the linear solver''s solve routine"
               "   *                      failed in a recoverable manner and the"
               "   *                      linear solver''s setup routine indicated that"
               "   *                      its Jacobian-related data is not current."
               "   *"
               "   * CV_FAIL_OTHER  : During the current internal step try, the"
               "   *                  previous Newton iteration failed to converge"
               "   *                  even though the linear solver was using current"
               "   *                  Jacobian-related data."
               "   * -----------------------------------------------------------------"
               "   */"
               "  "
               "  /* Constants for convfail (input to cv_lsetup) */"
               "  "
               "#define CV_NO_FAILURES 0"
               "#define CV_FAIL_BAD_J  1"
               "#define CV_FAIL_OTHER  2"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * int (*cv_linit)(CVodeMem cv_mem);"
               "   * -----------------------------------------------------------------"
               "   * The purpose of cv_linit is to complete initializations for a"
               "   * specific linear solver, such as counters and statistics."
               "   * An LInitFn should return 0 if it has successfully initialized the"
               "   * CVODE linear solver and a negative value otherwise."
               "   * If an error does occur, an appropriate message should be sent to"
               "   * the error handler function."
               "   * -----------------------------------------------------------------"
               "   */"
               "  "
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * int (*cv_lsetup)(CVodeMem cv_mem, int convfail, N_Vector ypred,"
               "   *                 N_Vector fpred, booleantype *jcurPtr,"
               "   *                 N_Vector vtemp1, N_Vector vtemp2,"
               "   *                 N_Vector vtemp3);"
               "   * -----------------------------------------------------------------"
               "   * The job of cv_lsetup is to prepare the linear solver for"
               "   * subsequent calls to cv_lsolve. It may recompute Jacobian-"
               "   * related data is it deems necessary. Its parameters are as"
               "   * follows:"
               "   *"
               "   * cv_mem - problem memory pointer of type CVodeMem. See the"
               "   *          typedef earlier in this file."
               "   *"
               "   * convfail - a flag to indicate any problem that occurred during"
               "   *            the solution of the nonlinear equation on the"
               "   *            current time step for which the linear solver is"
               "   *            being used. This flag can be used to help decide"
               "   *            whether the Jacobian data kept by a CVODE linear"
               "   *            solver needs to be updated or not."
               "   *            Its possible values have been documented above."
               "   *"
               "   * ypred - the predicted y vector for the current CVODE internal"
               "   *         step."
               "   *"
               "   * fpred - f(tn, ypred)."
               "   *"
               "   * jcurPtr - a pointer to a boolean to be filled in by cv_lsetup."
               "   *           The function should set *jcurPtr=TRUE if its Jacobian"
               "   *           data is current after the call and should set"
               "   *           *jcurPtr=FALSE if its Jacobian data is not current."
               "   *           Note: If cv_lsetup calls for re-evaluation of"
               "   *           Jacobian data (based on convfail and CVODE state"
               "   *           data), it should return *jcurPtr=TRUE always;"
               "   *           otherwise an infinite loop can result."
               "   *"
               "   * vtemp1 - temporary N_Vector provided for use by cv_lsetup."
               "   *"
               "   * vtemp3 - temporary N_Vector provided for use by cv_lsetup."
               "   *"
               "   * vtemp3 - temporary N_Vector provided for use by cv_lsetup."
               "   *"
               "   * The cv_lsetup routine should return 0 if successful, a positive"
               "   * value for a recoverable error, and a negative value for an"
               "   * unrecoverable error."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * int (*cv_lsolve)(CVodeMem cv_mem, N_Vector b, N_Vector weight,"
               "   *                  N_Vector ycur, N_Vector fcur);"
               "   * -----------------------------------------------------------------"
               "   * cv_lsolve must solve the linear equation P x = b, where"
               "   * P is some approximation to (I - gamma J), J = (df/dy)(tn,ycur)"
               "   * and the RHS vector b is input. The N-vector ycur contains"
               "   * the solver''s current approximation to y(tn) and the vector"
               "   * fcur contains the N_Vector f(tn,ycur). The solution is to be"
               "   * returned in the vector b. cv_lsolve returns a positive value"
               "   * for a recoverable error and a negative value for an"
               "   * unrecoverable error. Success is indicated by a 0 return value."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * void (*cv_lfree)(CVodeMem cv_mem);"
               "   * -----------------------------------------------------------------"
               "   * cv_lfree should free up any memory allocated by the linear"
               "   * solver. This routine is called once a problem has been"
               "   * completed and the linear solver is no longer needed."
               "   * -----------------------------------------------------------------"
               "   */"
               "  "
               "  /*"
               "   * ================================================================="
               "   *   C V O D E    I N T E R N A L   F U N C T I O N S"
               "   * ================================================================="
               "   */"
               ""
               "  /* Prototype of internal ewtSet function */"
               ""
               "  int CVEwtSet(N_Vector ycur, N_Vector weight, void *e_data);"
               ""
               "  /* High level error handler */"
               ""
               "  void CVProcessError(CVodeMem cv_mem, "
               "                      int error_code, const char *module, const char *fname, "
               "                      const char *msgfmt, ...);"
               ""
               "  /* Prototype of internal errHandler function */"
               ""
               "  void CVErrHandler(int error_code, const char *module, const char *function, "
               "                    char *msg, void *eh_data);"
               ""
               "  /*"
               "   * ================================================================="
               "   *   C V O D E    E R R O R    M E S S A G E S"
               "   * ================================================================="
               "   */"
               ""
               "#if defined(SUNDIALS_EXTENDED_PRECISION)"
               ""
               "#define MSG_TIME      ""t = %Lg"""
               "#define MSG_TIME_H    ""t = %Lg and h = %Lg"""
               "#define MSG_TIME_INT  ""t = %Lg is not between tcur - hu = %Lg and tcur = %Lg."""
               "#define MSG_TIME_TOUT ""tout = %Lg"""
               ""
               "#elif defined(SUNDIALS_DOUBLE_PRECISION)"
               ""
               "#define MSG_TIME      ""t = %lg"""
               "#define MSG_TIME_H    ""t = %lg and h = %lg"""
               "#define MSG_TIME_INT  ""t = %lg is not between tcur - hu = %lg and tcur = %lg."""
               "#define MSG_TIME_TOUT ""tout = %lg"""
               ""
               "#else"
               ""
               "#define MSG_TIME      ""t = %g"""
               "#define MSG_TIME_H    ""t = %g and h = %g"""
               "#define MSG_TIME_INT  ""t = %g is not between tcur - hu = %g and tcur = %g."""
               "#define MSG_TIME_TOUT ""tout = %g"""
               ""
               "#endif"
               ""
               "  /* Initialization and I/O error messages */"
               ""
               "#define MSGCV_NO_MEM ""cvode_mem = NULL illegal."""
               "#define MSGCV_CVMEM_FAIL ""Allocation of cvode_mem failed."""
               "#define MSGCV_MEM_FAIL ""A memory request failed."""
               "#define MSGCV_BAD_LMM  ""Illegal value for lmm. The legal values are CV_ADAMS and CV_BDF."""
               "#define MSGCV_BAD_ITER  ""Illegal value for iter. The legal values are CV_FUNCTIONAL and CV_NEWTON."""
               "#define MSGCV_BAD_ITOL ""Illegal value for itol. The legal values are CV_SS, CV_SV, and CV_WF."""
               "#define MSGCV_NO_MALLOC ""Attempt to call before CVodeMalloc."""
               "#define MSGCV_NEG_MAXORD ""maxord <= 0 illegal."""
               "#define MSGCV_BAD_MAXORD  ""Illegal attempt to increase maximum method order."""
               "#define MSGCV_NEG_MXSTEPS ""mxsteps < 0 illegal."""
               "#define MSGCV_SET_SLDET  ""Attempt to use stability limit detection with the CV_ADAMS method illegal."""
               "#define MSGCV_NEG_HMIN ""hmin < 0 illegal."""
               "#define MSGCV_NEG_HMAX ""hmax < 0 illegal."""
               "#define MSGCV_BAD_HMIN_HMAX ""Inconsistent step size limits: hmin > hmax."""
               "#define MSGCV_BAD_RELTOL ""reltol < 0 illegal."""
               "#define MSGCV_BAD_ABSTOL ""abstol has negative component(s) (illegal)."""
               "#define MSGCV_NULL_ABSTOL ""abstol = NULL illegal."""
               "#define MSGCV_NULL_Y0 ""y0 = NULL illegal."""
               "#define MSGCV_NULL_F ""f = NULL illegal."""
               "#define MSGCV_NULL_G ""g = NULL illegal."""
               "#define MSGCV_BAD_NVECTOR ""A required vector operation is not implemented."""
               "#define MSGCV_BAD_K ""Illegal value for k."""
               "#define MSGCV_NULL_DKY ""dky = NULL illegal."""
               "#define MSGCV_BAD_T ""Illegal value for t."" MSG_TIME_INT"
               ""
               "  /* CVode Error Messages */"
               ""
               "#define MSGCV_LSOLVE_NULL ""The linear solver''s solve routine is NULL."""
               "#define MSGCV_YOUT_NULL ""yout = NULL illegal."""
               "#define MSGCV_TRET_NULL ""tret = NULL illegal."""
               "#define MSGCV_BAD_EWT ""Initial ewt has component(s) equal to zero (illegal)."""
               "#define MSGCV_EWT_NOW_BAD ""At "" MSG_TIME "", a component of ewt has become <= 0."""
               "#define MSGCV_BAD_ITASK ""Illegal value for itask."""
               "#define MSGCV_BAD_H0 ""h0 and tout - t0 inconsistent."""
               "#define MSGCV_BAD_INIT_ROOT ""Root found at and very near initial t."""
               "#define MSGCV_BAD_TOUT ""Trouble interpolating at "" MSG_TIME_TOUT "". tout too far back in direction of integration"""
               "#define MSGCV_NO_EFUN ""itol = CV_WF but no EwtSet function was provided."""
               "#define MSGCV_NO_TSTOP ""itask = CV_NORMAL_TSTOP or itask = CV_ONE_STEP_TSTOP but tstop was not set."""
               "#define MSGCV_EWT_FAIL ""The user-provide EwtSet function failed."""
               "#define MSGCV_EWT_NOW_FAIL ""At "" MSG_TIME "", the user-provide EwtSet function failed."""
               "#define MSGCV_LINIT_FAIL ""The linear solver''s init routine failed."""
               "#define MSGCV_HNIL_DONE ""The above warning has been issued mxhnil times and will not be issued again for this problem."""
               "#define MSGCV_TOO_CLOSE ""tout too close to t0 to start integration."""
               "#define MSGCV_MAX_STEPS ""At "" MSG_TIME "", mxstep steps taken before reaching tout."""
               "#define MSGCV_TOO_MUCH_ACC ""At "" MSG_TIME "", too much accuracy requested."""
               "#define MSGCV_HNIL ""Internal "" MSG_TIME_H "" are such that t + h = t on the next step. The solver will continue anyway."""
               "#define MSGCV_ERR_FAILS ""At "" MSG_TIME_H "", the error test failed repeatedly or with |h| = hmin."""
               "#define MSGCV_CONV_FAILS ""At "" MSG_TIME_H "", the corrector convergence test failed repeatedly or with |h| = hmin."""
               "#define MSGCV_SETUP_FAILED ""At "" MSG_TIME "", the setup routine failed in an unrecoverable manner."""
               "#define MSGCV_SOLVE_FAILED ""At "" MSG_TIME "", the solve routine failed in an unrecoverable manner."""
               "#define MSGCV_RHSFUNC_FAILED ""At "" MSG_TIME "", the right-hand side routine failed in an unrecoverable manner."""
               "#define MSGCV_RHSFUNC_UNREC ""At "" MSG_TIME "", the right-hand side failed in a recoverable manner, but no recovery is possible."""
               "#define MSGCV_RHSFUNC_REPTD ""At "" MSG_TIME ""repeated recoverable right-hand side function errors."""
               "#define MSGCV_RHSFUNC_FIRST ""The right-hand side routine failed at the first call."""
               "#define MSGCV_RTFUNC_FAILED ""At "" MSG_TIME "", the rootfinding routine failed in an unrecoverable manner."""
               "#define MSGCV_CLOSE_ROOTS ""Root found at and very near "" MSG_TIME ""."""
               "#define MSGCV_BAD_TSTOP ""tstop is behind current "" MSG_TIME ""in the direction of integration."""
               ""
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'dopri5m.h' then
        txt = ["/*      dopri5"
               "	------"
               ""
               ""
               "This code computes the numerical solution of a system of first order ordinary"
               "differential equations y''=f(x,y). It uses an explicit Runge-Kutta method of"
               "order (4)5 due to Dormand & Prince with step size control and dense output."
               ""
               "Authors : E. Hairer & G. Wanner"
               "	  Universite de Geneve, dept. de Mathematiques"
               "	  CH-1211 GENEVE 4, SWITZERLAND"
               "	  E-mail : HAIRER@DIVSUN.UNIGE.CH, WANNER@DIVSUN.UNIGE.CH"
               ""
               "The code is described in : E. Hairer, S.P. Norsett and G. Wanner, Solving"
               "ordinary differential equations I, nonstiff problems, 2nd edition,"
               "Springer Series in Computational Mathematics, Springer-Verlag (1993)."
               ""
               "Version of April 28, 1994."
               ""
               "Remarks about the C version : this version allocates memory by itself, the"
               "iwork array (among the initial FORTRAN parameters) has been splitted into"
               "independant initial parameters, the statistical variables and last step size"
               "and x have been encapsulated in the module and are now accessible through"
               "dedicated functions, the variable names have been kept to maintain a kind"
               "of reading compatibility between the C and FORTRAN codes; adaptation made by"
               "J.Colinge (COLINGE@DIVSUN.UNIGE.CH)."
               ""
               ""
               ""
               "INPUT PARAMETERS"
               "----------------"
               ""
               "n        Dimension of the system (n < UINT_MAX)."
               ""
               "fcn      A pointer the the function definig the differential equation, this"
               "	 function must have the following prototype"
               ""
               "	   void fcn (unsigned n, double x, double *y, double *f)"
               ""
               "	 where the array f will be filled with the function result."
               ""
               "x        Initial x value."
               ""
               "*y       Initial y values (double y[n])."
               ""
               "xend     Final x value (xend-x may be positive or negative)."
               ""
               "*rtoler  Relative and absolute error tolerances. They can be both scalars or"
               "*atoler  vectors of length n (in the scalar case pass the addresses of"
               "	 variables where you have placed the tolerance values)."
               ""
               "itoler   Switch for atoler and rtoler :"
               "	   itoler=0 : both atoler and rtoler are scalars, the code keeps"
               "		      roughly the local error of y[i] below"
               "		      rtoler*abs(y[i])+atoler."
               "	   itoler=1 : both rtoler and atoler are vectors, the code keeps"
               "		      the local error of y[i] below"
               "		      rtoler[i]*abs(y[i])+atoler[i]."
               ""
               "solout   A pointer to the output function called during integration."
               "	 If iout >= 1, it is called after every successful step. If iout = 0,"
               "	 pass a pointer equal to NULL. solout must must have the following"
               "	 prototype"
               ""
               "	   solout (long nr, double xold, double x, double* y, unsigned n, int* irtrn)"
               ""
               "	 where y is the solution the at nr-th grid point x, xold is the"
               "	 previous grid point and irtrn serves to interrupt the integration"
               "	 (if set to a negative value)."
               ""
               "	 Continuous output : during the calls to solout, a continuous solution"
               "	 for the interval (xold,x) is available through the function"
               ""
               "	   contd5(i,s)"
               ""
               "	 which provides an approximation to the i-th component of the solution"
               "	 at the point s (s must lie in the interval (xold,x))."
               ""
               "iout     Switch for calling solout :"
               "	   iout=0 : no call,"
               "	   iout=1 : solout only used for output,"
               "	   iout=2 : dense output is performed in solout (in this case nrdens"
               "		    must be greater than 0)."
               ""
               "fileout  A pointer to the stream used for messages, if you do not want any"
               "	 message, just pass NULL."
               ""
               "icont    An array containing the indexes of components for which dense"
               "	 output is required. If no dense output is required, pass NULL."
               ""
               "licont   The number of cells in icont."
               ""
               ""
               "Sophisticated setting of parameters"
               "-----------------------------------"
               ""
               "	 Several parameters have a default value (if set to 0) but, to better"
               "	 adapt the code to your problem, you can specify particular initial"
               "	 values."
               ""
               "uround   The rounding unit, default 2.3E-16 (this default value can be"
               "	 replaced in the code by DBL_EPSILON providing float.h defines it"
               "	 in your system)."
               ""
               "safe     Safety factor in the step size prediction, default 0.9."
               ""
               "fac1     Parameters for step size selection; the new step size is chosen"
               "fac2     subject to the restriction  fac1 <= hnew/hold <= fac2."
               "	 Default values are fac1=0.2 and fac2=10.0."
               ""
               "beta     The ""beta"" for stabilized step size control (see section IV.2 of our"
               "	 book). Larger values for beta ( <= 0.1 ) make the step size control"
               "	 more stable. dopri5 needs a larger beta than Higham & Hall. Negative"
               "	 initial value provoke beta=0; default beta=0.04."
               ""
               "hmax     Maximal step size, default xend-x."
               ""
               "h        Initial step size, default is a guess computed by the function hinit."
               ""
               "nmax     Maximal number of allowed steps, default 100000."
               ""
               "meth     Switch for the choice of the method coefficients; at the moment the"
               "	 only possibility and default value are 1."
               ""
               "nstiff   Test for stiffness is activated when the current step number is a"
               "	 multiple of nstiff. A negative value means no test and the default"
               "	 is 1000."
               ""
               "nrdens   Number of components for which dense outpout is required, default 0."
               "	 For 0 < nrdens < n, the components have to be specified in icont[0],"
               "	 icont[1], ... icont[nrdens-1]. Note that if nrdens=0 or nrdens=n, no"
               "	 icont is needed, pass NULL."
               ""
               ""
               "Memory requirements"
               "-------------------"
               ""
               "	 The function dopri5 allocates dynamically 8*n doubles for the method"
               "	 stages, 5*nrdens doubles for the interpolation if dense output is"
               "	 performed and n unsigned if 0 < nrdens < n."
               ""
               ""
               ""
               "OUTPUT PARAMETERS"
               "-----------------"
               ""
               "y       numerical solution at x=xRead() (see below)."
               ""
               "dopri5 returns the following values"
               ""
               "	 1 : computation successful,"
               "	 2 : computation successful interrupted by solout,"
               "	-1 : input is not consistent,"
               "	-2 : larger nmax is needed,"
               "	-3 : step size becomes too small,"
               "	-4 : the problem is probably stff (interrupted)."
               ""
               ""
               "Several functions provide access to different values :"
               ""
               "xRead   x value for which the solution has been computed (x=xend after"
               "	successful return)."
               ""
               "hRead   Predicted step size of the last accepted step (useful for a"
               "	subsequent call to dopri5)."
               ""
               "nstepRead   Number of used steps."
               "naccptRead  Number of accepted steps."
               "nrejctRead  Number of rejected steps."
               "nfcnRead    Number of function calls."
               ""
               ""
               "*/"
               ""
               ""
               "#include <stdio.h>"
               "#include <limits.h>"
               ""
               "#define DP5_SUCCESS            251"
               "#define DP5_ROOT_RETURN        252"
               "#define DP5_ZERO_DETACH_RETURN 253"
               ""
               "#define DP5_TOO_MUCH_WORK    -251"
               "#define DP5_TOO_MUCH_ACC     -252"
               "#define DP5_ILL_INPUT        -253"
               "#define DP5_ERR_FAILURE      -254 "
               "#define DP5_CONV_FAILURE     -255"
               "#define DP5_BAD_EWT          -256"
               "#define DP5_I_R_HOT_SHORT    -257"
               "#define DP5_RTFUNC_FAIL      -258"
               "#define DP5_BAD_INIT_ROOT    -259"
               "#define DP5_CLOSE_ROOTS      -260"
               ""
               "typedef void (*FcnEqDiff)(unsigned n, double x, double *y, double *f, void *udata);"
               "typedef int (*FcnZeroC)(unsigned n, double x, double *y, double *g, void *udata);"
               ""
               "typedef struct {"
               "  double    *rcont1, *rcont2, *rcont3, *rcont4, *rcont5;"
               "  double    x, xstop, x_old, *y, *yy1, *k1, *k2, *k3, *k4, *k5, *k6, *ysti, *tmp;"
               "  double    *atoler, rtoler, h, h_old, hmax, facold, uround;"
               "  double    beta, safe, fac1, fac2, posneg;"
               "  int       itoler,meth;"
               "  long      nfcn, nstep, naccpt, nrejct, nmax,nstiff,nonsti,iasti;"
               "  unsigned  n, ng;"
               "  int *iroots, irfnd;"
               "  double *glo, *ghi, *grout, tlo, thi, trout, ttol, tretlast;"
               "  FcnEqDiff fcn;"
               "  FcnZeroC  gcn;"
               "  FILE* fileout;"
               "  int  fcallerid;"
               "  void *udata;"
               "} DOPRI5_mem;"
               ""
               "typedef struct {"
               "  void *dopri5_mem;"
               "} User_DP5_data;"
               ""
               ""
               "#include <float.h>"
               ""
               "#define DORI5_DOUBLE_PRECISION 1"
               ""
               "#if defined(DORI5_SINGLE_PRECISION)"
               "#define RCONST(x) x##F"
               "#define BIG_REAL FLT_MAX"
               "#define SMALL_REAL FLT_MIN"
               "#define UNIT_ROUNDOFF FLT_EPSILON"
               ""
               "#elif defined(DORI5_DOUBLE_PRECISION)"
               ""
               "#define RCONST(x) x"
               "#define BIG_REAL DBL_MAX"
               "#define SMALL_REAL DBL_MIN"
               "#define UNIT_ROUNDOFF DBL_EPSILON"
               ""
               "#elif defined(DORI5_EXTENDED_PRECISION)"
               ""
               "#define RCONST(x) x##L"
               "#define BIG_REAL LDBL_MAX"
               "#define SMALL_REAL LDBL_MIN"
               "#define UNIT_ROUNDOFF LDBL_EPSILON"
               ""
               "#endif"
               ""
               ""
               ""
               "long nfcnRead   (DOPRI5_mem *dopri5_mem);"
               "long nstepRead  (DOPRI5_mem *dopri5_mem);"
               "long naccptRead (DOPRI5_mem *dopri5_mem);"
               "long nrejctRead (DOPRI5_mem *dopri5_mem);"
               "double hRead  (DOPRI5_mem *dopri5_mem);"
               "double xRead  (DOPRI5_mem *dopri5_mem);"
               "int set_tstop (DOPRI5_mem *dopri5_mem, double xstop);"
               ""
               "double hinit (DOPRI5_mem *dopri5_mem, int iord);"
               "double contd5 (DOPRI5_mem *dopri5_mem, unsigned i, double x, double xold, double h);"
               "int dopri5_solve (DOPRI5_mem *dopri5_mem,double *xio, double xout, double* yio, int hot_start);"
               ""
               "int  Setup_dopri5(DOPRI5_mem **dopri5_mem, unsigned n, FcnEqDiff fcn, double xstart,double xend,"
               "		  double rtoler, double* atoler, int itoler,  double hmax, unsigned ng, FcnZeroC gcn,"
               "		  User_DP5_data **dopri5_udata);"
               ""
               "int dopri5_free (DOPRI5_mem *dopri5_mem);"
               "int DP5_Get_RootInfo (DOPRI5_mem *dopri5_mem, int *jroot);"
               "int DP5_Get_fcallerid(DOPRI5_mem *dopri5_mem,  int *fcallerid);"
               ""]

      case 'ida_dense.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * ----------------------------------------------------------------- "
               " * Programmer(s): Alan C. Hindmarsh and Radu Serban @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * This is the header file for the IDA dense linear solver module, "
               " * IDADENSE."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _IDADENSE_H"
               "#define _IDADENSE_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include ""sundials_dense.h"""
               "#include ""sundials_nvector.h"""
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * IDADENSE return values"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "#define IDADENSE_SUCCESS           0"
               "#define IDADENSE_MEM_NULL         -1 "
               "#define IDADENSE_LMEM_NULL        -2 "
               "#define IDADENSE_ILL_INPUT        -3"
               "#define IDADENSE_MEM_FAIL         -4"
               ""
               "  /* Additional last_flag values */"
               ""
               "#define IDADENSE_JACFUNC_UNRECVR  -5"
               "#define IDADENSE_JACFUNC_RECVR    -6"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Type : IDADenseJacFn"
               "   * -----------------------------------------------------------------"
               "   * A dense Jacobian approximation function djac must have the     "
               "   * prototype given below. Its parameters are:                     "
               "   *                                                                "
               "   * Neq is the problem size, and length of all vector arguments.   "
               "   *                                                                "
               "   * tt  is the current value of the independent variable t.        "
               "   *                                                                "
               "   * yy  is the current value of the dependent variable vector,     "
               "   *     namely the predicted value of y(t).                     "
               "   *                                                                "
               "   * yp  is the current value of the derivative vector y'',          "
               "   *     namely the predicted value of y''(t).                    "
               "   *                                                                "
               "   * rr  is the residual vector F(tt,yy,yp).                     "
               "   *                                                                "
               "   * c_j is the scalar in the system Jacobian, proportional to 1/hh."
               "   *                                                                "
               "   * jac_data  is a pointer to user Jacobian data - the same as the    "
               "   *     jdata parameter passed to IDADense.                     "
               "   *                                                                "
               "   * Jac is the dense matrix (of type DenseMat) to be loaded by  "
               "   *     an IDADenseJacFn routine with an approximation to the   "
               "   *     system Jacobian matrix                                  "
               "   *            J = dF/dy + c_j*dF/dy''                            "
               "   *     at the given point (t,y,y''), where the DAE system is    "
               "   *     given by F(t,y,y'') = 0.  Jac is preset to zero, so only "
               "   *     the nonzero elements need to be loaded.  See note below."
               "   *                                                                "
               "   * tmp1, tmp2, tmp3 are pointers to memory allocated for          "
               "   *     N_Vectors which can be used by an IDADenseJacFn routine "
               "   *     as temporary storage or work space.                     "
               "   *                                                                "
               "   * NOTE: The following are two efficient ways to load Jac:         "
               "   * (1) (with macros - no explicit data structure references)      "
               "   *     for (j=0; j < Neq; j++) {                                  "
               "   *       col_j = DENSE_COL(Jac,j);                                 "
               "   *       for (i=0; i < Neq; i++) {                                "
               "   *         generate J_ij = the (i,j)th Jacobian element           "
               "   *         col_j[i] = J_ij;                                       "
               "   *       }                                                        "
               "   *     }                                                          "
               "   * (2) (without macros - explicit data structure references)      "
               "   *     for (j=0; j < Neq; j++) {                                  "
               "   *       col_j = (Jac->data)[j];                                   "
               "   *       for (i=0; i < Neq; i++) {                                "
               "   *         generate J_ij = the (i,j)th Jacobian element           "
               "   *         col_j[i] = J_ij;                                       "
               "   *       }                                                        "
               "   *     }                                                          "
               "   * A third way, using the DENSE_ELEM(A,i,j) macro, is much less   "
               "   * efficient in general.  It is only appropriate for use in small "
               "   * problems in which efficiency of access is NOT a major concern. "
               "   *                                                                "
               "   * NOTE: If the user''s Jacobian routine needs other quantities,   "
               "   *     they are accessible as follows: hcur (the current stepsize)"
               "   *     and ewt (the error weight vector) are accessible through   "
               "   *     IDAGetCurrentStep and IDAGetErrWeights, respectively (see  "
               "   *     ida.h). The unit roundoff is available as                  "
               "   *     UNIT_ROUNDOFF defined in sundials_types.h                   "
               "   *                                                                "
               "   * The IDADenseJacFn should return                                "
               "   *     0 if successful,                                           "
               "   *     a positive int if a recoverable error occurred, or         "
               "   *     a negative int if a nonrecoverable error occurred.         "
               "   * In the case of a recoverable error return, the integrator will "
               "   * attempt to recover by reducing the stepsize (which changes cj)."
               "   * -----------------------------------------------------------------"
               "   */"
               "  "
               "  typedef int (*IDADenseJacFn)(long int Neq, realtype tt, "
               "                               N_Vector yy, N_Vector yp, N_Vector rr,"
               "                               realtype c_j, void *jac_data, "
               "                               DenseMat Jac, "
               "                               N_Vector tmp1, N_Vector tmp2, "
               "                               N_Vector tmp3);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : IDADense"
               "   * -----------------------------------------------------------------"
               "   * A call to the IDADense function links the main integrator      "
               "   * with the IDADENSE linear solver module.                        "
               "   *                                                                "
               "   * ida_mem is the pointer to integrator memory returned by        "
               "   *     IDACreate.                                                 "
               "   *                                                                "
               "   * Neq  is the problem size                                       "
               "   *                                                                "
               "   * IDADense returns:                                              "
               "   *     IDADENSE_SUCCESS   = 0  if successful                              "
               "   *     IDADENSE_LMEM_FAIL = -1 if there was a memory allocation failure   "
               "   *     IDADENSE_ILL_INPUT = -2 if NVECTOR found incompatible           "
               "   *                                                                "
               "   * NOTE: The dense linear solver assumes a serial implementation  "
               "   *       of the NVECTOR package. Therefore, IDADense will first"
               "   *       test for a compatible N_Vector internal representation"
               "   *       by checking that the functions N_VGetArrayPointer and"
               "   *       N_VSetArrayPointer exist."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int IDADense(void *ida_mem, long int Neq); "
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Optional inputs to the IDADENSE linear solver"
               "   * -----------------------------------------------------------------"
               "   * IDADenseSetJacFn specifies the dense Jacobian approximation    "
               "   *        routine to be used. A user-supplied djac routine must   "
               "   *        be of type IDADenseJacFn.                               "
               "   *        By default, a difference quotient routine IDADenseDQJac,"
               "   *        supplied with this solver is used.                      "
               "   *        It also specifies a pointer to user data which is   "
               "   *        passed to the djac routine every time it is called.     "
               "   *                                                                "
               "   * The return value of IDADenseSet* is one of:"
               "   *    IDADENSE_SUCCESS   if successful"
               "   *    IDADENSE_MEM_NULL  if the ida memory was NULL"
               "   *    IDaDENSE_LMEM_NULL if the idadense memory was NULL"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int IDADenseSetJacFn(void *ida_mem, IDADenseJacFn djac, void *jac_data);"
               " "
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Optional outputs from the IDADENSE linear solver"
               "   * -----------------------------------------------------------------"
               "   * IDADenseGetWorkSpace returns the real and integer workspace used "
               "   *     by IDADENSE.                                                  "
               "   * IDADenseGetNumJacEvals returns the number of calls made to the "
               "   *     Jacobian evaluation routine djac.                          "
               "   * IDADenseGetNumResEvals returns the number of calls to the user "
               "   *     res routine due to finite difference Jacobian evaluation.  "
               "   * IDADenseGetLastFlag returns the last error flag set by any of"
               "   *     the IDADENSE interface functions."
               "   *"
               "   * The return value of IDADenseGet* is one of:"
               "   *    IDADENSE_SUCCESS   if successful"
               "   *    IDADENSE_MEM_NULL  if the ida memory was NULL"
               "   *    IDaDENSE_LMEM_NULL if the idadense memory was NULL"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int IDADenseGetWorkSpace(void *ida_mem, long int *lenrwLS, long int *leniwLS);"
               "  int IDADenseGetNumJacEvals(void *ida_mem, long int *njevals);"
               "  int IDADenseGetNumResEvals(void *ida_mem, long int *nrevalsLS);"
               "  int IDADenseGetLastFlag(void *ida_mem, int *flag);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * The following function returns the name of the constant "
               "   * associated with a IDADENSE return flag"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  char *IDADenseGetReturnFlagName(int flag);"
               ""
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'ida_dense_impl.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * ----------------------------------------------------------------- "
               " * Programmers: Alan C. Hindmarsh and Radu Serban @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California  "
               " * Produced at the Lawrence Livermore National Laboratory"
               " * All rights reserved"
               " * For details, see the LICENSE file"
               " * -----------------------------------------------------------------"
               " * This is the header file (private version) for the IDA dense"
               " * linear solver module, IDADENSE."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _IDADENSE_IMPL_H"
               "#define _IDADENSE_IMPL_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include <stdio.h>"
               ""
               "#include ""ida_dense.h"""
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Types : IDADenseMemRec, IDADenseMem                             "
               " * -----------------------------------------------------------------"
               " */"
               ""
               "typedef struct {"
               ""
               "  long int d_neq;        /* Neq = problem dimension              */"
               ""
               "  IDADenseJacFn d_jac;   /* jac = Jacobian routine to be called  */"
               "  "
               "  DenseMat d_J;          /* J = dF/dy + cj*dF/dy''                */"
               "  "
               "  long int *d_pivots;    /* pivots = pivot array for PJ = LU     */"
               "  "
               "  long int d_nje;        /* nje = no. of calls to jac            */"
               "  "
               "  long int d_nreD;       /* nreD = no. of calls to res due to "
               "                            diff. quotient Jacobian evaluation   */"
               ""
               "  void *d_jdata;         /* jdata is passed to jac               */"
               ""
               "  int d_last_flag;       /* last error return flag               */"
               ""
               "} IDADenseMemRec, *IDADenseMem;"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Error Messages"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#define MSGD_IDAMEM_NULL ""Integrator memory is NULL."""
               "#define MSGD_MEM_FAIL    ""A memory request failed."""
               "#define MSGD_BAD_NVECTOR ""A required vector operation is not implemented."""
               "#define MSGD_LMEM_NULL   ""IDADENSE memory is NULL."""
               "#define MSGD_JACFUNC_FAILED ""The Jacobian routine failed in an unrecoverable manner."""
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'ida.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * ----------------------------------------------------------------- "
               " * Programmer(s): Allan G. Taylor, Alan C. Hindmarsh, Radu Serban,"
               " *                and Aaron Collier @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California  "
               " * Produced at the Lawrence Livermore National Laboratory"
               " * All rights reserved"
               " * For details, see the LICENSE file"
               " * -----------------------------------------------------------------"
               " * This is the header (include) file for the main IDA solver."
               " * -----------------------------------------------------------------"
               " *"
               " * IDA is used to solve numerically the initial value problem     "
               " * for the differential algebraic equation (DAE) system           "
               " *   F(t,y,y'') = 0,                                               "
               " * given initial conditions                                       "
               " *   y(t0) = y0,   y''(t0) = yp0.                                  "
               " * Here y and F are vectors of length N.                          "
               " *"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _IDA_H"
               "#define _IDA_H"
               ""
               "#ifdef __cplusplus     /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include <stdio.h>"
               ""
               "#include ""sundials_nvector.h"""
               ""
               "  /*"
               "   * ================================================================="
               "   *              I D A     C O N S T A N T S"
               "   * ================================================================="
               "   */"
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * Inputs to IDAMalloc, IDAReInit, IDACalcIC, and IDASolve.       "
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  /* itol */"
               "#define IDA_SS               1"
               "#define IDA_SV               2"
               "#define IDA_WF               3"
               ""
               "  /* itask */"
               "#define IDA_NORMAL           1"
               "#define IDA_ONE_STEP         2"
               "#define IDA_NORMAL_TSTOP     3 "
               "#define IDA_ONE_STEP_TSTOP   4"
               ""
               "  /* icopt */"
               "#define IDA_YA_YDP_INIT      1 "
               "#define IDA_Y_INIT           2"
               ""
               "  /* "
               "   * ----------------------------------------"
               "   * IDA return flags "
               "   * ----------------------------------------"
               "   */"
               ""
               "#define IDA_SUCCESS              0"
               "#define IDA_TSTOP_RETURN         1"
               "#define IDA_ROOT_RETURN          2"
               "#define IDA_ZERO_DETACH_RETURN   3"
               "#define IDA_WARNING              99"
               ""
               "#define IDA_MEM_NULL        -1"
               "#define IDA_ILL_INPUT       -2"
               "#define IDA_NO_MALLOC       -3"
               "#define IDA_TOO_MUCH_WORK   -4"
               "#define IDA_TOO_MUCH_ACC    -5"
               "#define IDA_ERR_FAIL        -6"
               "#define IDA_CONV_FAIL       -7"
               "#define IDA_LINIT_FAIL      -8"
               "#define IDA_LSETUP_FAIL     -9"
               "#define IDA_LSOLVE_FAIL     -10"
               "#define IDA_RES_FAIL        -11"
               "#define IDA_CONSTR_FAIL     -12"
               "#define IDA_REP_RES_ERR     -13"
               ""
               "#define IDA_MEM_FAIL        -14"
               ""
               "#define IDA_BAD_T           -15"
               ""
               "#define IDA_BAD_EWT         -16"
               "#define IDA_FIRST_RES_FAIL  -17"
               "#define IDA_LINESEARCH_FAIL -18"
               "#define IDA_NO_RECOVERY     -19"
               ""
               "#define IDA_RTFUNC_FAIL     -20"
               ""
               "  /* added by masoud*/"
               "#define IDA_YOUT_NULL            -28"
               "#define IDA_TRET_NULL            -29"
               "#define IDA_BAD_ITASK            -30"
               "#define IDA_NO_TSTOP             -31"
               "#define IDA_BAD_H0               -32"
               "#define IDA_BAD_TSTOP            -33"
               "#define IDA_BAD_INIT_ROOT        -34"
               "#define IDA_NO_EFUN              -35"
               "#define IDA_EWT_FAIL             -36"
               "#define IDA_LSOLVE_NULL          -38"
               "#define IDA_NULL_Y0              -39"
               "#define IDA_BAD_ITOL             -40"
               "#define IDA_NULL_F               -41"
               "#define IDA_BAD_NVECTOR          -42"
               "#define IDA_NULL_ABSTOL          -43"
               "#define IDA_BAD_RELTOL           -44"
               "#define IDA_BAD_ABSTOL           -45"
               "#define IDA_NULL_G               -46"
               "#define IDA_BAD_TOUT             -47"
               "#define IDA_YP0_NULL             -48 "
               "#define IDA_RES_NULL             -49"
               "#define IDA_YRET_NULL            -50"
               "#define IDA_YPRET_NULL           -51"
               "#define IDA_BAD_HINIT            -52"
               "#define IDA_MISSING_ID           -53"
               "#define IDA_Y0_FAIL_CONSTR       -54"
               "#define IDA_TOO_CLOSE            -55"
               "#define IDA_CLOSE_ROOTS          -56"
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * Type : IDAResFn                                                   "
               "   * ----------------------------------------------------------------"
               "   * The F function which defines the DAE system   F(t,y,y'')=0      "
               "   * must have type IDAResFn.                                          "
               "   * Symbols are as follows: "
               "   *                  t  <-> t        y <-> yy               "
               "   *                  y'' <-> yp       F <-> rr"
               "   * A IDAResFn takes as input the independent variable value t,    "
               "   * the dependent variable vector yy, and the derivative (with     "
               "   * respect to t) of the yy vector, yp.  It stores the result of   "
               "   * F(t,y,y'') in the vector rr. The yy, yp, and rr arguments are of "
               "   * type N_Vector. The res_data parameter is the pointer res_data "
               "   * passed by the user to the IDASetRdata routine. This user-supplied "
               "   * pointer is passed to the user''s res function every time it is called, "
               "   * to provide access in res to user data.                                    "
               "   *                                                                "
               "   * A IDAResFn res should return a value of 0 if successful, a positive"
               "   * value if a recoverable error occured (e.g. yy has an illegal value),"
               "   * or a negative value if a nonrecoverable error occured. In the latter"
               "   * case, the program halts. If a recoverable error occured, the integrator"
               "   * will attempt to correct and retry."
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  typedef int (*IDAResFn)(realtype tt, N_Vector yy, N_Vector yp,"
               "                          N_Vector rr, void *res_data);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Type : IDARootFn"
               "   * -----------------------------------------------------------------"
               "   * A function g, which defines a set of functions g_i(t,y,y'') whose"
               "   * roots are sought during the integration, must have type IDARootFn."
               "   * The function g takes as input the independent variable value t,"
               "   * the dependent variable vector y, and its t-derivative yp (= y'')."
               "   * It stores the nrtfn values g_i(t,y,y'') in the realtype array gout."
               "   * (Allocation of memory for gout is handled within IDA.)"
               "   * The g_data parameter is the same as that passed by the user"
               "   * to the IDARootInit routine.  This user-supplied pointer is"
               "   * passed to the user''s g function every time it is called."
               "   *"
               "   * An IDARootFn should return 0 if successful or a non-zero value"
               "   * if an error occured (in which case the integration will be halted)."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef int (*IDARootFn)(realtype t, N_Vector y, N_Vector yp,"
               "                           realtype *gout, void *g_data);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Type : IDAEwtFn"
               "   * -----------------------------------------------------------------"
               "   * A function e, which sets the error weight vector ewt, must have"
               "   * type IDAEwtFn."
               "   * The function e takes as input the current dependent variable y."
               "   * It must set the vector of error weights used in the WRMS norm:"
               "   * "
               "   *   ||y||_WRMS = sqrt [ 1/N * sum ( ewt_i * y_i)^2 ]"
               "   *"
               "   * Typically, the vector ewt has components:"
               "   * "
               "   *   ewt_i = 1 / (reltol * |y_i| + abstol_i)"
               "   *"
               "   * The e_data parameter is the same as that passed by the user"
               "   * to the IDASetEdata routine.  This user-supplied pointer is"
               "   * passed to the user''s e function every time it is called."
               "   * An IDAEwtFn e must return 0 if the error weight vector has been"
               "   * successfuly set and a non-zero value otherwise."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef int (*IDAEwtFn)(N_Vector y, N_Vector ewt, void *e_data);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Type : IDAErrHandlerFn"
               "   * -----------------------------------------------------------------"
               "   * A function eh, which handles error messages, must have type"
               "   * IDAErrHandlerFn."
               "   * The function eh takes as input the error code, the name of the"
               "   * module reporting the error, the error message, and a pointer to"
               "   * user data, the same as that passed to CVodeSetErrHandlerFn."
               "   * "
               "   * All error codes are negative, except IDA_WARNING which indicates "
               "   * a warning (the solver continues)."
               "   *"
               "   * An IDAErrHandlerFn has no return value."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef void (*IDAErrHandlerFn)(int error_code, "
               "                                  const char *module, const char *function, "
               "                                  char *msg, void *eh_data); "
               ""
               "  /*"
               "   * ================================================================"
               "   *          U S E R - C A L L A B L E   R O U T I N E S           "
               "   * ================================================================"
               "   */"
               ""
               "  /* "
               "   * ----------------------------------------------------------------"
               "   * Function : IDACreate                                           "
               "   * ----------------------------------------------------------------"
               "   * IDACreate creates an internal memory block for a problem to    "
               "   * be solved by IDA.                                              "
               "   *                                                                "
               "   * If successful, IDACreate returns a pointer to initialized      "
               "   * problem memory. This pointer should be passed to IDAMalloc.    "
               "   * If an initialization error occurs, IDACreate prints an error   "
               "   * message to standard err and returns NULL.                      "
               "   *                                                                "
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  void *IDACreate(void);"
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * Integrator optional input specification functions              "
               "   * ----------------------------------------------------------------"
               "   * The following functions can be called to set optional inputs   "
               "   * to values other than the defaults given below:                 "
               "   *                                                                "
               "   *                      |                                         "
               "   * Function             |  Optional input / [ default value ]     "
               "   *                      |                                          "
               "   * ---------------------------------------------------------------- "
               "   *                      |                                          "
               "   * IDASetErrHandlerFn   | user-provided ErrHandler function."
               "   *                      | [internal]"
               "   *                      |"
               "   * IDASetErrFile        | the file pointer for an error file"
               "   *                      | where all CVODE warning and error"
               "   *                      | messages will be written if the default"
               "   *                      | internal error handling function is used. "
               "   *                      | This parameter can be stdout (standard "
               "   *                      | output), stderr (standard error), or a "
               "   *                      | file pointer (corresponding to a user "
               "   *                      | error file opened for writing) returned "
               "   *                      | by fopen."
               "   *                      | If not called, then all messages will"
               "   *                      | be written to the standard error stream."
               "   *                      | [stderr]"
               "   *                      |                                          "
               "   * IDASetRdata          | a pointer to user data that will be     "
               "   *                      | passed to the user''s res function every "
               "   *                      | time res is called.                     "
               "   *                      | [NULL]                                  "
               "   *                      |         "
               "   * IDASetEwtFn          | user-provide EwtSet function e and "
               "   *                      | a pointer to user data that will be"
               "   *                      | passed to the user''s e function every"
               "   *                      | time e is called."
               "   *                      | [NULL]"
               "   *                      | [NULL]"
               "   *                      |"
               "   * IDASetMaxOrd         | maximum lmm order to be used by the     "
               "   *                      | solver.                                 "
               "   *                      | [5]                                      "
               "   *                      |                                          "
               "   * IDASetMaxNumSteps    | maximum number of internal steps to be  "
               "   *                      | taken by the solver in its attempt to   "
               "   *                      | reach tout.                             "
               "   *                      | [500]                                   "
               "   *                      |                                          "
               "   * IDASetInitStep       | initial step size.                      "
               "   *                      | [estimated by IDA]                       "
               "   *                      |                                          "
               "   * IDASetMaxStep        | maximum absolute value of step size     "
               "   *                      | allowed.                                "
               "   *                      | [infinity]                              "
               "   *                      |                                          "
               "   * IDASetStopTime       | the independent variable value past     "
               "   *                      | which the solution is not to proceed.   "
               "   *                      | [infinity]                              "
               "   *                      |                                          "
               "   * IDASetNonlinConvCoef | Newton convergence test  constant       "
               "   *                      | for use during integration.             "
               "   *                      | [0.33]                                  "
               "   *                      |                                          "
               "   * IDASetMaxErrTestFails| Maximum number of error test failures   "
               "   *                      | in attempting one step.                 "
               "   *                      | [10]                                    "
               "   *                      |                                         "
               "   * IDASetMaxNonlinIters | Maximum number of nonlinear solver      "
               "   *                      | iterations at one solution.             "
               "   *                      | [4]                                     "
               "   *                      |                                         "
               "   * IDASetMaxConvFails   | Maximum number of allowable conv.       "
               "   *                      | failures in attempting one step.        "
               "   *                      | [10]                                    "
               "   *                      |                                         "
               "   * IDASetSuppressAlg    | flag to indicate whether or not to      "
               "   *                      | suppress algebraic variables in the     "
               "   *                      | local error tests:                      "
               "   *                      | FALSE = do not suppress;                 "
               "   *                      | TRUE = do suppress;                     "
               "   *                      | [FALSE]                                 "
               "   *                      | NOTE: if suppressed algebraic variables "
               "   *                      | is selected, the nvector ''id'' must be   "
               "   *                      | supplied for identification of those    "
               "   *                      | algebraic components (see IDASetId).    "
               "   *                      |                                          "
               "   * IDASetId             | an N_Vector, which states a given       "
               "   *                      | element to be either algebraic or       "
               "   *                      | differential.                           "
               "   *                      | A value of 1.0 indicates a differential "
               "   *                      | variable while a 0.0 indicates an       "
               "   *                      | algebraic variable. ''id'' is required    "
               "   *                      | if optional input SUPPRESSALG is set,   "
               "   *                      | or if IDACalcIC is to be called with    "
               "   *                      | icopt = IDA_YA_YDP_INIT.               "
               "   *                      |                                         "
               "   * IDASetConstraints    | an N_Vector defining inequality         "
               "   *                      | constraints for each component of the   "
               "   *                      | solution vector y. If a given element   "
               "   *                      | of this vector has values +2 or -2,     "
               "   *                      | then the corresponding component of y   "
               "   *                      | will be constrained to be > 0.0 or      "
               "   *                      | <0.0, respectively, while if it is +1   "
               "   *                      | or -1, the y component is constrained   "
               "   *                      | to be >= 0.0 or <= 0.0, respectively.   "
               "   *                      | If a component of constraints is 0.0,   "
               "   *                      | then no constraint is imposed on the    "
               "   *                      | corresponding component of y.           "
               "   *                      | The presence of a non-NULL constraints  "
               "   *                      | vector that is not 0.0 (ZERO) in all    "
               "   *                      | components will cause constraint        "
               "   *                      | checking to be performed.               "
               "   *                      |                                         "
               "   * -----------------------------------------------------------------"
               "   *                      |"
               "   * IDASetTolerances     | Changes the integration tolerances"
               "   *                      | between calls to IDASolve()."
               "   *                      | [set by IDAMalloc/IDAReInit]"
               "   *                      |"
               "   * ---------------------------------------------------------------- "
               "   * Return flag:"
               "   *   IDA_SUCCESS   if successful"
               "   *   IDA_MEM_NULL  if the ida memory is NULL"
               "   *   IDA_ILL_INPUT if an argument has an illegal value"
               "   *"
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  int IDASetErrHandlerFn(void *ida_mem, IDAErrHandlerFn ehfun, void *eh_data);"
               "  int IDASetErrFile(void *ida_mem, FILE *errfp);"
               "  int IDASetRdata(void *ida_mem, void *res_data);"
               "  int IDASetEwtFn(void *ida_mem, IDAEwtFn efun, void *edata);"
               "  int IDASetMaxOrd(void *ida_mem, int maxord);"
               "  int IDASetMaxNumSteps(void *ida_mem, long int mxsteps);"
               "  int IDASetInitStep(void *ida_mem, realtype hin);"
               "  int IDASetMaxStep(void *ida_mem, realtype hmax);"
               "  int IDASetStopTime(void *ida_mem, realtype tstop);"
               "  int IDASetNonlinConvCoef(void *ida_mem, realtype epcon);"
               "  int IDASetMaxErrTestFails(void *ida_mem, int maxnef);"
               "  int IDASetMaxNonlinIters(void *ida_mem, int maxcor);"
               "  int IDASetMaxConvFails(void *ida_mem, int maxncf);"
               "  int IDASetSuppressAlg(void *ida_mem, booleantype suppressalg);"
               "  int IDASetId(void *ida_mem, N_Vector id);"
               "  int IDASetConstraints(void *ida_mem, N_Vector constraints);"
               ""
               "  int IDASetTolerances(void *ida_mem, int itol, realtype rtol, void *atol);"
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * Function : IDAMalloc                                           "
               "   * ----------------------------------------------------------------"
               "   * IDAMalloc allocates and initializes memory for a problem to    "
               "   * to be solved by IDA.                                           "
               "   *                                                                "
               "   * res     is the residual function F in F(t,y,y'') = 0.                     "
               "   *                                                                "
               "   * t0      is the initial value of t, the independent variable.   "
               "   *                                                                "
               "   * yy0     is the initial condition vector y(t0).                 "
               "   *                                                                "
               "   * yp0     is the initial condition vector y''(t0)                 "
               "   *                                                                "
               "   * itol    is the type of tolerances to be used.                  "
               "   *            The legal values are:                               "
               "   *               IDA_SS (scalar relative and absolute  tolerances),   "
               "   *               IDA_SV (scalar relative tolerance and vector         "
               "   *                       absolute tolerance).                         "
               "   *               IDA_WF (user-provided weight function)                       "
               "   *                                         "
               "   * rtol    is the relative tolerance scalar.         "
               "   *                                                                "
               "   * atol    is a pointer (void) to the absolute tolerance scalar or"
               "   *            an N_Vector tolerance or an IDAEwtFn funciton.                              "
               "   * (ewt)                                                          "
               "   *         Both rtol and atol are used to compute the error weight"
               "   *         vector, ewt. The error test required of a correction   "
               "   *         delta is that the weighted-RMS norm of delta be less   "
               "   *         than or equal to 1.0. Other convergence tests use the  "
               "   *         same norm. The weighting vector used in this norm is   "
               "   *         ewt. The components of ewt are defined by              "
               "   *         ewt[i] = 1.0/(rtol*yy[i] + atol[i]). Here, yy is the   "
               "   *         current approximate solution.  See the routine         "
               "   *         N_VWrmsNorm for the norm used in this error test.      "
               "   *                                                                "
               "   * Note: The tolerance values may be changed in between calls to  "
               "   *       IDASolve for the same problem. These values refer to     "
               "   *       (*rtol) and either (*atol), for a scalar absolute        "
               "   *       tolerance, or the components of atol, for a vector       "
               "   *       absolute tolerance.                                      "
               "   *                                                                 "
               "   *  IDA_SUCCESS if successful"
               "   *  IDA_MEM_NULL if the ida memory was NULL"
               "   *  IDA_MEM_FAIL if a memory allocation failed"
               "   *  IDA_ILL_INPUT f an argument has an illegal value."
               "   *                                                                "
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  int IDAMalloc(void *ida_mem, IDAResFn res,"
               "                realtype t0, N_Vector yy0, N_Vector yp0, "
               "                int itol, realtype rtol, void *atol);"
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * Function : IDAReInit                                           "
               "   * ----------------------------------------------------------------"
               "   * IDAReInit re-initializes IDA for the solution of a problem,    "
               "   * where a prior call to IDAMalloc has been made.                 "
               "   * IDAReInit performs the same input checking and initializations "
               "   * that IDAMalloc does.                                           "
               "   * But it does no memory allocation, assuming that the existing   "
               "   * internal memory is sufficient for the new problem.             "
               "   *                                                                "
               "   * The use of IDAReInit requires that the maximum method order,   "
               "   * maxord, is no larger for the new problem than for the problem  "
               "   * specified in the last call to IDAMalloc.  This condition is    "
               "   * automatically fulfilled if the default value for maxord is     "
               "   * specified.                                                     "
               "   *                                                                "
               "   * Following the call to IDAReInit, a call to the linear solver   "
               "   * specification routine is necessary if a different linear solver"
               "   * is chosen, but may not be otherwise.  If the same linear solver"
               "   * is chosen, and there are no changes in its input parameters,   "
               "   * then no call to that routine is needed.                        "
               "   *                                                                "
               "   * The first argument to IDAReInit is:                            "
               "   *                                                                "
               "   * ida_mem = pointer to IDA memory returned by IDACreate.         "
               "   *                                                                "
               "   * All the remaining arguments to IDAReInit have names and        "
               "   * meanings identical to those of IDAMalloc.                      "
               "   *                                                                "
               "   * The return value of IDAReInit is equal to SUCCESS = 0 if there "
               "   * were no errors; otherwise it is a negative int equal to:       "
               "   *   IDA_MEM_NULL   indicating ida_mem was NULL, or            "
               "   *   IDA_NO_MALLOC  indicating that ida_mem was not allocated. "
               "   *   IDA_ILL_INPUT  indicating an input argument was illegal   "
               "   *                  (including an attempt to increase maxord). "
               "   * In case of an error return, an error message is also printed.  "
               "   * ----------------------------------------------------------------"
               "   */                                                                "
               ""
               "  int IDAReInit(void *ida_mem, IDAResFn res,"
               "                realtype t0, N_Vector yy0, N_Vector yp0,"
               "                int itol, realtype rtol, void *atol);"
               " "
               "  /* ----------------------------------------------------------------"
               "   * Initial Conditions optional input specification functions      "
               "   * ----------------------------------------------------------------"
               "   * The following functions can be called to set optional inputs   "
               "   * to control the initial conditions calculations.                "
               "   *                                                                "
               "   *                        |                                        "
               "   * Function               |  Optional input / [ default value ]   "
               "   *                        |                                        "
               "   * -------------------------------------------------------------- "
               "   *                        |                                        "
               "   * IDASetNonlinConvCoefIC | positive coeficient in the Newton     "
               "   *                        | convergence test.  This test uses a   "
               "   *                        | weighted RMS norm (with weights       "
               "   *                        | defined by the tolerances, as in      "
               "   *                        | IDASolve).  For new initial value     "
               "   *                        | vectors y and y'' to be accepted, the  "
               "   *                        | norm of J-inverse F(t0,y,y'') is       "
               "   *                        | required to be less than epiccon,     "
               "   *                        | where J is the system Jacobian.       "
               "   *                        | [0.01 * 0.33]                          "
               "   *                        |                                        "
               "   * IDASetMaxNumStepsIC    | maximum number of values of h allowed "
               "   *                        | when icopt = IDA_YA_YDP_INIT, where  "
               "   *                        | h appears in the system Jacobian,     "
               "   *                        | J = dF/dy + (1/h)dF/dy''.              "
               "   *                        | [5]                                   "
               "   *                        |                                        "
               "   * IDASetMaxNumJacsIC     | maximum number of values of the       "
               "   *                        | approximate Jacobian or preconditioner"
               "   *                        | allowed, when the Newton iterations   "
               "   *                        | appear to be slowly converging.       "
               "   *                        | [4]                                    "
               "   *                        |                                        "
               "   * IDASetMaxNumItersIC    | maximum number of Newton iterations   "
               "   *                        | allowed in any one attempt to solve   "
               "   *                        | the IC problem.                       "
               "   *                        | [10]                                  "
               "   *                        |                                        "
               "   * IDASetLineSearchOffIC  | a boolean flag to turn off the        "
               "   *                        | linesearch algorithm.                 "
               "   *                        | [FALSE]                               "
               "   *                        |                                        "
               "   * IDASetStepToleranceIC  | positive lower bound on the norm of   "
               "   *                        | a Newton step.                        "
               "   *                        | [(unit roundoff)^(2/3)                "
               "   *                                                                "
               "   * ---------------------------------------------------------------- "
               "   * Return flag:"
               "   *   IDA_SUCCESS   if successful"
               "   *   IDA_MEM_NULL  if the ida memory is NULL"
               "   *   IDA_ILL_INPUT if an argument has an illegal value"
               "   *"
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  int IDASetNonlinConvCoefIC(void *ida_mem, realtype epiccon);"
               "  int IDASetMaxNumStepsIC(void *ida_mem, int maxnh);"
               "  int IDASetMaxNumJacsIC(void *ida_mem, int maxnj);"
               "  int IDASetMaxNumItersIC(void *ida_mem, int maxnit);"
               "  int IDASetLineSearchOffIC(void *ida_mem, booleantype lsoff);"
               "  int IDASetStepToleranceIC(void *ida_mem, realtype steptol);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : IDARootInit"
               "   * -----------------------------------------------------------------"
               "   * IDARootInit initializes a rootfinding problem to be solved"
               "   * during the integration of the DAE system.  It must be called"
               "   * after IDACreate, and before IDASolve.  The arguments are:"
               "   *"
               "   * ida_mem = pointer to IDA memory returned by IDACreate."
               "   *"
               "   * nrtfn   = number of functions g_i, an int >= 0."
               "   *"
               "   * g       = name of user-supplied function, of type IDARootFn,"
               "   *           defining the functions g_i whose roots are sought."
               "   *"
               "   * g_data  = a pointer to user data that will be passed to the "
               "   *           user''s g function every time g is called."
               "   *"
               "   * If a new problem is to be solved with a call to IDAReInit,"
               "   * where the new problem has no root functions but the prior one"
               "   * did, then call IDARootInit with nrtfn = 0."
               "   *"
               "   * The return value of IDARootInit is IDA_SUCCESS = 0 if there were"
               "   * no errors; otherwise it is a negative int equal to:"
               "   *   IDA_MEM_NULL     indicating ida_mem was NULL, or"
               "   *   IDA_MEM_FAIL     indicating a memory allocation failed."
               "   *                    (including an attempt to increase maxord)."
               "   *   IDA_ILL_INPUT    indicating nrtfn > 0 but g = NULL."
               "   * In case of an error return, an error message is also printed."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int IDARootInit(void *ida_mem, int nrtfn, IDARootFn g, void *g_data);"
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * Function : IDACalcIC                                           "
               "   * ----------------------------------------------------------------"
               "   * IDACalcIC calculates corrected initial conditions for the DAE  "
               "   * system for a class of index-one problems of semi-implicit form."
               "   * It uses Newton iteration combined with a Linesearch algorithm. "
               "   * Calling IDACalcIC is optional. It is only necessary when the   "
               "   * initial conditions do not solve the given system.  I.e., if    "
               "   * y0 and yp0 are known to satisfy F(t0, y0, yp0) = 0, then       "
               "   * a call to IDACalcIC is NOT necessary (for index-one problems). "
               "   *                                                                "
               "   * A call to IDACalcIC must be preceded by a successful call to   "
               "   * IDAMalloc or IDAReInit for the given DAE problem, and by a     "
               "   * successful call to the linear system solver specification      "
               "   * routine.                                                       "
               "   *                                                                "
               "   * The call to IDACalcIC should precede the call(s) to IDASolve   "
               "   * for the given problem.                                         "
               "   *                                                                "
               "   * The arguments to IDACalcIC are as follows:                     "
               "   *                                                                "
               "   * ida_mem is the pointer to IDA memory returned by IDACreate.    "
               "   *                                                                "
               "   * icopt  is the option of IDACalcIC to be used.                  "
               "   *        icopt = IDA_YA_YDP_INIT   directs IDACalcIC to compute "
               "   *                the algebraic components of y and differential  "
               "   *                components of y'', given the differential        "
               "   *                components of y.  This option requires that the "
               "   *                N_Vector id was set through a call to IDASetId  "
               "   *                specifying the differential and algebraic       "
               "   *                components.                                     "
               "   *        icopt = IDA_Y_INIT   directs IDACalcIC to compute all  "
               "   *                components of y, given y''.  id is not required. "
               "   *                                                                "
               "   * tout1  is the first value of t at which a soluton will be      "
               "   *        requested (from IDASolve).  (This is needed here to     "
               "   *        determine the direction of integration and rough scale  "
               "   *        in the independent variable t.)                          "
               "   *                                                                "
               "   *                                                                "
               "   * IDACalcIC returns an int flag.  Its symbolic values and their  "
               "   * meanings are as follows.  (The numerical return values are set "
               "   * above in this file.)  All unsuccessful returns give a negative "
               "   * return value.  If IFACalcIC failed, y0 and yp0 contain         "
               "   * (possibly) altered values, computed during the attempt.        "
               "   *                                                                "
               "   * SUCCESS             IDACalcIC was successful.  The corrected   "
               "   *                     initial value vectors are in y0 and yp0.    "
               "   *                                                                "
               "   * IDA_MEM_NULL        The argument ida_mem was NULL.             "
               "   *                                                                "
               "   * IDA_ILL_INPUT       One of the input arguments was illegal.    "
               "   *                     See printed message.                       "
               "   *                                                                "
               "   * IDA_LINIT_FAIL      The linear solver''s init routine failed.   "
               "   *                                                                "
               "   * IDA_BAD_EWT         Some component of the error weight vector  "
               "   *                     is zero (illegal), either for the input    "
               "   *                     value of y0 or a corrected value.          "
               "   *                                                                "
               "   * IDA_RES_FAIL        The user''s residual routine returned "
               "   *                     a non-recoverable error flag.              "
               "   *                                                                "
               "   * IDA_FIRST_RES_FAIL  The user''s residual routine returned "
               "   *                     a recoverable error flag on the first call,"
               "   *                     but IDACalcIC was unable to recover.       "
               "   *                                                                "
               "   * IDA_LSETUP_FAIL     The linear solver''s setup routine had a    "
               "   *                     non-recoverable error.                     "
               "   *                                                                "
               "   * IDA_LSOLVE_FAIL     The linear solver''s solve routine had a    "
               "   *                     non-recoverable error.                     "
               "   *                                                                "
               "   * IDA_NO_RECOVERY     The user''s residual routine, or the linear "
               "   *                     solver''s setup or solve routine had a      "
               "   *                     recoverable error, but IDACalcIC was       "
               "   *                     unable to recover.                         "
               "   *                                                                "
               "   * IDA_CONSTR_FAIL     IDACalcIC was unable to find a solution    "
               "   *                     satisfying the inequality constraints.     "
               "   *                                                                "
               "   * IDA_LINESEARCH_FAIL The Linesearch algorithm failed to find a  "
               "   *                     solution with a step larger than steptol   "
               "   *                     in weighted RMS norm.                      "
               "   *                                                                "
               "   * IDA_CONV_FAIL       IDACalcIC failed to get convergence of the "
               "   *                     Newton iterations.                         "
               "   *                                                                "
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  int IDACalcIC(void *ida_mem, int icopt, realtype tout1); "
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * Function : IDASolve                                            "
               "   * ----------------------------------------------------------------"
               "   * IDASolve integrates the DAE over an interval in t, the         "
               "   * independent variable. If itask is IDA_NORMAL, then the solver      "
               "   * integrates from its current internal t value to a point at or  "
               "   * beyond tout, then interpolates to t = tout and returns y(tret) "
               "   * in the user-allocated vector yret. In general, tret = tout.    "
               "   * If itask is IDA_ONE_STEP, then the solver takes one internal"
               "   * step of the independent variable and returns in yret the value"
               "   * of y at the new internal independent variable value. In this"
               "   * case, tout is used only during the first call to IDASolve to         "
               "   * determine the direction of integration and the rough scale of  "
               "   * the problem. If itask is IDA_NORMAL_TSTOP or IDA_ONE_STEP_TSTOP,"
               "   * then IDA returns the solution at tstop if that comes sooner than"
               "   * tout or the end of the next internal step, respectively."
               "   * In any case, the independent variable value reached by the solver"
               "   * is placed in (*tret).  The user is responsible for allocating the"
               "   * memory for this value.          "
               "   *                                                                "
               "   * ida_mem is the pointer (void) to IDA memory returned by        "
               "   *         IDACreate."
               "   *                                                                "
               "   * tout    is the next independent variable value at which a      "
               "   *         computed solution is desired.                          "
               "   *                                                                "
               "   * tret    is a pointer to a real location.  IDASolve sets (*tret)"
               "   *         to the actual t value reached, corresponding to the"
               "   *         solution vector yret.  In IDA_NORMAL mode, with no"
               "   *         errors and no roots found, (*tret) = tout."
               "   *"
               "   * yret    is the computed solution vector.  With no errors,"
               "   *         yret = y(tret).                                        "
               "   *                                                                "
               "   * ypret   is the derivative of the computed solution at t = tret."
               "   *                                                                "
               "   * Note: yret and ypret may be the same N_Vectors as y0 and yp0   "
               "   * in the call to IDAMalloc or IDAReInit.                         "
               "   *                                                                "
               "   * itask   is IDA_NORMAL, IDA_NORMAL_TSTOP, IDA_ONE_STEP, or"
               "   *         IDA_ONE_STEP_TSTOP.   These modes are described above."
               "   *"
               "   *"
               "   * The return values for IDASolve are described below.            "
               "   * (The numerical return values are defined above in this file.)  "
               "   * All unsuccessful returns give a negative return value.         "
               "   *                                                                "
               "   * IDA_SUCCESS"
               "   *   IDASolve succeeded and no roots were found.                       "
               "   *"
               "   * IDA_ROOT_RETURN:  IDASolve succeeded, and found one or more roots."
               "   *   If nrtfn > 1, call IDAGetRootInfo to see which g_i were found"
               "   *   to have a root at (*tret)."
               "   *"
               "   * IDA_TSTOP_RETURN: "
               "   *   IDASolve returns computed results for the independent variable "
               "   *   value tstop. That is, tstop was reached.                            "
               "   *                                                                "
               "   * IDA_MEM_NULL: "
               "   *   The IDA_mem argument was NULL.            "
               "   *                                                                "
               "   * IDA_ILL_INPUT: "
               "   *   One of the inputs to IDASolve is illegal. This includes the "
               "   *   situation when a component of the error weight vectors "
               "   *   becomes < 0 during internal stepping.  It also includes the"
               "   *   situation where a root of one of the root functions was found"
               "   *   both at t0 and very near t0.  The ILL_INPUT flag          "
               "   *   will also be returned if the linear solver function IDA---"
               "   *   (called by the user after calling IDACreate) failed to set one "
               "   *   of the linear solver-related fields in ida_mem or if the linear "
               "   *   solver''s init routine failed. In any case, the user should see "
               "   *   the printed error message for more details.                "
               "   *                                                                "
               "   * IDA_TOO_MUCH_WORK: "
               "   *   The solver took mxstep internal steps but could not reach tout. "
               "   *   The default value for mxstep is MXSTEP_DEFAULT = 500.                "
               "   *                                                                "
               "   * IDA_TOO_MUCH_ACC: "
               "   *   The solver could not satisfy the accuracy demanded by the user "
               "   *   for some internal step.   "
               "   *                                                                "
               "   * IDA_ERR_FAIL:"
               "   *   Error test failures occurred too many times (=MXETF = 10) during "
               "   *   one internal step.  "
               "   *                                                                "
               "   * IDA_CONV_FAIL: "
               "   *   Convergence test failures occurred too many times (= MXNCF = 10) "
               "   *   during one internal step.                                          "
               "   *                                                                "
               "   * IDA_LSETUP_FAIL: "
               "   *   The linear solver''s setup routine failed  "
               "   *   in an unrecoverable manner.                    "
               "   *                                                                "
               "   * IDA_LSOLVE_FAIL: "
               "   *   The linear solver''s solve routine failed  "
               "   *   in an unrecoverable manner.                    "
               "   *                                                                "
               "   * IDA_CONSTR_FAIL:"
               "   *    The inequality constraints were violated, "
               "   *    and the solver was unable to recover.         "
               "   *                                                                "
               "   * IDA_REP_RES_ERR: "
               "   *    The user''s residual function repeatedly returned a recoverable "
               "   *    error flag, but the solver was unable to recover.                 "
               "   *                                                                "
               "   * IDA_RES_FAIL:"
               "   *    The user''s residual function returned a nonrecoverable error "
               "   *    flag."
               "   *                                                                "
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  int IDASolve(void *ida_mem, realtype tout, realtype *tret,"
               "               N_Vector yret, N_Vector ypret, int itask);"
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * Function: IDAGetSolution                                       "
               "   * ----------------------------------------------------------------"
               "   *                                                                "
               "   * This routine evaluates y(t) and y''(t) as the value and         "
               "   * derivative of the interpolating polynomial at the independent  "
               "   * variable t, and stores the results in the vectors yret and     "
               "   * ypret.  It uses the current independent variable value, tn,    "
               "   * and the method order last used, kused. This function is        "
               "   * called by IDASolve with t = tout, t = tn, or t = tstop.        "
               "   *                                                                "
               "   * If kused = 0 (no step has been taken), or if t = tn, then the  "
               "   * order used here is taken to be 1, giving yret = phi[0],        "
               "   * ypret = phi[1]/psi[0].                                         "
               "   *                                                                "
               "   * The return values are:                                         "
               "   *   IDA_SUCCESS:  succeess.                                  "
               "   *   IDA_BAD_T:    t is not in the interval [tn-hu,tn].                   "
               "   *   IDA_MEM_NULL: The ida_mem argument was NULL.     "
               "   *                                                                "
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  int IDAGetSolution(void *ida_mem, realtype t, "
               "                     N_Vector yret, N_Vector ypret);"
               ""
               "  /* ----------------------------------------------------------------"
               "   * Integrator optional output extraction functions                "
               "   * ----------------------------------------------------------------"
               "   *                                                                "
               "   * The following functions can be called to get optional outputs  "
               "   * and statistics related to the main integrator.                 "
               "   * ---------------------------------------------------------------- "
               "   *                                                                "
               "   * IDAGetWorkSpace returns the IDA real and integer workspace sizes      "
               "   * IDAGetNumSteps returns the cumulative number of internal       "
               "   *       steps taken by the solver                                "
               "   * IDAGetNumRhsEvals returns the number of calls to the user''s    "
               "   *       res function                                             "
               "   * IDAGetNumLinSolvSetups returns the number of calls made to     "
               "   *       the linear solver''s setup routine                        "
               "   * IDAGetNumErrTestFails returns the number of local error test   "
               "   *       failures that have occured                               "
               "   * IDAGetNumBacktrackOps returns the number of backtrack          "
               "   *       operations done in the linesearch algorithm in IDACalcIC "
               "   * IDAGetConsistentIC returns the consistent initial conditions"
               "   *       computed by IDACalcIC"
               "   * IDAGetLastOrder returns the order used during the last         "
               "   *       internal step                                            "
               "   * IDAGetCurentOrder returns the order to be used on the next     "
               "   *       internal step                                            "
               "   * IDAGetActualInitStep returns the actual initial step size      "
               "   *       used by IDA                                              "
               "   * IDAGetLAstStep returns the step size for the last internal     "
               "   *       step (if from IDASolve), or the last value of the        "
               "   *       artificial step size h (if from IDACalcIC)               "
               "   * IDAGetCurrentStep returns the step size to be attempted on the "
               "   *       next internal step                                       "
               "   * IDAGetCurrentTime returns the current internal time reached    "
               "   *       by the solver                                            "
               "   * IDAGetTolScaleFactor returns a suggested factor by which the   "
               "   *       user''s tolerances should be scaled when too much         "
               "   *       accuracy has been requested for some internal step       "
               "   * IDAGetErrWeights returns the current state error weight vector.        "
               "   *       The user must allocate space for eweight."
               "   * IDAGetEstLocalErrors returns the estimated local errors. The user"
               "   *       must allocate space for the vector ele."
               "   * IDAGetNumGEvals returns the number of calls to the user''s"
               "   *       g function (for rootfinding)"
               "   * IDAGetRootInfo returns the indices for which g_i was found to "
               "   *       have a root. The user must allocate space for rootsfound."
               "   *       For i = 0 ... nrtfn-1, rootsfound[i] = 1 if g_i has a root,"
               "   *       and rootsfound[i]= 0 if not."
               "   *                                                                "
               "   * IDAGet* return values:"
               "   *   IDA_SUCCESS   if succesful"
               "   *   IDA_MEM_NULL  if the ida memory was NULL"
               "   *   IDA_ILL_INPUT if some input is illegal"
               "   *"
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  int IDAGetWorkSpace(void *ida_mem, long int *lenrw, long int *leniw);"
               "  int IDAGetNumSteps(void *ida_mem, long int *nsteps);"
               "  int IDAGetNumResEvals(void *ida_mem, long int *nrevals);"
               "  int IDAGetNumLinSolvSetups(void *ida_mem, long int *nlinsetups);"
               "  int IDAGetNumErrTestFails(void *ida_mem, long int *netfails);"
               "  int IDAGetNumBacktrackOps(void *ida_mem, long int *nbacktr);"
               "  int IDAGetConsistentIC(void *ida_mem, N_Vector yy0_mod, N_Vector yp0_mod);"
               "  int IDAGetLastOrder(void *ida_mem, int *klast);"
               "  int IDAGetCurrentOrder(void *ida_mem, int *kcur);"
               "  int IDAGetActualInitStep(void *ida_mem, realtype *hinused);"
               "  int IDAGetLastStep(void *ida_mem, realtype *hlast);"
               "  int IDAGetCurrentStep(void *ida_mem, realtype *hcur);"
               "  int IDAGetCurrentTime(void *ida_mem, realtype *tcur);"
               "  int IDAGetTolScaleFactor(void *ida_mem, realtype *tolsfact);"
               "  int IDAGetErrWeights(void *ida_mem, N_Vector eweight);"
               "  int IDAGetEstLocalErrors(void *ida_mem, N_Vector ele);"
               "  int IDAGetNumGEvals(void *ida_mem, long int *ngevals);"
               "  int IDAGetRootInfo(void *ida_mem, int *rootsfound);"
               "  int IDAGetfcallerid(void *ida_mem,  int *fcallerid);"
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * As a convenience, the following function provides the          "
               "   * optional outputs in a group.                                   "
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  int IDAGetIntegratorStats(void *ida_mem, long int *nsteps, "
               "                            long int *nrevals, long int *nlinsetups, "
               "                            long int *netfails, int *qlast, int *qcur, "
               "                            realtype *hinused, realtype *hlast, realtype *hcur, "
               "                            realtype *tcur);"
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * Nonlinear solver optional output extraction functions          "
               "   * ----------------------------------------------------------------"
               "   *                                                                "
               "   * The following functions can be called to get optional outputs  "
               "   * and statistics related to the nonlinear solver.                "
               "   * -------------------------------------------------------------- "
               "   *                                                                "
               "   * IDAGetNumNonlinSolvIters returns the number of nonlinear       "
               "   *       solver iterations performed.                             "
               "   * IDAGetNumNonlinSolvConvFails returns the number of nonlinear   "
               "   *       convergence failures.                                    "
               "   *                                                                "
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  int IDAGetNumNonlinSolvIters(void *ida_mem, long int *nniters);"
               "  int IDAGetNumNonlinSolvConvFails(void *ida_mem, long int *nncfails);"
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * As a convenience, the following function provides the          "
               "   * nonlinear solver optional outputs in a group.                                   "
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  int IDAGetNonlinSolvStats(void *ida_mem, long int *nniters, "
               "                            long int *nncfails);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * The following function returns the name of the constant "
               "   * associated with an IDA return flag"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  char *IDAGetReturnFlagName(int flag);"
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * Function : IDAFree                                             "
               "   * ----------------------------------------------------------------"
               "   * IDAFree frees the problem memory IDA_mem allocated by          "
               "   * IDAMalloc.  Its only argument is the pointer idamem            "
               "   * returned by IDAMalloc.                                         "
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  void IDAFree(void **ida_mem);"
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'ida_impl.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * ----------------------------------------------------------------- "
               " * Programmer(s): Allan G. Taylor, Alan C. Hindmarsh, Radu Serban,"
               " *                and Aaron Collier @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * This is the header file (private version) for the main IDA solver."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _IDA_IMPL_H"
               "#define _IDA_IMPL_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include <stdarg.h>"
               ""
               "#include ""ida.h"""
               ""
               "  /* "
               "   * ================================================================="
               "   *   M A I N    I N T E G R A T O R    M E M O R Y    B L O C K"
               "   * ================================================================="
               "   */"
               ""
               ""
               "  /* Basic IDA constants */"
               ""
               "#define HMAX_INV_DEFAULT RCONST(0.0) /* hmax_inv default value          */"
               "#define MAXORD_DEFAULT   5           /* maxord default value            */"
               "#define MXORDP1          6           /* max. number of N_Vectors in phi */"
               "#define MXSTEP_DEFAULT   500         /* mxstep default value            */"
               ""
               "  /*"
               "   * ----------------------------------------------------------------"
               "   * Types : struct IDAMemRec, IDAMem"
               "   * ----------------------------------------------------------------"
               "   * The type IDAMem is type pointer to struct IDAMemRec. This"
               "   * structure contains fields to keep track of problem state."
               "   * ----------------------------------------------------------------"
               "   */"
               ""
               "  typedef struct IDAMemRec {"
               ""
               "    realtype ida_uround;    /* machine unit roundoff */"
               ""
               "    /* Problem Specification Data */"
               ""
               "    IDAResFn       ida_res;            /* F(t,y(t),y''(t))=0; the function F  */"
               "    void          *ida_rdata;          /* user pointer passed to res         */"
               "    "
               "    int            ida_itol;           /* itol = IDA_SS, IDA_SV or IDA_WF    */"
               "    realtype       ida_rtol;           /* relative tolerance                 */"
               "    realtype       ida_Satol;          /* scalar absolute tolerance          */  "
               "    N_Vector       ida_Vatol;          /* vector absolute tolerance          */  "
               "    IDAEwtFn       ida_efun;           /* function to set ewt                */"
               "    void          *ida_edata;          /* user pointer passed to efun        */"
               "  "
               ""
               "    booleantype    ida_setupNonNull;   /* Does setup do something?           */"
               "    booleantype    ida_constraintsSet; /* constraints vector present: "
               "                                          do constraints calc                */"
               "    booleantype    ida_suppressalg;    /* true means suppress algebraic vars"
               "                                          in local error tests               */"
               ""
               "    /* Divided differences array and associated minor arrays */"
               ""
               "    N_Vector ida_phi[MXORDP1];   /* phi = (maxord+1) arrays of divided differences */"
               ""
               "    realtype ida_psi[MXORDP1];   /* differences in t (sums of recent step sizes)   */"
               "    realtype ida_alpha[MXORDP1]; /* ratios of current stepsize to psi values       */"
               "    realtype ida_beta[MXORDP1];  /* ratios of current to previous product of psi''s */"
               "    realtype ida_sigma[MXORDP1]; /* product successive alpha values and factorial  */"
               "    realtype ida_gamma[MXORDP1]; /* sum of reciprocals of psi values               */"
               ""
               "    /* N_Vectors */"
               ""
               "    N_Vector ida_ewt;         /* error weight vector                           */"
               "    N_Vector ida_yy;          /* work space for y vector (= user''s yret)       */"
               "    N_Vector ida_yp;          /* work space for y'' vector (= user''s ypret)     */"
               "    N_Vector ida_delta;       /* residual vector                               */"
               "    N_Vector ida_id;          /* bit vector for diff./algebraic components     */"
               "    N_Vector ida_constraints; /* vector of inequality constraint options       */"
               "    N_Vector ida_savres;      /* saved residual vector (= tempv1)              */"
               "    N_Vector ida_ee;          /* accumulated corrections to y vector, but"
               "                                 set equal to estimated local errors upon"
               "                                 successful return                             */"
               "    N_Vector ida_mm;          /* mask vector in constraints tests (= tempv2)   */"
               "    N_Vector ida_tempv1;      /* work space vector                             */"
               "    N_Vector ida_tempv2;      /* work space vector                             */"
               "    N_Vector ida_ynew;        /* work vector for y in IDACalcIC (= tempv2)     */"
               "    N_Vector ida_ypnew;       /* work vector for yp in IDACalcIC (= ee)        */"
               "    N_Vector ida_delnew;      /* work vector for delta in IDACalcIC (= phi[2]) */"
               "    N_Vector ida_dtemp;       /* work vector in IDACalcIC (= phi[3])           */"
               ""
               "    /* Variables for use by IDACalcIC*/"
               ""
               "    realtype ida_t0;          /* initial t                                     */"
               "    N_Vector ida_yy0;         /* initial y vector (user-supplied).             */"
               "    N_Vector ida_yp0;         /* initial y'' vector (user-supplied).            */"
               ""
               "    int ida_icopt;            /* IC calculation user option                    */"
               "    booleantype ida_lsoff;    /* IC calculation linesearch turnoff option      */"
               "    int ida_maxnh;            /* max. number of h tries in IC calculation      */"
               "    int ida_maxnj;            /* max. number of J tries in IC calculation      */"
               "    int ida_maxnit;           /* max. number of Netwon iterations in IC calc.  */"
               "    int ida_nbacktr;          /* number of IC linesearch backtrack operations  */"
               "    int ida_sysindex;         /* computed system index (0 or 1)                */"
               "    realtype ida_epiccon;     /* IC nonlinear convergence test constant        */"
               "    realtype ida_steptol;     /* minimum Newton step size in IC calculation    */"
               "    realtype ida_tscale;      /* time scale factor = abs(tout1 - t0)           */"
               ""
               "    /* Tstop information */"
               ""
               "    booleantype ida_istop;"
               "    booleantype ida_tstopset;"
               "    realtype ida_tstop;"
               ""
               "    /* Step Data */"
               ""
               "    int ida_kk;        /* current BDF method order                              */"
               "    int ida_kused;     /* method order used on last successful step             */"
               "    int ida_knew;      /* order for next step from order decrease decision      */"
               "    int ida_phase;     /* flag to trigger step doubling in first few steps      */"
               "    int ida_ns;        /* counts steps at fixed stepsize and order              */"
               ""
               "    realtype ida_hin;      /* initial step                                      */"
               "    realtype ida_h0u;      /* actual initial stepsize                           */"
               "    realtype ida_hh;       /* current step size h                               */"
               "    realtype ida_hused;    /* step size used on last successful step            */"
               "    realtype ida_rr;       /* rr = hnext / hused                                */"
               "    realtype ida_tn;       /* current internal value of t                       */"
               "    realtype ida_tretlast; /* value of tret previously returned by IDASolve     */"
               "    realtype ida_cj;       /* current value of scalar (-alphas/hh) in Jacobian  */"
               "    realtype ida_cjlast;   /* cj value saved from last successful step          */"
               "    realtype ida_cjold;    /* cj value saved from last call to lsetup           */"
               "    realtype ida_cjratio;  /* ratio of cj values: cj/cjold                      */"
               "    realtype ida_ss;       /* scalar used in Newton iteration convergence test  */"
               "    realtype ida_epsNewt;  /* test constant in Newton convergence test          */"
               "    realtype ida_epcon;    /* coeficient of the Newton covergence test          */"
               "    realtype ida_toldel;   /* tolerance in direct test on Newton corrections    */"
               ""
               "    /* Limits */"
               ""
               "    int ida_maxncf;        /* max numer of convergence failures                 */"
               "    int ida_maxcor;        /* max number of Newton corrections                  */"
               "    int ida_maxnef;        /* max number of error test failures                 */"
               ""
               "    int ida_maxord;        /* max value of method order k:                      */"
               "    int ida_maxord_alloc;  /* value of maxord used when allocating memory       */"
               "    long int ida_mxstep;   /* max number of internal steps for one user call    */"
               "    realtype ida_hmax_inv; /* inverse of max. step size hmax (default = 0.0)    */"
               ""
               "    /* Counters */"
               ""
               "    long int ida_nst;      /* number of internal steps taken                    */"
               "    long int ida_nre;      /* number of function (res) calls                    */"
               "    long int ida_ncfn;     /* number of corrector convergence failures          */"
               "    long int ida_netf;     /* number of error test failures                     */"
               "    long int ida_nni;      /* number of Newton iterations performed             */"
               "    long int ida_nsetups;  /* number of lsetup calls                            */"
               ""
               "    /* Space requirements for IDA */"
               ""
               "    long int ida_lrw1;     /* no. of realtype words in 1 N_Vector               */"
               "    long int ida_liw1;     /* no. of integer words in 1 N_Vector                */"
               "    long int ida_lrw;      /* number of realtype words in IDA work vectors      */"
               "    long int ida_liw;      /* no. of integer words in IDA work vectors          */"
               ""
               "    realtype ida_tolsf;    /* tolerance scale factor (saved value)              */"
               ""
               "    /* Error handler function and error ouput file */"
               ""
               "    IDAErrHandlerFn ida_ehfun; /* Error messages are handled by ehfun           */"
               "    void *ida_eh_data;         /* user pointer passed to ehfun                  */"
               "    FILE *ida_errfp;           /* IDA error messages are sent to errfp          */"
               ""
               "    /* Flags to verify correct calling sequence */"
               ""
               "    booleantype ida_SetupDone;     /* set to FALSE by IDAMalloc and IDAReInit   */"
               "    /* set to TRUE by IDACalcIC or IDASolve      */"
               ""
               "    booleantype ida_VatolMallocDone;"
               "    booleantype ida_constraintsMallocDone;"
               "    booleantype ida_idMallocDone;"
               ""
               "    booleantype ida_MallocDone;    /* set to FALSE by IDACreate                 */"
               "    /* set to TRUE by IDAMAlloc                  */"
               "    /* tested by IDAReInit and IDASolve          */"
               ""
               "    /* Linear Solver Data */"
               ""
               "    /* Linear Solver functions to be called */"
               ""
               "    int (*ida_linit)(struct IDAMemRec *idamem);"
               ""
               "    int (*ida_lsetup)(struct IDAMemRec *idamem, N_Vector yyp, "
               "                      N_Vector ypp, N_Vector resp, "
               "                      N_Vector tempv1, N_Vector tempv2, N_Vector tempv3); "
               ""
               "    int (*ida_lsolve)(struct IDAMemRec *idamem, N_Vector b, N_Vector weight,"
               "                      N_Vector ycur, N_Vector ypcur, N_Vector rescur);"
               ""
               "    int (*ida_lperf)(struct IDAMemRec *idamem, int perftask);"
               ""
               "    int (*ida_lfree)(struct IDAMemRec *idamem);"
               ""
               "    /* Linear Solver specific memory */"
               ""
               "    void *ida_lmem;           "
               ""
               "    /* Flag to indicate successful ida_linit call */"
               ""
               "    booleantype ida_linitOK;"
               ""
               "    /* Rootfinding Data */"
               ""
               "    IDARootFn ida_gfun;    /* Function g for roots sought                     */"
               "    int ida_nrtfn;         /* number of components of g                       */"
               "    void *ida_g_data;      /* pointer to user data for g                      */"
               "    int *ida_iroots;       /* int array for root information                  */"
               "    realtype ida_tlo;      /* nearest endpoint of interval in root search     */"
               "    realtype ida_thi;      /* farthest endpoint of interval in root search    */"
               "    realtype ida_trout;    /* t return value from rootfinder routine          */"
               "    realtype *ida_glo;     /* saved array of g values at t = tlo              */"
               "    realtype *ida_ghi;     /* saved array of g values at t = thi              */"
               "    realtype *ida_grout;   /* array of g values at t = trout                  */"
               "    realtype ida_toutc;    /* copy of tout (if NORMAL mode)                   */"
               "    realtype ida_ttol;     /* tolerance on root location                      */"
               "    int ida_taskc;         /* copy of parameter task                          */"
               "    int ida_irfnd;         /* flag showing whether last step had a root       */"
               "    long int ida_nge;      /* counter for g evaluations                       */"
               "    int ida_fcallerid;     /* indicates the ID of the function invoking the user supplied function  */"
               ""
               "  } *IDAMem;"
               ""
               "  /*"
               "   * ================================================================="
               "   *     I N T E R F A C E   T O    L I N E A R   S O L V E R S     "
               "   * ================================================================="
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * int (*ida_linit)(IDAMem IDA_mem);                               "
               "   * -----------------------------------------------------------------"
               "   * The purpose of ida_linit is to allocate memory for the          "
               "   * solver-specific fields in the structure *(idamem->ida_lmem) and "
               "   * perform any needed initializations of solver-specific memory,   "
               "   * such as counters/statistics. An (*ida_linit) should return      "
               "   * 0 if it has successfully initialized the IDA linear solver and "
               "   * a non-zero value otherwise. If an error does occur, an appropriate"
               "   * message should be sent to the error handler function."
               "   * ----------------------------------------------------------------"
               "   */                                                                 "
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * int (*ida_lsetup)(IDAMem IDA_mem, N_Vector yyp, N_Vector ypp,   "
               "   *                  N_Vector resp,                                 "
               "   *            N_Vector tempv1, N_Vector tempv2, N_Vector tempv3);  "
               "   * -----------------------------------------------------------------"
               "   * The job of ida_lsetup is to prepare the linear solver for       "
               "   * subsequent calls to ida_lsolve. Its parameters are as follows:  "
               "   *                                                                 "
               "   * idamem - problem memory pointer of type IDAMem. See the big     "
               "   *          typedef earlier in this file.                          "
               "   *                                                                 "
               "   *                                                                 "
               "   * yyp   - the predicted y vector for the current IDA internal     "
               "   *         step.                                                   "
               "   *                                                                 "
               "   * ypp   - the predicted y'' vector for the current IDA internal    "
               "   *         step.                                                   "
               "   *                                                                 "
               "   * resp  - F(tn, yyp, ypp).                                        "
               "   *                                                                 "
               "   * tempv1, tempv2, tempv3 - temporary N_Vectors provided for use   "
               "   *         by ida_lsetup.                                          "
               "   *                                                                 "
               "   * The ida_lsetup routine should return 0 if successful,"
               "   * a positive value for a recoverable error, and a negative value "
               "   * for an unrecoverable error."
               "   * -----------------------------------------------------------------"
               "   */                                                                 "
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * int (*ida_lsolve)(IDAMem IDA_mem, N_Vector b, N_Vector weight,  "
               "   *               N_Vector ycur, N_Vector ypcur, N_Vector rescur);  "
               "   * -----------------------------------------------------------------"
               "   * ida_lsolve must solve the linear equation P x = b, where        "
               "   * P is some approximation to the system Jacobian                  "
               "   *                  J = (dF/dy) + cj (dF/dy'')                      "
               "   * evaluated at (tn,ycur,ypcur) and the RHS vector b is input.     "
               "   * The N-vector ycur contains the solver''s current approximation   "
               "   * to y(tn), ypcur contains that for y''(tn), and the vector rescur "
               "   * contains the N-vector residual F(tn,ycur,ypcur).                "
               "   * The solution is to be returned in the vector b. "
               "   *                                                                 "
               "   * The ida_lsolve routine should return 0 if successful,"
               "   * a positive value for a recoverable error, and a negative value "
               "   * for an unrecoverable error."
               "   * -----------------------------------------------------------------"
               "   */                                                                 "
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * int (*ida_lperf)(IDAMem IDA_mem, int perftask);                 "
               "   * -----------------------------------------------------------------"
               "   * ida_lperf is called two places in IDA where linear solver       "
               "   * performance data is required by IDA. For perftask = 0, an       "
               "   * initialization of performance variables is performed, while for "
               "   * perftask = 1, the performance is evaluated.                     "
               "   * -----------------------------------------------------------------"
               "   */                                                                 "
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * int (*ida_lfree)(IDAMem IDA_mem);                               "
               "   * -----------------------------------------------------------------"
               "   * ida_lfree should free up any memory allocated by the linear     "
               "   * solver. This routine is called once a problem has been          "
               "   * completed and the linear solver is no longer needed.            "
               "   * -----------------------------------------------------------------"
               "   */                                                                 "
               ""
               "  /*"
               "   * ================================================================="
               "   *   I D A    I N T E R N A L   F U N C T I O N S"
               "   * ================================================================="
               "   */"
               ""
               "  /* Prototype of internal ewtSet function */"
               ""
               "  int IDAEwtSet(N_Vector ycur, N_Vector weight, void *e_data);"
               ""
               "  /* High level error handler */"
               ""
               "  void IDAProcessError(IDAMem IDA_mem, "
               "                       int error_code, const char *module, const char *fname, "
               "                       const char *msgfmt, ...);"
               ""
               "  /* Prototype of internal errHandler function */"
               ""
               "  void IDAErrHandler(int error_code, const char *module, const char *function, "
               "                     char *msg, void *eh_data);"
               ""
               "  /*"
               "   * ================================================================="
               "   * I D A    E R R O R    M E S S A G E S"
               "   * ================================================================="
               "   */"
               ""
               "#if defined(SUNDIALS_EXTENDED_PRECISION)"
               ""
               "#define MSG_TIME ""t = %Lg, """
               "#define MSG_TIME_H ""t = %Lg and h = %Lg, """
               "#define MSG_TIME_INT ""t = %Lg is not between tcur - hu = %Lg and tcur = %Lg."""
               "#define MSG_TIME_TOUT ""tout = %Lg"""
               ""
               "#elif defined(SUNDIALS_DOUBLE_PRECISION)"
               ""
               "#define MSG_TIME ""t = %lg, """
               "#define MSG_TIME_H ""t = %lg and h = %lg, """
               "#define MSG_TIME_INT ""t = %lg is not between tcur - hu = %lg and tcur = %lg."""
               "#define MSG_TIME_TOUT ""tout = %lg"""
               ""
               "#else"
               ""
               "#define MSG_TIME ""t = %g, """
               "#define MSG_TIME_H ""t = %g and h = %g, """
               "#define MSG_TIME_INT ""t = %g is not between tcur - hu = %g and tcur = %g."""
               "#define MSG_TIME_TOUT ""tout = %g"""
               ""
               "#endif"
               ""
               "  /* General errors */"
               ""
               "#define MSG_MEM_FAIL       ""A memory request failed."""
               "#define MSG_NO_MEM         ""ida_mem = NULL illegal."""
               "#define MSG_NO_MALLOC      ""Attempt to call before IDAMalloc."""
               "#define MSG_BAD_NVECTOR    ""A required vector operation is not implemented."""
               ""
               "  /* Initialization errors */"
               ""
               "#define MSG_Y0_NULL        ""y0 = NULL illegal."""
               "#define MSG_YP0_NULL       ""yp0 = NULL illegal."""
               "#define MSG_BAD_ITOL       ""Illegal value for itol. The legal values are IDA_SS, IDA_SV, and IDA_WF."""
               "#define MSG_RES_NULL       ""res = NULL illegal."""
               "#define MSG_BAD_RTOL       ""reltol < 0 illegal."""
               "#define MSG_ATOL_NULL      ""abstol = NULL illegal."""
               "#define MSG_BAD_ATOL       ""Some abstol component < 0.0 illegal."""
               "#define MSG_ROOT_FUNC_NULL ""g = NULL illegal."""
               ""
               "#define MSG_MISSING_ID     ""id = NULL but suppressalg option on."""
               "#define MSG_NO_EFUN        ""itol = IDA_WF but no EwtSet function was provided."""
               "#define MSG_FAIL_EWT       ""The user-provide EwtSet function failed."""
               "#define MSG_BAD_EWT        ""Some initial ewt component = 0.0 illegal."""
               "#define MSG_Y0_FAIL_CONSTR ""y0 fails to satisfy constraints."""
               "#define MSG_LSOLVE_NULL    ""The linear solver''s solve routine is NULL."""
               "#define MSG_LINIT_FAIL     ""The linear solver''s init routine failed."""
               ""
               "  /* IDACalcIC error messages */"
               ""
               "#define MSG_IC_BAD_ICOPT   ""icopt has an illegal value."""
               "#define MSG_IC_MISSING_ID  ""id = NULL conflicts with icopt."""
               "#define MSG_IC_TOO_CLOSE   ""tout1 too close to t0 to attempt initial condition calculation."""
               "#define MSG_IC_BAD_ID      ""id has illegal values."""
               "#define MSG_IC_BAD_EWT     ""Some initial ewt component = 0.0 illegal."""
               "#define MSG_IC_RES_NONREC  ""The residual function failed unrecoverably. """
               "#define MSG_IC_RES_FAIL    ""The residual function failed at the first call. """
               "#define MSG_IC_SETUP_FAIL  ""The linear solver setup failed unrecoverably."""
               "#define MSG_IC_SOLVE_FAIL  ""The linear solver solve failed unrecoverably."""
               "#define MSG_IC_NO_RECOVERY ""The residual routine or the linear setup or solve routine had a recoverable error, but IDACalcIC was unable to recover."""
               "#define MSG_IC_FAIL_CONSTR ""Unable to satisfy the inequality constraints."""
               "#define MSG_IC_FAILED_LINS ""The linesearch algorithm failed with too small a step."""
               "#define MSG_IC_CONV_FAILED ""Newton/Linesearch algorithm failed to converge."""
               ""
               "  /* IDASolve error messages */"
               ""
               "#define MSG_YRET_NULL      ""yret = NULL illegal."""
               "#define MSG_YPRET_NULL     ""ypret = NULL illegal."""
               "#define MSG_TRET_NULL      ""tret = NULL illegal."""
               "#define MSG_BAD_ITASK      ""itask has an illegal value."""
               "#define MSG_NO_TSTOP       ""tstop not set for this itask. """
               "#define MSG_TOO_CLOSE      ""tout too close to t0 to start integration."""
               "#define MSG_BAD_HINIT      ""Initial step is not towards tout."""
               "#define MSG_BAD_TSTOP      ""tstop is behind current "" MSG_TIME ""in the direction of integration."""
               "#define MSG_BAD_INIT_ROOT  ""Root found at and very near initial t."""
               "#define MSG_CLOSE_ROOTS    ""Root found at and very near "" MSG_TIME ""."""
               "#define MSG_MAX_STEPS      ""At "" MSG_TIME "", mxstep steps taken before reaching tout."" "
               "#define MSG_EWT_NOW_FAIL   ""At "" MSG_TIME ""the user-provide EwtSet function failed."""
               "#define MSG_EWT_NOW_BAD    ""At "" MSG_TIME ""some ewt component has become <= 0.0."""
               "#define MSG_TOO_MUCH_ACC   ""At "" MSG_TIME ""too much accuracy requested."""
               ""
               "#define MSG_BAD_T          ""Illegal value for t."" MSG_TIME_INT"
               "#define MSG_BAD_TOUT       ""Trouble interpolating at "" MSG_TIME_TOUT "". tout too far back in direction of integration."""
               ""
               "#define MSG_ERR_FAILS      ""At "" MSG_TIME_H ""the error test failed repeatedly or with |h| = hmin."""
               "#define MSG_CONV_FAILS     ""At "" MSG_TIME_H ""the corrector convergence failed repeatedly or with |h| = hmin."""
               "#define MSG_SETUP_FAILED   ""At "" MSG_TIME ""the linear solver setup failed unrecoverably."""
               "#define MSG_SOLVE_FAILED   ""At "" MSG_TIME ""the linear solver solve failed unrecoverably."""
               "#define MSG_REP_RES_ERR    ""At "" MSG_TIME ""repeated recoverable residual errors."""
               "#define MSG_RES_NONRECOV   ""At "" MSG_TIME ""the residual function failed unrecoverably."""
               "#define MSG_FAILED_CONSTR  ""At "" MSG_TIME ""unable to satisfy inequality constraints."""
               "#define MSG_RTFUNC_FAILED  ""At "" MSG_TIME "", the rootfinding routine failed in an unrecoverable manner."""
               ""
               "  /* IDASet* / IDAGet* error messages */"
               ""
               "#define MSG_NEG_MAXORD     ""maxord<=0 illegal."""
               "#define MSG_BAD_MAXORD     ""Illegal attempt to increase maximum order."""
               "#define MSG_NEG_MXSTEPS    ""mxsteps < 0 illegal."""
               "#define MSG_NEG_HMAX       ""hmax < 0 illegal."""
               "#define MSG_NEG_EPCON      ""epcon < 0.0 illegal."""
               "#define MSG_BAD_CONSTR     ""Illegal values in constraints vector."""
               "#define MSG_BAD_EPICCON    ""epiccon < 0.0 illegal."""
               "#define MSG_BAD_MAXNH      ""maxnh < 0 illegal."""
               "#define MSG_BAD_MAXNJ      ""maxnj < 0 illegal."""
               "#define MSG_BAD_MAXNIT     ""maxnit < 0 illegal."""
               "#define MSG_BAD_STEPTOL    ""steptol < 0.0 illegal."""
               ""
               "#define MSG_TOO_LATE       ""IDAGetConsistentIC can only be called before IDASolve."""
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'kinsol_dense.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * Revision: 1.1 $"
               " * Date: 2008-11-17 16:26:32 $"
               " * -----------------------------------------------------------------"
               " * Programmer(s): Radu Serban @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * This is the header file for the KINSOL dense linear solver module, "
               " * KINDENSE."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#ifndef _KINDENSE_H"
               "#define _KINDENSE_H"
               ""
               "#include ""sundials_dense.h"""
               "#include ""sundials_nvector.h"""
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Type : KINDenseJacFn"
               " * -----------------------------------------------------------------"
               " * A dense Jacobian approximation function Jac must have the"
               " * prototype given below. Its parameters are:"
               " *"
               " * N is the problem size."
               " *"
               " * J is the dense matrix (of type DenseMat) that will be loaded"
               " * by a KINDenseJacFn with an approximation to the Jacobian matrix"
               " * J = (df_i/dy_j)."
               " * J is preset to zero, so only the nonzero elements need to be"
               " * loaded. Two efficient ways to load J are:"
               " *"
               " * (1) (with macros - no explicit data structure references)"
               " *     for (j=0; j < n; j++) {"
               " *       col_j = DENSE_COL(J,j);"
               " *       for (i=0; i < n; i++) {"
               " *         generate J_ij = the (i,j)th Jacobian element"
               " *         col_j[i] = J_ij;"
               " *       }"
               " *     }"
               " *"
               " * (2) (without macros - explicit data structure references)"
               " *     for (j=0; j < n; j++) {"
               " *       col_j = (J->data)[j];"
               " *       for (i=0; i < n; i++) {"
               " *         generate J_ij = the (i,j)th Jacobian element"
               " *         col_j[i] = J_ij;"
               " *       }"
               " *     }"
               " *"
               " * The DENSE_ELEM(A,i,j) macro is appropriate for use in small"
               " * problems in which efficiency of access is NOT a major concern."
               " *"
               " * uu   current iterate (unscaled) [input]"
               " *"
               " * fval  vector (type N_Vector) containing result of nonlinear"
               " *     system function evaluated at current iterate:"
               " *     fval = F(uu) [input]"
               " *"
               " * jac_data is a pointer to user data - the same as the jac_data"
               " *          parameter passed to KINDenseSetJacFn."
               " *"
               " * vtemp1, vtemp2  available scratch vectors (volatile storage)"
               " *"
               " * If successful, the function should return 0 (zero). If an error"
               " * occurs, then the routine should return a non-zero integer value."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "typedef int (*KINDenseJacFn)(long int N, DenseMat J, "
               "                             N_Vector uu, N_Vector fval, void *jac_data,"
               "                             N_Vector vtemp1, N_Vector vtemp2);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : KINDense"
               " * -----------------------------------------------------------------"
               " * A call to the KINDense function links the main solver with"
               " * the KINDENSE linear solver."
               " *"
               " * kinmem pointer to an internal memory block allocated during a"
               " *          prior call to KINCreate"
               " *"
               " * N is the problem size"
               " *"
               " * The return value of KINDense is one of:"
               " *    KINDENSE_SUCCESS   if successful"
               " *    KINDENSE_MEM_NULL  if the kinsol memory was NULL"
               " *    KINDENSE_MEM_FAIL  if there was a memory allocation failure"
               " *    KINDENSE_ILL_INPUT if a required vector operation is missing"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "int KINDense(void *kinmem, long int N);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Optional inputs to the KINDENSE linear solver"
               " * -----------------------------------------------------------------"
               " *"
               " * KINDenseSetJacFn specifies the dense Jacobian approximation"
               " *                 routine to be used. A user-supplied djac routine"
               " *                 must be of type KINDenseJacFn. By default, a"
               " *                 difference quotient routine KINDenseDQJac, supplied"
               " *                 with this solver is used.                     "
               " *                 It also specifies a pointer to user data which is"
               " *                 passed to the djac routine every time it is called."
               " *"
               " * The return value of KINDenseSetJacFn is one of:"
               " *    KINDENSE_SUCCESS   if successful"
               " *    KINDENSE_MEM_NULL  if the kinsol memory was NULL"
               " *    KINDENSE_LMEM_NULL if the kindense memory was NULL"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "int KINDenseSetJacFn(void *kinmem, KINDenseJacFn djac, void *jac_data);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Optional outputs from the KINDENSE linear solver"
               " * -----------------------------------------------------------------"
               " *"
               " * KINDenseGetWorkSpace returns the real and integer workspace used"
               " *                      by KINDENSE."
               " * KINDenseGetNumJacEvals returns the number of calls made to the"
               " *                        Jacobian evaluation routine djac."
               " * KINDenseGetNumFuncEvals returns the number of calls to the user"
               " *                         f routine due to finite difference Jacobian"
               " *                         evaluation."
               " * KINDenseGetLastFlag returns the last error flag set by any of"
               " *                     the KINDENSE interface functions."
               " *"
               " * KINDenseGetReturnFlagName returns the name of a constant associated"
               " *                           with a KINDENSE return flag"
               " *"
               " * The return value of KINDenseGet* is one of:"
               " *    KINDENSE_SUCCESS   if successful"
               " *    KINDENSE_MEM_NULL  if the kinsol memory was NULL"
               " *    KINDENSE_LMEM_NULL if the kindense memory was NULL"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "int KINDenseGetWorkSpace(void *kinmem, long int *lenrwD, long int *leniwD);"
               "int KINDenseGetNumJacEvals(void *kinmem, long int *njevalsD);"
               "int KINDenseGetNumFuncEvals(void *kinmem, long int *nfevalsD);"
               "int KINDenseGetLastFlag(void *kinmem, int *flag);"
               "char *KINDenseGetReturnFlagName(int flag);"
               ""
               "/* CVDENSE return values */"
               ""
               "#define KINDENSE_SUCCESS    0"
               "#define KINDENSE_MEM_NULL  -1"
               "#define KINDENSE_LMEM_NULL -2"
               "#define KINDENSE_ILL_INPUT -3"
               "#define KINDENSE_MEM_FAIL  -4"
               ""
               "#endif"
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"]

      case 'kinsol_dense_impl.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * Revision: 1.1 $"
               " * Date: 2008-11-17 16:26:32 $"
               " * -----------------------------------------------------------------"
               " * Programmer(s): Radu Serban @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * KINDENSE linear solver module header file (private version)"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#ifndef _KINDENSE_IMPL_H"
               "#define _KINDENSE_IMPL_H"
               ""
               "#include ""kinsol_dense.h"""
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Types : KINDenseMemRec, KINDenseMem                             "
               " * -----------------------------------------------------------------"
               " * The type KINDenseMem is pointer to a KINDenseMemRec."
               " * This structure contains KINDENSE solver-specific data. "
               " * -----------------------------------------------------------------"
               " */"
               ""
               "typedef struct {"
               ""
               "  long int d_n;       /* problem dimension                      */"
               ""
               "  KINDenseJacFn d_jac; /* jac = Jacobian routine to be called   */"
               ""
               "  DenseMat d_J;       /* problem Jacobian                       */"
               "  "
               "  long int *d_pivots; /* pivots = pivot array for PM = LU       */"
               "  "
               "  long int d_nje;     /* nje = no. of calls to jac              */"
               ""
               "  long int d_nfeD;    /* nfeD = no. of calls to f due to"
               "                         difference quotient approximation of J */"
               "  "
               "  void *d_J_data;     /* J_data is passed to jac                */"
               ""
               "  int d_last_flag;    /* last error return flag                 */"
               "  "
               "} KINDenseMemRec, *KINDenseMem;"
               ""
               "/* Error Messages */"
               ""
               "#define MSGDS_KINMEM_NULL ""KINSOL memory is NULL."""
               "#define MSGDS_BAD_NVECTOR ""A required vector operation is not implemented."""
               "#define MSGDS_MEM_FAIL    ""A memory request failed."""
               "#define MSGDS_LMEM_NULL   ""KINDENSE memory is NULL."""
               ""
               "#endif"
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"]

      case 'kinsol.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * Revision: 1.1 $"
               " * Date: 2008-11-17 16:26:32 $"
               " * -----------------------------------------------------------------"
               " * Programmer(s): Allan Taylor, Alan Hindmarsh, Radu Serban, and"
               " *                Aaron Collier @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * KINSOL solver module header file"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _KINSOL_H"
               "#define _KINSOL_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include <stdio.h>"
               ""
               "#include ""sundials_nvector.h"""
               ""
               "  /*"
               "   * ================================================================="
               "   *              K I N S O L     C O N S T A N T S"
               "   * ================================================================="
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * KINSOL return flags"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "#define KIN_SUCCESS             0"
               "#define KIN_INITIAL_GUESS_OK    1"
               "#define KIN_STEP_LT_STPTOL      2"
               ""
               "#define KIN_WARNING             99"
               ""
               "#define KIN_MEM_NULL            -1"
               "#define KIN_ILL_INPUT           -2"
               "#define KIN_NO_MALLOC           -3"
               "#define KIN_MEM_FAIL            -4"
               "#define KIN_LINESEARCH_NONCONV  -5"
               "#define KIN_MAXITER_REACHED     -6"
               "#define KIN_MXNEWT_5X_EXCEEDED  -7"
               "#define KIN_LINESEARCH_BCFAIL   -8"
               "#define KIN_LINSOLV_NO_RECOVERY -9"
               "#define KIN_LINIT_FAIL          -10"
               "#define KIN_LSETUP_FAIL         -11"
               "#define KIN_LSOLVE_FAIL         -12"
               ""
               "#define KIN_SYSFUNC_FAIL        -13"
               "#define KIN_FIRST_SYSFUNC_ERR   -14"
               "#define KIN_REPTD_SYSFUNC_ERR   -15"
               "#define KIN_NAN_ERR             -16"
               ""
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Enumeration for inputs to KINSetEtaForm (eta choice)"
               "   * -----------------------------------------------------------------"
               "   * KIN_ETACONSTANT : use constant value for eta (default value is"
               "   *                   0.1 but a different value can be specified via"
               "   *                   a call to KINSetEtaConstValue)"
               "   *"
               "   * KIN_ETACHOICE1 : use choice #1 as given in Eisenstat and Walker''s"
               "   *                  paper of SIAM J.Sci.Comput.,17 (1996), pp 16-32,"
               "   *                  wherein eta is defined to be:"
               "   *"
               "   *              eta(k+1) = ABS(||F(u_k+1)||_L2-||F(u_k)+J(u_k)*p_k||_L2)"
               "   *                       ---------------------------------------------"
               "   *                                       ||F(u_k)||_L2"
               "   *"
               "   *                                                      1+sqrt(5)"
               "   *              eta_safe = eta(k)^ealpha where ealpha = ---------"
               "   *                                                          2"
               "   *"
               "   * KIN_ETACHOICE2 : use choice #2 as given in Eisenstat and Walker''s"
               "   *                  paper wherein eta is defined to be:"
               "   *"
               "   *                                  [ ||F(u_k+1)||_L2 ]^ealpha"
               "   *              eta(k+1) = egamma * [ --------------- ]"
               "   *                                  [  ||F(u_k)||_L2  ]"
               "   *"
               "   *                  where egamma = [0,1] and ealpha = (1,2]"
               "   *"
               "   *              eta_safe = egamma*(eta(k)^ealpha)"
               "   *"
               "   *                  Note: The default values of the scalar"
               "   *                  coefficients egamma and ealpha (both required)"
               "   *                  are egamma = 0.9 and ealpha = 2.0, but the"
               "   *                  routine KINSetEtaParams can be used to specify"
               "   *                  different values."
               "   *"
               "   * When using either KIN_ETACHOICE1 or KIN_ETACHOICE2, if"
               "   * eta_safe > 0.1 then the following safeguard is applied:"
               "   *"
               "   *  eta(k+1) = MAX {eta(k+1), eta_safe}"
               "   *"
               "   * The following safeguards are always applied when using either"
               "   * KIN_ETACHOICE1 or KIN_ETACHOICE2 so that eta_min <= eta <= eta_max:"
               "   *"
               "   *  eta(k+1) = MAX {eta(k+1), eta_min}"
               "   *  eta(k+1) = MIN {eta(k+1), eta_max}"
               "   *"
               "   * where eta_min = 1.0e-4 and eta_max = 0.9 (see KINForcingTerm)."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "#define KIN_ETACHOICE1  1"
               "#define KIN_ETACHOICE2  2"
               "#define KIN_ETACONSTANT 3"
               "  "
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Enumeration for global strategy"
               "   * -----------------------------------------------------------------"
               "   * Choices are KIN_NONE and KIN_LINESEARCH."
               "   * -----------------------------------------------------------------"
               "   */"
               "  "
               "#define KIN_NONE       0"
               "#define KIN_LINESEARCH 1"
               ""
               "  /*"
               "   * ================================================================="
               "   *              F U N C T I O N   T Y P E S"
               "   * ================================================================="
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Type : KINSysFn"
               "   * -----------------------------------------------------------------"
               "   * The user-supplied subroutine implementing the nonlinear system"
               "   * function (vector-valued function) F must take as input the"
               "   * dependent variable vector uu (type N_Vector), and set fval (type"
               "   * N_Vector) equal to F(uu) before returning. Additional workspace"
               "   * is allocated by the user and referenced by the f_data memory"
               "   * pointer."
               "   * "
               "   * Note: The user-defined routine (internally referenced by a"
               "   * a pointer (type KINSysFn) named func) should have an ''int'' return"
               "   * value type. However, the return value is currently ignored."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef int (*KINSysFn)(N_Vector uu, N_Vector fval, void *f_data );"
               ""
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Type : KINErrHandlerFn"
               "   * -----------------------------------------------------------------"
               "   * A function eh, which handles error messages, must have type"
               "   * KINErrHandlerFn."
               "   * The function eh takes as input the error code, the name of the"
               "   * module reporting the error, the error message, and a pointer to"
               "   * user data, the same as that passed to KINSetErrHandlerFn."
               "   * "
               "   * All error codes are negative, except KIN_WARNING which indicates "
               "   * a warning (the solver continues)."
               "   *"
               "   * A KINErrHandlerFn has no return value."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef void (*KINErrHandlerFn)(int error_code, "
               "                                  const char *module, const char *function, "
               "                                  char *msg, void *eh_data); "
               ""
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Type : KINInfoHandlerFn"
               "   * -----------------------------------------------------------------"
               "   * A function ih, which handles info messages, must have type"
               "   * KINInfoHandlerFn."
               "   * The function ih takes as input the name of the module and of the"
               "   * function reporting the info message and a pointer to"
               "   * user data, the same as that passed to KINSetInfoHandlerFn."
               "   * "
               "   * A KINInfoHandlerFn has no return value."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef void (*KINInfoHandlerFn)(const char *module, const char *function, "
               "                                   char *msg, void *ih_data); "
               ""
               "  /*"
               "   * ================================================================"
               "   *          U S E R - C A L L A B L E   R O U T I N E S           "
               "   * ================================================================"
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : KINCreate"
               "   * -----------------------------------------------------------------"
               "   * KINCreate allocates and initializes an internal memory block for"
               "   * the KINSOL solver module."
               "   *"
               "   * If successful, KINCreate returns a pointer to the initialized"
               "   * memory block which should be passed to KINMalloc. If an"
               "   * error occurs, then KINCreate returns a NULL pointer."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void *KINCreate(void);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Optional Input Specification Functions (KINSOL)"
               "   * -----------------------------------------------------------------"
               "   * The following functions can be called to set optional inputs:"
               "   *"
               "   *     Function Name      |    Optional Input  [Default Value]"
               "   *                        |"
               "   * -----------------------------------------------------------------"
               "   *                        |"
               "   * KINSetErrHandlerFn     | user-provided ErrHandler function."
               "   *                        | [internal]"
               "   *                        |"
               "   * KINSetErrFile          | pointer (type FILE) indicating where all"
               "   *                        | warning/error messages should be sent"
               "   *                        | if the default internal error handler "
               "   *                        | is used"
               "   *                        | [stderr]"
               "   *                        |"
               "   * KINSetPrintLevel       | level of verbosity of output:"
               "   *                        |"
               "   *                        |  0  no statistical information is"
               "   *                        |     displayed (default level)"
               "   *                        |"
               "   *                        |  1  for each nonlinear iteration display"
               "   *                        |     the following information: the scaled"
               "   *                        |     norm (L2) of the system function"
               "   *                        |     evaluated at the current iterate, the"
               "   *                        |     scaled norm of the Newton step (only if"
               "   *                        |     using KIN_NONE), and the"
               "   *                        |     number of function evaluations performed"
               "   *                        |     thus far"
               "   *                        |"
               "   *                        |  2  display level 1 output and the"
               "   *                        |     following values for each iteration:"
               "   *                        |"
               "   *                        |       fnorm (L2) = ||fscale*func(u)||_L2"
               "   *                        |       (only for KIN_NONE)"
               "   *                        |"
               "   *                        |       scaled fnorm (for stopping) ="
               "   *                        |       ||fscale*ABS(func(u))||_L-infinity"
               "   *                        |       (for KIN_NONE and"
               "   *                        |       KIN_LINESEARCH)"
               "   *                        |"
               "   *                        |  3  display level 2 output plus additional"
               "   *                        |     values used by the global strategy"
               "   *                        |     (only if using KIN_LINESEARCH), and"
               "   *                        |     statistical information for the linear"
               "   *                        |     solver"
               "   *                        | [0]"
               "   *                        |"
               "   * KINSetInfoHandlerFn    | user-provided InfoHandler function."
               "   *                        | [internal]"
               "   *                        |"
               "   * KINSetInfoFile         | pointer (type FILE) specifying where"
               "   *                        | informative (non-error) messages should"
               "   *                        | be sent if the default internal info"
               "   *                        | handler is used"
               "   *                        | [stdout]"
               "   *                        |"
               "   * KINSetFdata            | pointer to user-allocated memory that is"
               "   *                        | passed to the user-supplied subroutine"
               "   *                        | implementing the nonlinear system function"
               "   *                        | F(u)"
               "   *                        | [NULL]"
               "   *                        |"
               "   * KINSetNumMaxIters      | maximum number of nonlinear iterations"
               "   *                        | [MXITER_DEFAULT] (defined in kinsol_impl.h)"
               "   *                        |"
               "   * KINSetNoInitSetup      | flag controlling whether or not the"
               "   *                        | KINSol routine makes an initial call"
               "   *                        | to the linear solver setup routine (lsetup)"
               "   *                        | (possible values are TRUE and FALSE)"
               "   *                        | [FALSE]"
               "   *                        |"
               "   * KINSetNoResMon         | flag controlling whether or not the nonlinear"
               "   *                        | residual monitoring scheme is used to control"
               "   *                        | Jacobian updating (possible values are TRUE"
               "   *                        | and FALSE)"
               "   *                        | [FALSE if using direct linear solver]"
               "   *                        | [TRUE if using inexact linear solver]"
               "   *                        |"
               "   * KINSetMaxSetupCalls    | mbset, number of nonlinear iteraions, such "
               "   *                        | that a call to the linear solver setup routine"
               "   *                        | (lsetup) is forced every mbset iterations."
               "   *                        | If mbset=1, lsetup s called at every iteration."
               "   *                        | [MSBSET_DEFAULT] (defined in kinsol_impl.h)"
               "   *                        |"
               "   * KINSetMaxSubSetupCalls | mbsetsub is the number of nonlinear iterations"
               "   *                        | between checks by the nonlinear residual"
               "   *                        | monitoring algorithm (specifies length of"
               "   *                        | subinterval)"
               "   *                        | NOTE: mbset should be a multiple of mbsetsub"
               "   *                        | [MSBSET_SUB_DEFAULT] (defined in kinsol_impl.h)"
               "   *                        |"
               "   * KINSetEtaForm          | flag indicating which method to use to"
               "   *                        | compute the value of the eta coefficient"
               "   *                        | used in the calculation of the linear"
               "   *                        | solver convergence tolerance:"
               "   *                        |"
               "   *                        |  eps = (eta+uround)*||fscale*func(u)||_L2"
               "   *                        |"
               "   *                        | the linear solver tests for convergence by"
               "   *                        | checking if the following inequality has"
               "   *                        | been satisfied:"
               "   *                        |"
               "   *                        |  ||fscale*(func(u)+J(u)*p)||_L2 <= eps"
               "   *                        |"
               "   *                        | where J(u) is the system Jacobian"
               "   *                        | evaluated at the current iterate, and p"
               "   *                        | denotes the Newton step"
               "   *                        |"
               "   *                        | choices for computing eta are as follows:"
               "   *                        |"
               "   *                        |  KIN_ETACHOICE1  (refer to KINForcingTerm)"
               "   *                        |"
               "   *                        |  eta = ABS(||F(u_k+1)||_L2-||F(u_k)+J(u_k)*p_k||_L2)"
               "   *                        |        ---------------------------------------------"
               "   *                        |                        ||F(u_k)||_L2"
               "   *                        | "
               "   *                        |  KIN_ETACHOICE2  (refer to KINForcingTerm)"
               "   *                        |"
               "   *                        |                [ ||F(u_k+1)||_L2 ]^alpha"
               "   *                        |  eta = gamma * [ --------------- ]"
               "   *                        |                [  ||F(u_k)||_L2  ]"
               "   *                        |"
               "   *                        |  where gamma = [0,1] and alpha = (1,2]"
               "   *                        |"
               "   *                        |  KIN_ETACONSTANT  use a constant value for eta"
               "   *                        | [KIN_ETACHOICE1]"
               "   *                        |"
               "   * KINSetEtaConstValue    | constant value of eta - use with"
               "   *                        | KIN_ETACONSTANT option"
               "   *                        | [0.1]"
               "   *                        |"
               "   * KINSetEtaParams        | values of eta_gamma (egamma) and eta_alpha"
               "   *                        | (ealpha) coefficients - use with KIN_ETACHOICE2"
               "   *                        | option"
               "   *                        | [0.9 and 2.0]"
               "   *                        |"
               "   * KINSetResMonParams     | values of omega_min and omega_max scalars"
               "   *                        | used by nonlinear residual monitoring"
               "   *                        | algorithm (see KINStop)"
               "   *                        | [0.00001 and 0.9]"
               "   *                        |"
               "   * KINSetResMonConstValue | constant value used by residual monitoring"
               "   *                        | algorithm. If omega=0, then it is estimated"
               "   *                        | using omega_min and omega_max."
               "   *                        | [0.0]"
               "   *                        |"
               "   * KINSetNoMinEps         | flag controlling whether or not the value"
               "   *                        | of eps is bounded below by 0.01*fnormtol"
               "   *                        | (see KINSetFuncNormTol)"
               "   *                        |"
               "   *                        |  FALSE  constrain value of eps by setting"
               "   *                        |         to the following:"
               "   *                        |"
               "   *                        |          eps = MAX{0.01*fnormtol, eps}"
               "   *                        |"
               "   *                        |  TRUE  do not constrain value of eps"
               "   *                        | [FALSE]"
               "   *                        |"
               "   * KINSetMaxNewtonStep    | maximum scaled length of Newton step"
               "   *                        | (reset to value of one if user-supplied"
               "   *                        | value is less than one)"
               "   *                        | [1000*||uscale*u_0||_L2]"
               "   *                        |"
               "   * KINSetMaxBetaFails     | maximum number of beta condition failures"
               "   *                        | in the line search algorithm."
               "   *                        | [MXNBCF_DEFAULT] (defined in kinsol_impl.h)"
               "   *                        |"
               "   * KINSetRelErrFunc       | real scalar equal to realative error in"
               "   *                        | computing F(u) (used in difference-"
               "   *                        | quotient approximation of matrix-vector"
               "   *                        | product J(u)*v)"
               "   *                        | [(uround)^1/2]"
               "   *                        |"
               "   * KINSetFuncNormTol      | real scalar used as stopping tolerance on"
               "   *                        | ||fscale*ABS(func(u))||_L-infinity (see"
               "   *                        | KINStop and KINInitialStop)"
               "   *                        | [(uround)^1/3]"
               "   *                        |"
               "   * KINSetScaledStepTol    | real scalar used as stopping tolerance on"
               "   *                        | the maximum scaled step length:"
               "   *                        |"
               "   *                        |  ||    u_k+1 - u_k    ||"
               "   *                        |  || ----------------- ||_L-infinity"
               "   *                        |  || ABS(u_k+1)+uscale ||"
               "   *                        |"
               "   *                        | (see KINStop)"
               "   *                        | [(uround)^2/3]"
               "   *                        |"
               "   * KINSetConstraints      | pointer to an array (type N_Vector) of"
               "   *                        | constraints on the solution vector u"
               "   *                        | "
               "   *                        | if constraints[i] ="
               "   *                        |"
               "   *                        |   0  u[i] not constrained"
               "   *                        |"
               "   *                        |  +1  u[i] constrained to be >= 0"
               "   *                        |  -1  u[i] constrained to be <= 0"
               "   *                        |"
               "   *                        |  +2  u[i] constrained to be > 0"
               "   *                        |  -2  u[i] constrained to be < 0"
               "   *                        |"
               "   *                        | if a NULL pointer is given, then no"
               "   *                        | constraints are applied to vector u"
               "   *                        | [NULL]"
               "   *                        |"
               "   * KINSetSysFunc          | set the user-provided routine which"
               "   *                        | defines the nonlinear problem to be "
               "   *                        | solved"
               "   *                        | [none]"
               "   * -----------------------------------------------------------------"
               "   * The possible return values for the KINSet* subroutines are the"
               "   * following:"
               "   *"
               "   * KIN_SUCCESS : means the associated variable was successfully"
               "   *               set [0]"
               "   *"
               "   * KIN_MEM_NULL : means a NULL KINSOL memory block pointer was given"
               "   *                (must call the KINCreate and KINMalloc memory"
               "   *                allocation subroutines prior to calling KINSol) [-1]"
               "   *"
               "   * KIN_ILL_INPUT : means the supplied parameter was invalid (check"
               "   *                 error message) [-2]"
               "   * -----------------------------------------------------------------"
               "   * Note: If successful, these functions return KIN_SUCCESS. If an"
               "   * argument has an illegal value, then an error message is printed"
               "   * to the file specified by errfp and an error code is returned."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int KINSetErrHandlerFn(void *kinmem, KINErrHandlerFn ehfun, void *eh_data);"
               "  int KINSetErrFile(void *kinmem, FILE *errfp);"
               "  int KINSetInfoHandlerFn(void *kinmem, KINInfoHandlerFn ihfun, void *ih_data);"
               "  int KINSetInfoFile(void *kinmem, FILE *infofp);"
               "  int KINSetFdata(void *kinmem, void *f_data);"
               "  int KINSetPrintLevel(void *kinmemm, int printfl);"
               "  int KINSetNumMaxIters(void *kinmem, long int mxiter);"
               "  int KINSetNoInitSetup(void *kinmem, booleantype noInitSetup);"
               "  int KINSetNoResMon(void *kinmem, booleantype noNNIResMon);"
               "  int KINSetMaxSetupCalls(void *kinmem, long int msbset);"
               "  int KINSetMaxSubSetupCalls(void *kinmem, long int msbsetsub);"
               "  int KINSetEtaForm(void *kinmem, int etachoice);"
               "  int KINSetEtaConstValue(void *kinmem, realtype eta);"
               "  int KINSetEtaParams(void *kinmem, realtype egamma, realtype ealpha);"
               "  int KINSetResMonParams(void *kinmem, realtype omegamin, realtype omegamax);"
               "  int KINSetResMonConstValue(void *kinmem, realtype omegaconst);"
               "  int KINSetNoMinEps(void *kinmem, booleantype noMinEps);"
               "  int KINSetMaxNewtonStep(void *kinmem, realtype mxnewtstep);"
               "  int KINSetMaxBetaFails(void *kinmem, long int mxnbcf);"
               "  int KINSetRelErrFunc(void *kinmem, realtype relfunc);"
               "  int KINSetFuncNormTol(void *kinmem, realtype fnormtol);"
               "  int KINSetScaledStepTol(void *kinmem, realtype scsteptol);"
               "  int KINSetConstraints(void *kinmem, N_Vector constraints);"
               "  int KINSetSysFunc(void *kinmem, KINSysFn func);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : KINMalloc"
               "   * -----------------------------------------------------------------"
               "   * KINMalloc allocates additional memory for vector storage and"
               "   * sets a couple problem-specific KINSOL variables."
               "   *"
               "   * Note: Additional vectors must be initialized by the user and"
               "   * passed to the KINSol routine."
               "   *"
               "   *  kinmem  pointer to an internal memory block allocated during a"
               "   *          prior call to KINCreate"
               "   *"
               "   *  func  name of user-supplied subroutine implementing the"
               "   *        nonlinear function F(u)"
               "   *"
               "   *  tmpl  implementation-specific template vector (type N_Vector)"
               "   *        (created using either N_VNew_Serial or N_VNew_Parallel)"
               "   *"
               "   * KINMalloc return flags: KIN_SUCCESS, KIN_MEM_NULL, KIN_ILL_INPUT,"
               "   * and KIN_MEM_FAIL (see below). If an error occurs, then KINMalloc"
               "   * prints an error message."
               "   *"
               "   * -----------------------------------------------------------------"
               "   * The possible return values for the KINMalloc subroutine are the"
               "   * following:"
               "   *"
               "   * KIN_SUCCESS : means the necessary system memory was successfully"
               "   *               allocated [0]"
               "   *"
               "   * KIN_MEM_NULL : means a NULL KINSOL memory block pointer was given"
               "   *                (must call the KINCreate routine before calling"
               "   *                KINMalloc) [-1]"
               "   *"
               "   * KIN_ILL_INPUT : means the name of a user-supplied subroutine"
               "   *                 implementing the nonlinear system function F(u)"
               "   *                 was not given [-2]"
               "   *"
               "   * KIN_MEM_FAIL : means an error occurred during memory allocation"
               "   *                (either insufficient system resources are available"
               "   *                or the vector kernel has not yet been initialized)"
               "   *                [-4]"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int KINMalloc(void *kinmem, KINSysFn func, N_Vector tmpl);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : KINSol"
               "   * -----------------------------------------------------------------"
               "   * KINSol (main KINSOL driver routine) manages the computational"
               "   * process of computing an approximate solution of the nonlinear"
               "   * system. If the initial guess (initial value assigned to vector u)"
               "   * doesn''t violate any user-defined constraints, then the subroutine"
               "   * attempts to solve the system F(u) = 0 using a nonlinear Krylov"
               "   * subspace projection method. The Newton-Krylov iterations are"
               "   * stopped if either of the following conditions is satisfied:"
               "   *"
               "   *  ||F(u)||_L-infinity <= 0.01*fnormtol"
               "   *"
               "   *  ||u[i+1] - u[i]||_L-infinity <= scsteptol"
               "   *"
               "   * However, if the current iterate satisfies the second stopping"
               "   * criterion, it doesn''t necessarily mean an approximate solution"
               "   * has been found since the algorithm may have stalled, or the"
               "   * user-specified step tolerance (scsteptol) may be too large."
               "   *"
               "   *  kinmem  pointer to an internal memory block allocated during a"
               "   *          prior call to KINCreate"
               "   *"
               "   *  uu  vector set to initial guess by user before calling KINSol,"
               "   *      but which upon return contains an approximate solution of"
               "   *      the nonlinear system F(u) = 0"
               "   *"
               "   *  strategy  global strategy applied to Newton step if unsatisfactory"
               "   *            (KIN_NONE or KIN_LINESEARCH)"
               "   *"
               "   *  u_scale  vector containing diagonal elements of scaling matrix"
               "   *           for vector u chosen so that the components of"
               "   *           u_scale*u (as a matrix multiplication) all have"
               "   *           about the same magnitude when u is close to a root"
               "   *           of F(u)"
               "   *"
               "   *  f_scale  vector containing diagonal elements of scaling matrix"
               "   *           for F(u) chosen so that the components of"
               "   *           f_scale*F(u) (as a matrix multiplication) all have"
               "   *           roughly the same magnitude when u is not too near a"
               "   *           root of F(u)"
               "   *"
               "   * Note: The components of vectors u_scale and f_scale should be"
               "   * positive."
               "   *"
               "   * If successful, KINSol returns a vector uu contains an approximate"
               "   * solution of the given nonlinear system. If an error occurs, then"
               "   * an error message is printed and an error code is returned."
               "   *"
               "   * -----------------------------------------------------------------"
               "   * KINSol Return Values"
               "   * -----------------------------------------------------------------"
               "   *"
               "   * The possible return values for the KINSol subroutine are the"
               "   * following:"
               "   *"
               "   * KIN_SUCCESS : means ||fscale*ABS(func(u))||_L-infinity <= 0.01*fnormtol"
               "   *               and the current iterate uu is probably an approximate"
               "   *               solution of the nonlinear system F(u) = 0 [0]"
               "   *"
               "   * KIN_INITIAL_GUESS_OK : means the initial user-supplied guess"
               "   *                        already satisfies the stopping criterion"
               "   *                        given above [1]"
               "   *"
               "   * KIN_STEP_LT_STPTOL : means the following inequality has been"
               "   *                      satisfied (stopping tolerance on scaled"
               "   *                      step length):"
               "   *"
               "   *                    ||    u_k+1 - u_k    ||"
               "   *                    || ----------------- ||_L-infinity <= scsteptol"
               "   *                    || ABS(u_k+1)+uscale ||"
               "   *"
               "   *                      so the current iterate (denoted above by u_k+1)"
               "   *                      may be an approximate solution of the given"
               "   *                      nonlinear system, but it is also quite possible"
               "   *                      that the algorithm is ""stalled"" (making"
               "   *                      insufficient progress) near an invalid solution,"
               "   *                      or the real scalar scsteptol is too large [2]"
               "   *"
               "   * KIN_LINESEARCH_NONCONV : means the line search algorithm was unable"
               "   *                          to find an iterate sufficiently distinct"
               "   *                          from the current iterate"
               "   *"
               "   *                          failure to satisfy the sufficient decrease"
               "   *                          condition could mean the current iterate is"
               "   *                          ""close"" to an approximate solution of the given"
               "   *                          nonlinear system, the finite-difference"
               "   *                          approximation of the matrix-vector product"
               "   *                          J(u)*v is inaccurate, or the real scalar"
               "   *                          scsteptol is too large [-5]"
               "   *"
               "   * KIN_MAXITER_REACHED : means the maximum number of nonlinear iterations"
               "   *                       has been reached [-6]"
               "   *"
               "   * KIN_MXNEWT_5X_EXCEEDED : means five consecutive steps have been taken"
               "   *                          that satisfy the following inequality:"
               "   *"
               "   *                            ||uscale*p||_L2 > 0.99*mxnewtstep"
               "   *"
               "   *                          where p denotes the current step and"
               "   *                          mxnewtstep is a real scalar upper bound"
               "   *                          on the scaled step length"
               "   *"
               "   *                          such a failure may mean ||fscale*func(u)||_L2"
               "   *                          asymptotes from above to a finite value, or"
               "   *                          the real scalar mxnewtstep is too small [-7]"
               "   *"
               "   * KIN_LINESEARCH_BCFAIL : means the line search algorithm (implemented"
               "   *                         in KINLineSearch) was unable to satisfy the"
               "   *                         beta-condition for MXNBCF + 1 nonlinear"
               "   *                         iterations (not necessarily consecutive),"
               "   *                         which may indicate the algorithm is making"
               "   *                         poor progress [-8]"
               "   *"
               "   * KIN_LINSOLV_NO_RECOVERY : means the user-supplied routine psolve"
               "   *                           encountered a recoverable error, but"
               "   *                           the preconditioner is already current [-9]"
               "   *"
               "   * KIN_LINIT_FAIL : means the linear solver initialization routine (linit)"
               "   *                  encountered an error [-10]"
               "   *"
               "   * KIN_LSETUP_FAIL : means the user-supplied routine pset (used to compute"
               "   *                   the preconditioner) encountered an unrecoverable"
               "   *                   error [-11]"
               "   *"
               "   * KIN_LSOLVE_FAIL : means either the user-supplied routine psolve (used to"
               "   *                   to solve the preconditioned linear system) encountered"
               "   *                   an unrecoverable error, or the linear solver routine"
               "   *                   (lsolve) encountered an error condition [-12]"
               "   *"
               "   * KIN_MEM_NULL : means a NULL KINSOL memory block pointer was given"
               "   *                (must call the KINCreate and KINMalloc memory"
               "   *                allocation subroutines prior to calling KINSol) [-1]"
               "   *"
               "   * KIN_NO_MALLOC : means additional system memory has not yet been"
               "   *                 allocated for vector storage (forgot to call the"
               "   *                 KINMalloc routine) [-3]"
               "   *"
               "   * KIN_ILL_INPUT : means at least one input parameter was invalid"
               "   *                 (check error output) [-2]"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int KINSol(void *kinmem, N_Vector uu, int strategy,"
               "             N_Vector u_scale, N_Vector f_scale);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Optional Output Extraction Functions (KINSOL)"
               "   * -----------------------------------------------------------------"
               "   * The following functions can be called to get optional outputs"
               "   * and statistical information related to the KINSOL solver:"
               "   *"
               "   *       Function Name       |      Returned Value"
               "   *                           |"
               "   * -----------------------------------------------------------------"
               "   *                           |"
               "   * KINGetWorkSpace           | returns both integer workspace size"
               "   *                           | (total number of long int-sized blocks"
               "   *                           | of memory allocated by KINSOL for"
               "   *                           | vector storage) and real workspace"
               "   *                           | size (total number of realtype-sized"
               "   *                           | blocks of memory allocated by KINSOL"
               "   *                           | for vector storage)"
               "   *                           |"
               "   * KINGetNumFuncEvals        | total number evaluations of the"
               "   *                           | nonlinear system function F(u)"
               "   *                           | (number of direct calls made to the"
               "   *                           | user-supplied subroutine by KINSOL"
               "   *                           | module member functions)"
               "   *                           |"
               "   * KINGetNumNonlinSolvIters  | total number of nonlinear iterations"
               "   *                           | performed"
               "   *                           |"
               "   * KINGetNumBetaCondFails    | total number of beta-condition"
               "   *                           | failures (see KINLineSearch)"
               "   *                           |"
               "   *                           | KINSOL halts if the number of such"
               "   *                           | failures exceeds the value of the"
               "   *                           | constant MXNBCF (defined in kinsol.c)"
               "   *                           |"
               "   * KINGetNumBacktrackOps     | total number of backtrack operations"
               "   *                           | (step length adjustments) performed"
               "   *                           | by the line search algorithm (see"
               "   *                           | KINLineSearch)"
               "   *                           |"
               "   * KINGetFuncNorm            | scaled norm of the nonlinear system"
               "   *                           | function F(u) evaluated at the"
               "   *                           | current iterate:"
               "   *                           |"
               "   *                           |  ||fscale*func(u)||_L2"
               "   *                           |"
               "   * KINGetStepLength          | scaled norm (or length) of the step"
               "   *                           | used during the previous iteration:"
               "   *                           |"
               "   *                           |  ||uscale*p||_L2"
               "   *                           |"
               "   * KINGetReturnFlagName      | returns the name of the constant"
               "   *                           | associated with a KINSOL return flag"
               "   *                           |"
               "   * -----------------------------------------------------------------"
               "   *"
               "   * The possible return values for the KINSet* subroutines are the"
               "   * following:"
               "   *"
               "   * KIN_SUCCESS : means the information was successfully retrieved [0]"
               "   * "
               "   * KIN_MEM_NULL : means a NULL KINSOL memory block pointer was given"
               "   *                (must call the KINCreate and KINMalloc memory"
               "   *                allocation subroutines prior to calling KINSol) [-1]"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  int KINGetWorkSpace(void *kinmem, long int *lenrw, long int *leniw);"
               "  int KINGetNumNonlinSolvIters(void *kinmem, long int *nniters);"
               "  int KINGetNumFuncEvals(void *kinmem, long int *nfevals);"
               "  int KINGetNumBetaCondFails(void *kinmem, long int *nbcfails); "
               "  int KINGetNumBacktrackOps(void *kinmem, long int *nbacktr);"
               "  int KINGetFuncNorm(void *kinmem, realtype *fnorm);"
               "  int KINGetStepLength(void *kinmem, realtype *steplength);"
               "  char *KINGetReturnFlagName(int flag);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : KINFree"
               "   * -----------------------------------------------------------------"
               "   * KINFree frees system memory resources reserved for the KINSOL"
               "   * solver module."
               "   *"
               "   *  kinmem  pointer to an internal memory block allocated during"
               "   *          prior calls to KINCreate and KINMalloc"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void KINFree(void **kinmem);"
               ""
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'kinsol_impl.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * Revision: 1.1 $"
               " * Date: 2008-11-17 16:26:32 $"
               " * -----------------------------------------------------------------"
               " * Programmer(s): Allan Taylor, Alan Hindmarsh, Radu Serban, and"
               " *                Aaron Collier @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * KINSOL solver module header file (private version)"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _KINSOL_IMPL_H"
               "#define _KINSOL_IMPL_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include <stdarg.h>"
               ""
               "#include ""kinsol.h"""
               ""
               "  /*"
               "   * ================================================================="
               "   *   M A I N    S O L V E R    M E M O R Y    B L O C K"
               "   * ================================================================="
               "   */"
               ""
               "  /* KINSOL default constants */"
               " "
               "#define PRINTFL_DEFAULT    0"
               "#define MXITER_DEFAULT     200"
               "#define MXNBCF_DEFAULT     10"
               "#define MSBSET_DEFAULT     10"
               "#define MSBSET_SUB_DEFAULT 5"
               ""
               "#define OMEGA_MIN RCONST(0.00001)"
               "#define OMEGA_MAX RCONST(0.9)"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Types : struct KINMemRec and struct *KINMem"
               "   * -----------------------------------------------------------------"
               "   * A variable declaration of type struct *KINMem denotes a"
               "   * pointer to a data structure of type struct KINMemRec. The"
               "   * KINMemRec structure contains numerous fields that must be"
               "   * accessible by KINSOL solver module routines."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef struct KINMemRec {"
               ""
               "    realtype kin_uround;        /* machine epsilon (or unit roundoff error) "
               "                                   (defined in sundials_types.h)                */"
               ""
               "    /* problem specification data */"
               ""
               "    KINSysFn kin_func;           /* nonlinear system function implementation     */"
               "    void *kin_f_data;            /* work space available to func routine         */"
               "    realtype kin_fnormtol;       /* stopping tolerance on L2-norm of function"
               "                                    value                                        */"
               "    realtype kin_scsteptol;      /* scaled step length tolerance                 */"
               "    int kin_globalstrategy;      /* choices are KIN_NONE and KIN_LINESEARCH      */"
               "    int kin_printfl;             /* level of verbosity of output                 */"
               "    long int kin_mxiter;         /* maximum number of nonlinear iterations       */"
               "    long int kin_msbset;         /* maximum number of nonlinear iterations that"
               "                                    may be performed between calls to the"
               "                                    linear solver setup routine (lsetup)         */"
               "    long int kin_msbset_sub;     /* subinterval length for residual monitoring   */"
               "    long int kin_mxnbcf;         /* maximum number of beta condition failures    */"
               "    int kin_etaflag;             /* choices are KIN_ETACONSTANT, KIN_ETACHOICE1"
               "                                    and KIN_ETACHOICE2                           */"
               "    booleantype kin_noMinEps;    /* flag controlling whether or not the value"
               "                                    of eps is bounded below                      */"
               "    booleantype kin_setupNonNull;   /* flag indicating if linear solver setup"
               "                                       routine is non-null and if setup is used  */"
               "    booleantype kin_constraintsSet; /* flag indicating if constraints are being"
               "                                       used                                      */"
               "    booleantype kin_jacCurrent;     /* flag indicating if the Jacobian info. "
               "                                       used by the linear solver is current      */"
               "    booleantype kin_callForcingTerm; /* flag set if using either KIN_ETACHOICE1"
               "                                        or KIN_ETACHOICE2                        */"
               "    booleantype kin_noResMon;         /* flag indicating if the nonlinear"
               "                                         residual monitoring scheme should be"
               "                                         used                                    */"
               "    booleantype kin_retry_nni;        /* flag indicating if nonlinear iteration"
               "                                         should be retried (set by residual"
               "                                         monitoring algorithm)                   */"
               "    booleantype kin_update_fnorm_sub; /* flag indicating if the fnorm associated"
               "                                         with the subinterval needs to be"
               "                                         updated (set by residual monitoring"
               "                                         algorithm)                              */"
               ""
               "    realtype kin_mxnewtstep;     /* maximum allowable scaled step length         */"
               "    realtype kin_sqrt_relfunc;   /* relative error bound for func(u)             */"
               "    realtype kin_stepl;          /* scaled length of current step                */"
               "    realtype kin_stepmul;        /* step scaling factor                          */"
               "    realtype kin_eps;            /* current value of eps                         */"
               "    realtype kin_eta;            /* current value of eta                         */"
               "    realtype kin_eta_gamma;      /* gamma value used in eta calculation"
               "                                    (choice #2)                                  */"
               "    realtype kin_eta_alpha;      /* alpha value used in eta calculation"
               "                                    (choice #2)                                  */"
               "    booleantype kin_noInitSetup; /* flag controlling whether or not the KINSol"
               "                                    routine makes an initial call to the"
               "                                    linear solver setup routine (lsetup)         */"
               "    realtype kin_sthrsh;         /* threshold value for calling the linear   "
               "                                    solver setup routine                         */"
               ""
               "    /* counters */"
               ""
               "    long int kin_nni;            /* number of nonlinear iterations               */"
               "    long int kin_nfe;            /* number of calls made to func routine         */"
               "    long int kin_nnilset;        /* value of nni counter when the linear solver"
               "                                    setup was last called                        */"
               "    long int kin_nnilset_sub;    /* value of nni counter when the linear solver"
               "                                    setup was last called (subinterval)          */"
               "    long int kin_nbcf;           /* number of times the beta-condition could not "
               "                                    be met in KINLineSearch                      */"
               "    long int kin_nbktrk;         /* number of backtracks performed by"
               "                                    KINLineSearch                                */"
               "    long int kin_ncscmx;         /* number of consecutive steps of size"
               "                                    mxnewtstep taken                             */"
               ""
               "    /* vectors */"
               ""
               "    N_Vector kin_uu;          /* solution vector/current iterate (initially"
               "                                 contains initial guess, but holds approximate"
               "                                 solution upon completion if no errors occurred) */"
               "    N_Vector kin_unew;        /* next iterate (unew = uu+pp)                     */"
               "    N_Vector kin_fval;        /* vector containing result of nonlinear system"
               "                                 function evaluated at a given iterate"
               "                                 (fval = func(uu))                               */"
               "    N_Vector kin_uscale;      /* iterate scaling vector                          */"
               "    N_Vector kin_fscale;      /* fval scaling vector                             */"
               "    N_Vector kin_pp;          /* incremental change vector (pp = unew-uu)        */"
               "    N_Vector kin_constraints; /* constraints vector                              */ "
               "    N_Vector kin_vtemp1;      /* scratch vector #1                               */"
               "    N_Vector kin_vtemp2;      /* scratch vector #2                               */"
               ""
               "    /* space requirements for vector storage */ "
               ""
               "    long int kin_lrw1;        /* number of realtype-sized memory blocks needed"
               "                                 for a single N_Vector                           */ "
               "    long int kin_liw1;        /* number of int-sized memory blocks needed for"
               "                                 a single N_Vecotr                               */ "
               "    long int kin_lrw;         /* total number of realtype-sized memory blocks"
               "                                 needed for all KINSOL work vectors              */"
               "    long int kin_liw;         /* total number of int-sized memory blocks needed"
               "                                 for all KINSOL work vectors                     */"
               ""
               "    /* linear solver data */"
               " "
               "    /* function prototypes (pointers) */"
               ""
               "    int (*kin_linit)(struct KINMemRec *kin_mem);"
               ""
               "    int (*kin_lsetup)(struct KINMemRec *kin_mem);"
               ""
               "    int (*kin_lsolve)(struct KINMemRec *kin_mem, N_Vector xx, N_Vector bb, "
               "                      realtype *res_norm );"
               ""
               "    void (*kin_lfree)(struct KINMemRec *kin_mem);"
               ""
               "    booleantype kin_inexact_ls; /* flag set by the linear solver module"
               "                                   (in linit) indicating whether this is an"
               "                                   iterative linear solver (TRUE), or a direct"
               "                                   linear solver (FALSE)                         */"
               ""
               "    void *kin_lmem;         /* pointer to linear solver memory block             */"
               ""
               "    realtype kin_fnorm;     /* value of L2-norm of fscale*fval                   */"
               "    realtype kin_f1norm;    /* f1norm = 0.5*(fnorm)^2                            */"
               "    realtype kin_res_norm;  /* value of L2-norm of residual (set by the linear"
               "                               solver)                                           */"
               "    realtype kin_sfdotJp;   /* value of scaled func(u) vector (fscale*fval)"
               "                               dotted with scaled J(u)*pp vector                 */"
               "    realtype kin_sJpnorm;   /* value of L2-norm of fscale*(J(u)*pp)              */"
               ""
               "    realtype kin_fnorm_sub; /* value of L2-norm of fscale*fval (subinterval)     */"
               "    realtype kin_omega;     /* constant value for real scalar used in test to"
               "                               determine if reduction of norm of nonlinear"
               "                               residual is sufficient. a value of zero indicates"
               "                               that omega should be estimated from omega_min and"
               "                               omega_max.                                         */"
               "    realtype kin_omega_min; /* lower bound on omega                               */"
               "    realtype kin_omega_max; /* upper bound on omega                               */"
               "  "
               "    /*"
               "     * -----------------------------------------------------------------"
               "     * Note: The KINLineSearch subroutine scales the values of the"
               "     * variables sfdotJp and sJpnorm by a factor rl (lambda) that is"
               "     * chosen by the line search algorithm such that the sclaed Newton"
               "     * step satisfies the following conditions:"
               "     *"
               "     *  F(u_k+1) <= F(u_k) + alpha*(F(u_k)^T * J(u_k))*p*rl"
               "     *"
               "     *  F(u_k+1) >= F(u_k) + beta*(F(u_k)^T * J(u_k))*p*rl"
               "     *"
               "     * where alpha = 1.0e-4, beta = 0.9, u_k+1 = u_k + rl*p,"
               "     * 0 < rl <= 1, J denotes the system Jacobian, and F represents"
               "     * the nonliner system function."
               "     * -----------------------------------------------------------------"
               "     */"
               ""
               "    booleantype kin_MallocDone; /* flag indicating if KINMalloc has been"
               "                                   called yet                                    */"
               ""
               "    /* message files */"
               "    /*-------------------------------------------"
               "      Error handler function and error ouput file "
               "      -------------------------------------------*/"
               ""
               "    KINErrHandlerFn kin_ehfun;   /* Error messages are handled by ehfun          */"
               "    void *kin_eh_data;           /* user pointer passed to ehfun                 */"
               "    FILE *kin_errfp;             /* KINSOL error messages are sent to errfp      */"
               ""
               "    KINInfoHandlerFn kin_ihfun;  /* Info messages are handled by ihfun           */"
               "    void *kin_ih_data;           /* user pointer passed to ihfun                 */"
               "    FILE *kin_infofp;            /* where KINSol info messages are sent          */"
               ""
               "  } *KINMem;"
               ""
               "  /*"
               "   * ================================================================="
               "   *   I N T E R F A C E   T O   L I N E A R   S O L V E R"
               "   * ================================================================="
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : int (*kin_linit)(KINMem kin_mem)"
               "   * -----------------------------------------------------------------"
               "   * kin_linit initializes solver-specific data structures (including"
               "   * variables used as counters or for storing statistical information),"
               "   * but system memory allocation should be done by the subroutine"
               "   * that actually initializes the environment for liner solver"
               "   * package. If the linear system is to be preconditioned, then the"
               "   * variable setupNonNull (type booleantype) should be set to TRUE"
               "   * (predefined constant) and the kin_lsetup routine should be"
               "   * appropriately defined."
               "   *"
               "   *  kinmem  pointer to an internal memory block allocated during"
               "   *          prior calls to KINCreate and KINMalloc"
               "   *"
               "   * If the necessary variables have been successfully initialized,"
               "   * then the kin_linit function should return 0 (zero). Otherwise,"
               "   * the subroutine should indicate a failure has occurred by"
               "   * returning a non-zero integer value."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : int (*kin_lsetup)(KINMem kin_mem)"
               "   * -----------------------------------------------------------------"
               "   * kin_lsetup interfaces with the user-supplied pset subroutine (the"
               "   * preconditioner setup routine), and updates relevant variable"
               "   * values (see KINSpgmrSetup/KINSpbcgSetup). Simply stated, the"
               "   * kin_lsetup routine prepares the linear solver for a subsequent"
               "   * call to the user-supplied kin_lsolve function."
               "   *"
               "   *  kinmem  pointer to an internal memory block allocated during"
               "   *          prior calls to KINCreate and KINMalloc"
               "   *"
               "   * If successful, the kin_lsetup routine should return 0 (zero)."
               "   * Otherwise it should return a non-zero value."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : int (*kin_lsolve)(KINMem kin_mem, N_Vector xx,"
               "   *                              N_Vector bb, realtype *res_norm)"
               "   * -----------------------------------------------------------------"
               "   * kin_lsolve interfaces with the subroutine implementing the"
               "   * numerical method to be used to solve the linear system J*xx = bb,"
               "   * and must increment the relevant counter variable values in"
               "   * addition to computing certain values used by the global strategy"
               "   * and forcing term routines (see KINInexactNewton, KINLineSearch,"
               "   * KINForcingTerm, and KINSpgmrSolve/KINSpbcgSolve)."
               "   *"
               "   *  kinmem  pointer to an internal memory block allocated during"
               "   *          prior calls to KINCreate and KINMalloc"
               "   *"
               "   *  xx  vector (type N_Vector) set to initial guess by kin_lsolve"
               "   *      routine prior to calling the linear solver, but which upon"
               "   *      return contains an approximate solution of the linear"
               "   *      system J*xx = bb, where J denotes the system Jacobian"
               "   *"
               "   *  bb  vector (type N_Vector) set to -func(u) (negative of the"
               "   *      value of the system function evaluated at the current"
               "   *      iterate) by KINLinSolDrv before kin_lsolve is called"
               "   *"
               "   *  res_norm  holds the value of the L2-norm (Euclidean norm) of"
               "   *            the residual vector upon return"
               "   *"
               "   * If successful, the kin_lsolve routine should return 0 (zero)."
               "   * Otherwise it should return a positive value if a re-evaluation"
               "   * of the lsetup function could recover, or a negative value if"
               "   * no such recovery is possible."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : void (*kin_lfree)(KINMem kin_mem)"
               "   * -----------------------------------------------------------------"
               "   * kin_lfree is called by KINFree and should free (deallocate) all"
               "   * system memory resources allocated for the linear solver module"
               "   * (see KINSpgmrFree/KINSpbcgFree)."
               "   *"
               "   *  kinmem  pointer to an internal memory block allocated during"
               "   *          prior calls to KINCreate and KINMalloc"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  /*"
               "   * ================================================================="
               "   *   K I N S O L    I N T E R N A L   F U N C T I O N S"
               "   * ================================================================="
               "   */"
               ""
               ""
               "  /* High level error handler */"
               ""
               "  void KINProcessError(KINMem kin_mem, "
               "                       int error_code, const char *module, const char *fname, "
               "                       const char *msgfmt, ...);"
               ""
               "  /* Prototype of internal errHandler function */"
               ""
               "  void KINErrHandler(int error_code, const char *module, const char *function, "
               "                     char *msg, void *eh_data);"
               ""
               ""
               "  /* High level info handler */"
               ""
               "  void KINPrintInfo(KINMem kin_mem, "
               "                    int info_code, const char *module, const char *fname, "
               "                    const char *msgfmt, ...);"
               ""
               "  /* Prototype of internal infoHandler function */"
               ""
               "  void KINInfoHandler(const char *module, const char *function, "
               "                      char *msg, void *ih_data);"
               ""
               "  /*"
               "   * ================================================================="
               "   *   K I N S O L    E R R O R    M E S S A G E S"
               "   * ================================================================="
               "   */"
               ""
               "#define MSG_MEM_FAIL           ""A memory request failed."""
               "#define MSG_NO_MEM             ""kinsol_mem = NULL illegal."""
               "#define MSG_BAD_NVECTOR        ""A required vector operation is not implemented."""
               "#define MSG_FUNC_NULL          ""func = NULL illegal."""
               "#define MSG_NO_MALLOC          ""Attempt to call before KINMalloc illegal."""
               ""
               "#define MSG_BAD_PRINTFL        ""Illegal value for printfl."""
               "#define MSG_BAD_MXITER         ""Illegal value for mxiter."""
               "#define MSG_BAD_MSBSET         ""Illegal msbset < 0."""
               "#define MSG_BAD_MSBSETSUB      ""Illegal msbsetsub < 0."""
               "#define MSG_BAD_ETACHOICE      ""Illegal value for etachoice."""
               "#define MSG_BAD_ETACONST       ""eta out of range."""
               "#define MSG_BAD_GAMMA          ""gamma out of range."""
               "#define MSG_BAD_ALPHA          ""alpha out of range."""
               "#define MSG_BAD_MXNEWTSTEP     ""Illegal mxnewtstep < 0."""
               "#define MSG_BAD_RELFUNC        ""relfunc < 0 illegal."""
               "#define MSG_BAD_FNORMTOL       ""fnormtol < 0 illegal."""
               "#define MSG_BAD_SCSTEPTOL      ""scsteptol < 0 illegal."""
               "#define MSG_BAD_MXNBCF         ""mxbcf < 0 illegal."""
               "#define MSG_BAD_CONSTRAINTS    ""Illegal values in constraints vector."""
               "#define MSG_BAD_OMEGA          ""scalars < 0 illegal."""
               ""
               "#define MSG_LSOLV_NO_MEM       ""The linear solver memory pointer is NULL."""
               "#define MSG_UU_NULL            ""uu = NULL illegal."""
               "#define MSG_BAD_GLSTRAT        ""Illegal value for global strategy."""
               "#define MSG_BAD_USCALE         ""uscale = NULL illegal."""
               "#define MSG_USCALE_NONPOSITIVE ""uscale has nonpositive elements."""
               "#define MSG_BAD_FSCALE         ""fscale = NULL illegal."""
               "#define MSG_FSCALE_NONPOSITIVE ""fscale has nonpositive elements."""
               "#define MSG_INITIAL_CNSTRNT    ""Initial guess does NOT meet constraints."""
               "#define MSG_LINIT_FAIL         ""The linear solver''s init routine failed."""
               ""
               "#define MSG_SYSFUNC_FAILED      ""The system function failed in an unrecoverable manner."""
               "#define MSG_SYSFUNC_FIRST       ""The system function failed at the first call."""
               "#define MSG_LSETUP_FAILED       ""The linear solver''s setup function failed in an unrecoverable manner."""
               "#define MSG_LSOLVE_FAILED       ""The linear solver''s solve function failed in an unrecoverable manner."""
               "#define MSG_LINSOLV_NO_RECOVERY ""The linear solver''s solve function failed recoverably, but the Jacobian data is already current."""
               "#define MSG_LINESEARCH_NONCONV  ""The line search algorithm was unable to find an iterate sufficiently distinct from the current iterate."""
               "#define MSG_LINESEARCH_BCFAIL   ""The line search algorithm was unable to satisfy the beta-condition for nbcfails iterations."""
               "#define MSG_MAXITER_REACHED     ""The maximum number of iterations was reached before convergence."""
               "#define MSG_MXNEWT_5X_EXCEEDED  ""Five consecutive steps have been taken that satisfy a scaled step length test."""
               "#define MSG_SYSFUNC_REPTD       ""Unable to correct repeated recoverable system function errors."""
               ""
               "  /*"
               "   * ================================================================="
               "   *   K I N S O L    I N F O    M E S S A G E S"
               "   * ================================================================="
               "   */"
               ""
               "#define INFO_RETVAL    ""Return value: %d"""
               "#define INFO_ADJ       ""no. of lambda adjustments = %ld"""
               ""
               "#if defined(SUNDIALS_EXTENDED_PRECISION)"
               ""
               "#define INFO_NNI       ""nni = %4ld   nfe = %6ld   fnorm = %26.16Lg"""
               "#define INFO_TOL       ""scsteptol = %12.3Lg  fnormtol = %12.3Lg"""
               "#define INFO_FMAX      ""scaled f norm (for stopping) = %12.3Lg"""
               "#define INFO_PNORM     ""pnorm = %12.4Le"""
               "#define INFO_PNORM1    ""(ivio=1) pnorm = %12.4Le"""
               "#define INFO_FNORM     ""fnorm(L2) = %20.8Le"""
               "#define INFO_LAM       ""min_lam = %11.4Le   f1norm = %11.4Le   pnorm = %11.4Le"""
               "#define INFO_ALPHA     ""fnorm = %15.8Le   f1norm = %15.8Le   alpha_cond = %15.8Le  lam = %15.8Le"""
               "#define INFO_BETA      ""f1norm = %15.8Le   beta_cond = %15.8Le   lam = %15.8Le"""
               "#define INFO_ALPHABETA ""f1norm = %15.8Le  alpha_cond = %15.8Le  beta_cond = %15.8Le  lam = %15.8Le"""
               ""
               "#elif defined(SUNDIALS_DOUBLE_PRECISION)"
               ""
               "#define INFO_NNI       ""nni = %4ld   nfe = %6ld   fnorm = %26.16lg"""
               "#define INFO_TOL       ""scsteptol = %12.3lg  fnormtol = %12.3lg"""
               "#define INFO_FMAX      ""scaled f norm (for stopping) = %12.3lg"""
               "#define INFO_PNORM     ""pnorm = %12.4le"""
               "#define INFO_PNORM1    ""(ivio=1) pnorm = %12.4le"""
               "#define INFO_FNORM     ""fnorm(L2) = %20.8le"""
               "#define INFO_LAM       ""min_lam = %11.4le   f1norm = %11.4le   pnorm = %11.4le"""
               "#define INFO_ALPHA     ""fnorm = %15.8le   f1norm = %15.8le   alpha_cond = %15.8le  lam = %15.8le"""
               "#define INFO_BETA      ""f1norm = %15.8le   beta_cond = %15.8le   lam = %15.8le"""
               "#define INFO_ALPHABETA ""f1norm = %15.8le  alpha_cond = %15.8le  beta_cond = %15.8le  lam = %15.8le"""
               ""
               "#else"
               ""
               "#define INFO_NNI       ""nni = %4ld   nfe = %6ld   fnorm = %26.16g"""
               "#define INFO_TOL       ""scsteptol = %12.3g  fnormtol = %12.3g"""
               "#define INFO_FMAX      ""scaled f norm (for stopping) = %12.3g"""
               "#define INFO_PNORM     ""pnorm = %12.4e"""
               "#define INFO_PNORM1    ""(ivio=1) pnorm = %12.4e"""
               "#define INFO_FNORM     ""fnorm(L2) = %20.8e"""
               "#define INFO_LAM       ""min_lam = %11.4e   f1norm = %11.4e   pnorm = %11.4e"""
               "#define INFO_ALPHA     ""fnorm = %15.8e   f1norm = %15.8e   alpha_cond = %15.8e  lam = %15.8e"""
               "#define INFO_BETA      ""f1norm = %15.8e   beta_cond = %15.8e   lam = %15.8e"""
               "#define INFO_ALPHABETA ""f1norm = %15.8e  alpha_cond = %15.8e  beta_cond = %15.8e  lam = %15.8e"""
               ""
               "#endif"
               ""
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'nvector_serial.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * ----------------------------------------------------------------- "
               " * Programmer(s): Scott D. Cohen, Alan C. Hindmarsh, Radu Serban,"
               " *                and Aaron Collier @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * This is the header file for the serial implementation of the"
               " * NVECTOR module."
               " *"
               " * Part I contains declarations specific to the serial"
               " * implementation of the supplied NVECTOR module."
               " *"
               " * Part II defines accessor macros that allow the user to"
               " * efficiently use the type N_Vector without making explicit"
               " * references to the underlying data structure."
               " *"
               " * Part III contains the prototype for the constructor N_VNew_Serial"
               " * as well as implementation-specific prototypes for various useful"
               " * vector operations."
               " *"
               " * Notes:"
               " *"
               " *   - The definition of the generic N_Vector structure can be found"
               " *     in the header file sundials_nvector.h."
               " *"
               " *   - The definition of the type ''realtype'' can be found in the"
               " *     header file sundials_types.h, and it may be changed (at the "
               " *     configuration stage) according to the user''s needs. "
               " *     The sundials_types.h file also contains the definition"
               " *     for the type ''booleantype''."
               " *"
               " *   - N_Vector arguments to arithmetic vector operations need not"
               " *     be distinct. For example, the following call:"
               " *"
               " *       N_VLinearSum_Serial(a,x,b,y,y);"
               " *"
               " *     (which stores the result of the operation a*x+b*y in y)"
               " *     is legal."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _NVECTOR_SERIAL_H"
               "#define _NVECTOR_SERIAL_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include ""sundials_nvector.h"""
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * PART I: SERIAL implementation of N_Vector"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "/* serial implementation of the N_Vector ''content'' structure"
               "   contains the length of the vector, a pointer to an array"
               "   of ''realtype'' components, and a flag indicating ownership of"
               "   the data */"
               ""
               "struct _N_VectorContent_Serial {"
               "  long int length;"
               "  booleantype own_data;"
               "  realtype *data;"
               "};"
               ""
               "typedef struct _N_VectorContent_Serial *N_VectorContent_Serial;"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * PART II: macros NV_CONTENT_S, NV_DATA_S, NV_OWN_DATA_S,"
               " *          NV_LENGTH_S, and NV_Ith_S"
               " * -----------------------------------------------------------------"
               " * In the descriptions below, the following user declarations"
               " * are assumed:"
               " *"
               " * N_Vector v;"
               " * long int i;"
               " *"
               " * (1) NV_CONTENT_S"
               " *"
               " *     This routines gives access to the contents of the serial"
               " *     vector N_Vector."
               " *"
               " *     The assignment v_cont = NV_CONTENT_S(v) sets v_cont to be"
               " *     a pointer to the serial N_Vector content structure."
               " *"
               " * (2) NV_DATA_S NV_OWN_DATA_S and NV_LENGTH_S"
               " *"
               " *     These routines give access to the individual parts of"
               " *     the content structure of a serial N_Vector."
               " *"
               " *     The assignment v_data = NV_DATA_S(v) sets v_data to be"
               " *     a pointer to the first component of v. The assignment"
               " *     NV_DATA_S(v) = data_V sets the component array of v to"
               " *     be data_v by storing the pointer data_v."
               " *"
               " *     The assignment v_len = NV_LENGTH_S(v) sets v_len to be"
               " *     the length of v. The call NV_LENGTH_S(v) = len_v sets"
               " *     the length of v to be len_v."
               " *"
               " * (3) NV_Ith_S"
               " *"
               " *     In the following description, the components of an"
               " *     N_Vector are numbered 0..n-1, where n is the length of v."
               " *"
               " *     The assignment r = NV_Ith_S(v,i) sets r to be the value of"
               " *     the ith component of v. The assignment NV_Ith_S(v,i) = r"
               " *     sets the value of the ith component of v to be r."
               " *"
               " * Note: When looping over the components of an N_Vector v, it is"
               " * more efficient to first obtain the component array via"
               " * v_data = NV_DATA_S(v) and then access v_data[i] within the"
               " * loop than it is to use NV_Ith_S(v,i) within the loop."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#define NV_CONTENT_S(v)  ( (N_VectorContent_Serial)(v->content) )"
               ""
               "#define NV_LENGTH_S(v)   ( NV_CONTENT_S(v)->length )"
               ""
               "#define NV_OWN_DATA_S(v) ( NV_CONTENT_S(v)->own_data )"
               ""
               "#define NV_DATA_S(v)     ( NV_CONTENT_S(v)->data )"
               ""
               "#define NV_Ith_S(v,i)    ( NV_DATA_S(v)[i] )"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * PART III: functions exported by nvector_serial"
               " * "
               " * CONSTRUCTORS:"
               " *    N_VNew_Serial"
               " *    N_VNewEmpty_Serial"
               " *    N_VMake_Serial"
               " *    N_VCloneVectorArray_Serial"
               " *    N_VCloneVectorArrayEmpty_Serial"
               " * DESTRUCTORS:"
               " *    N_VDestroy_Serial"
               " *    N_VDestroyVectorArray_Serial"
               " * OTHER:"
               " *    N_VPrint_Serial"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : N_VNew_Serial"
               " * -----------------------------------------------------------------"
               " * This function creates and allocates memory for a serial vector."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "N_Vector N_VNew_Serial(long int vec_length);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : N_VNewEmpty_Serial"
               " * -----------------------------------------------------------------"
               " * This function creates a new serial N_Vector with an empty (NULL)"
               " * data array."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "N_Vector N_VNewEmpty_Serial(long int vec_length);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : N_VMake_Serial"
               " * -----------------------------------------------------------------"
               " * This function creates and allocates memory for a serial vector"
               " * with a user-supplied data array."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "N_Vector N_VMake_Serial(long int vec_length, realtype *v_data);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : N_VCloneVectorArray_Serial"
               " * -----------------------------------------------------------------"
               " * This function creates an array of ''count'' SERIAL vectors by"
               " * cloning a given vector w."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "N_Vector *N_VCloneVectorArray_Serial(int count, N_Vector w);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : N_VCloneVectorArrayEmpty_Serial"
               " * -----------------------------------------------------------------"
               " * This function creates an array of ''count'' SERIAL vectors each"
               " * with an empty (NULL) data array by cloning w."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "N_Vector *N_VCloneVectorArrayEmpty_Serial(int count, N_Vector w);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : N_VDestroyVectorArray_Serial"
               " * -----------------------------------------------------------------"
               " * This function frees an array of SERIAL vectors created with "
               " * N_VCloneVectorArray_Serial or N_VCloneVectorArrayEmpty_Serial."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "void N_VDestroyVectorArray_Serial(N_Vector *vs, int count);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : N_VPrint_Serial"
               " * -----------------------------------------------------------------"
               " * This function prints the content of a serial vector to stdout."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "void N_VPrint_Serial(N_Vector v);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * serial implementations of various useful vector operations"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "N_Vector N_VCloneEmpty_Serial(N_Vector w);"
               "N_Vector N_VClone_Serial(N_Vector w);"
               "void N_VDestroy_Serial(N_Vector v);"
               "void N_VSpace_Serial(N_Vector v, long int *lrw, long int *liw);"
               "realtype *N_VGetArrayPointer_Serial(N_Vector v);"
               "void N_VSetArrayPointer_Serial(realtype *v_data, N_Vector v);"
               "void N_VLinearSum_Serial(realtype a, N_Vector x, realtype b, N_Vector y, N_Vector z);"
               "void N_VConst_Serial(realtype c, N_Vector z);"
               "void N_VProd_Serial(N_Vector x, N_Vector y, N_Vector z);"
               "void N_VDiv_Serial(N_Vector x, N_Vector y, N_Vector z);"
               "void N_VScale_Serial(realtype c, N_Vector x, N_Vector z);"
               "void N_VAbs_Serial(N_Vector x, N_Vector z);"
               "void N_VInv_Serial(N_Vector x, N_Vector z);"
               "void N_VAddConst_Serial(N_Vector x, realtype b, N_Vector z);"
               "realtype N_VDotProd_Serial(N_Vector x, N_Vector y);"
               "realtype N_VMaxNorm_Serial(N_Vector x);"
               "realtype N_VWrmsNorm_Serial(N_Vector x, N_Vector w);"
               "realtype N_VWrmsNormMask_Serial(N_Vector x, N_Vector w, N_Vector id);"
               "realtype N_VMin_Serial(N_Vector x);"
               "realtype N_VWL2Norm_Serial(N_Vector x, N_Vector w);"
               "realtype N_VL1Norm_Serial(N_Vector x);"
               "void N_VCompare_Serial(realtype c, N_Vector x, N_Vector z);"
               "booleantype N_VInvTest_Serial(N_Vector x, N_Vector z);"
               "booleantype N_VConstrMask_Serial(N_Vector c, N_Vector x, N_Vector m);"
               "realtype N_VMinQuotient_Serial(N_Vector num, N_Vector denom);"
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'sundials_config.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2005, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see sundials/shared/LICENSE."
               " * -----------------------------------------------------------------"
               " * Sample SUNDIALS configuration header file"
               " * -----------------------------------------------------------------"
               " */"
               " "
               "/* ------------------------------  "
               " * Define SUNDIALS version number"
               " * ------------------------------ */"
               ""
               "#define SUNDIALS_PACKAGE_VERSION ""2.2.0"""
               " "
               "/* ------------------------------------------------- "
               " * Define precision of SUNDIALS data type ''realtype''"
               " * ------------------------------------------------- */"
               ""
               "/* Define SUNDIALS data type ''realtype'' as ''double'' */"
               "#define SUNDIALS_DOUBLE_PRECISION 1"
               ""
               "/* Define SUNDIALS data type ''realtype'' as ''float'' */"
               "/* #define SUNDIALS_SINGLE_PRECISION 1 */"
               ""
               "/* Define SUNDIALS data type ''realtype'' as ''long double'' */"
               "/* #define SUNDIALS_EXTENDED_PRECISION 1 */"
               ""
               "/* --------------------------"
               " * Use generic math functions"
               " * -------------------------- */"
               ""
               "#define SUNDIALS_USE_GENERIC_MATH 1"
               "  "
               "/* -----------------------------------------"
               " * FCMIX: Define Fortran name-mangling macro"
               " * ----------------------------------------- */"
               ""
               "#define F77_FUNC(name,NAME) name ## _"
               "#define F77_FUNC_(name,NAME) name ## _"
               ""
               "/* ------------------------------------"
               " * FCMIX: Define case of function names"
               " * ------------------------------------ */"
               " "
               "/* FCMIX: Make function names lowercase */"
               "/* #define SUNDIALS_CASE_LOWER 1 */"
               ""
               "/* FCMIX: Make function names uppercase */"
               "/* #define SUNDIALS_CASE_UPPER 1 */"
               ""
               "/* ---------------------------------------------------------------"
               " * FCMIX: Define number of underscores to append to function names"
               " * --------------------------------------------------------------- */"
               ""
               "/* FCMIX: Do NOT append any underscores to functions names */"
               "/* #define SUNDIALS_UNDERSCORE_NONE 1 */"
               ""
               "/* FCMIX: Append ONE underscore to function names */"
               "/* #define SUNDIALS_UNDERSCORE_ONE 1 */"
               ""
               "/* FCMIX: Append TWO underscores to function names */"
               "/* #define SUNDIALS_UNDERSCORE_TWO 1 */"
               " "
               "/* ----------------------------------------------------------"
               " * FNVECTOR: Allow user to specify different MPI communicator"
               " * ---------------------------------------------------------- */"
               ""
               "#define SUNDIALS_MPI_COMM_F2C 1"]

      case 'sundials_dense.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * -----------------------------------------------------------------"
               " * Programmer: Radu Serban @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2006, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * This is the header file for a generic package of DENSE matrix"
               " * operations.  The routines listed in this file all use type"
               " * DenseMat, defined below, for M by N matrices."
               " * These routines in turn call routines in the smalldense module,"
               " * which use the type realtype** for matrices. This separation allows"
               " * for possible modifications in which matrices of type DenseMat"
               " * may not be stored contiguously, while small matrices can still"
               " * be treated with the routines in smalldense."
               " *"
               " * Routines that work with the type DenseMat begin with ""Dense""."
               " * The DenseAllocMat function allocates a dense matrix for use in"
               " * the other DenseMat routines listed in this file. Matrix"
               " * storage details are given in the documentation for the type"
               " * DenseMat. The DenseAllocPiv function allocates memory for"
               " * pivot information. The storage allocated by DenseAllocMat and"
               " * DenseAllocPiv is deallocated by the routines DenseFreeMat and"
               " * DenseFreePiv, respectively. The DenseGETRF and DenseGETRS"
               " * routines perform the actual solution of a dense linear system."
               " *"
               " * Routines that work with realtype** begin with ""den"". "
               " * The underlying matrix storage is described in the documentation "
               " * for denalloc in smalldense.h"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _DENSE_H"
               "#define _DENSE_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include ""sundials_types.h"""
               "#include ""sundials_smalldense.h"""
               ""
               "  /*"
               "   * =================================================================="
               "   * Type definitions"
               "   * =================================================================="
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Type : DenseMat"
               "   * -----------------------------------------------------------------"
               "   * The type DenseMat is defined to be a pointer to a structure"
               "   * with sizes (M and N) and a data field. The M and N fields "
               "   * indicates the number of rows and columns, respectively of a dense "
               "   * matrix, while the data field is a two dimensional array used for "
               "   * component storage. The elements of a dense matrix are stored "
               "   * columnwise (i.e columns are stored one on top of the other in "
               "   * memory). If A is of type DenseMat, then the (i,j)th element "
               "   * of A (with 0 <= i < M and 0 <= j < N) is given by the expression "
               "   * (A->data)[j][i] or by the expression (A->data)[0][j*n+i]. "
               "   * The macros below allow a user to access efficiently individual"
               "   * matrix elements without writing out explicit data structure"
               "   * references and without knowing too much about the underlying"
               "   * element storage. The only storage assumption needed is that"
               "   * elements are stored columnwise and that a pointer to the jth"
               "   * column of elements can be obtained via the DENSE_COL macro."
               "   * Users should use these macros whenever possible."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  typedef struct _DenseMat {"
               "    long int M;"
               "    long int N;"
               "    realtype **data;"
               "  } *DenseMat;"
               ""
               "  /*"
               "   * =================================================================="
               "   * Data accessor macros"
               "   * =================================================================="
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Macro : DENSE_ELEM"
               "   * -----------------------------------------------------------------"
               "   * Usage : DENSE_ELEM(A,i,j) = a_ij;  OR"
               "   *         a_ij = DENSE_ELEM(A,i,j);"
               "   * -----------------------------------------------------------------"
               "   * DENSE_ELEM(A,i,j) references the (i,j)th element of the M by N"
               "   * DenseMat A, 0 <= i < M ; 0 <= j < N."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "#define DENSE_ELEM(A,i,j) ((A->data)[j][i])"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Macro : DENSE_COL"
               "   * -----------------------------------------------------------------"
               "   * Usage : col_j = DENSE_COL(A,j);"
               "   * -----------------------------------------------------------------"
               "   * DENSE_COL(A,j) references the jth column of the M by N"
               "   * DenseMat A, 0 <= j < N. The type of the expression DENSE_COL(A,j) "
               "   * is (realtype *). After the assignment in the usage above, col_j "
               "   * may be treated as an array indexed from 0 to M-1. "
               "   * The (i,j)-th element of A is thus referenced by col_j[i]."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "#define DENSE_COL(A,j) ((A->data)[j])"
               ""
               "  /*"
               "   * =================================================================="
               "   * Function prototypes"
               "   * =================================================================="
               "   */"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : DenseAllocMat"
               "   * -----------------------------------------------------------------"
               "   * Usage : A = DenseAllocMat(M, N);"
               "   *         if (A == NULL) ... memory request failed"
               "   * -----------------------------------------------------------------"
               "   * DenseAllocMat allocates memory for an M by N dense matrix and"
               "   * returns the storage allocated (type DenseMat). DenseAllocMat"
               "   * returns NULL if the request for matrix storage cannot be"
               "   * satisfied. See the above documentation for the type DenseMat"
               "   * for matrix storage details."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  DenseMat DenseAllocMat(long int M, long int N);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : DenseAllocPiv"
               "   * -----------------------------------------------------------------"
               "   * Usage : p = DenseAllocPiv(N);"
               "   *         if (p == NULL) ... memory request failed"
               "   * -----------------------------------------------------------------"
               "   * DenseAllocPiv allocates memory for pivot information to be"
               "   * filled in by the DenseGETRF routine during the factorization"
               "   * of an N by N dense matrix. The underlying type for pivot"
               "   * information is an array of N integers and this routine returns"
               "   * the pointer to the memory it allocates. If the request for"
               "   * pivot storage cannot be satisfied, DenseAllocPiv returns NULL."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  long int *DenseAllocPiv(long int N);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : DenseGETRF"
               "   * -----------------------------------------------------------------"
               "   * Usage : ier = DenseGETRF(A, p);"
               "   *         if (ier != 0) ... A is singular"
               "   * -----------------------------------------------------------------"
               "   * DenseGETRF performs the LU factorization of the M by N dense"
               "   * matrix A. This is done using standard Gaussian elimination"
               "   * with partial (row) pivoting. Note that this applies only"
               "   * to matrices with M >= N and full column rank."
               "   *"
               "   * A successful LU factorization leaves the matrix A and the"
               "   * pivot array p with the following information:"
               "   *"
               "   * (1) p[k] contains the row number of the pivot element chosen"
               "   *     at the beginning of elimination step k, k=0, 1, ..., N-1."
               "   *"
               "   * (2) If the unique LU factorization of A is given by PA = LU,"
               "   *     where P is a permutation matrix, L is a lower trapezoidal"
               "   *     matrix with all 1''s on the diagonal, and U is an upper"
               "   *     triangular matrix, then the upper triangular part of A"
               "   *     (including its diagonal) contains U and the strictly lower"
               "   *     trapezoidal part of A contains the multipliers, I-L."
               "   *"
               "   * For square matrices (M=N), L is unit lower triangular."
               "   *"
               "   * DenseGETRF returns 0 if successful. Otherwise it encountered"
               "   * a zero diagonal element during the factorization. In this case"
               "   * it returns the column index (numbered from one) at which"
               "   * it encountered the zero."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  long int DenseGETRF(DenseMat A, long int *p);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : DenseGETRS"
               "   * -----------------------------------------------------------------"
               "   * Usage : DenseGETRS(A, p, b);"
               "   * -----------------------------------------------------------------"
               "   * DenseGETRS solves the N-dimensional system A x = b using"
               "   * the LU factorization in A and the pivot information in p"
               "   * computed in DenseGETRF. The solution x is returned in b. This"
               "   * routine cannot fail if the corresponding call to DenseGETRF"
               "   * did not fail."
               "   * DenseGETRS does NOT check for a square matrix!"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void DenseGETRS(DenseMat A, long int *p, realtype *b);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : DenseZero"
               "   * -----------------------------------------------------------------"
               "   * Usage : DenseZero(A);"
               "   * -----------------------------------------------------------------"
               "   * DenseZero sets all the elements of the M by N matrix A to 0.0."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void DenseZero(DenseMat A);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : DenseCopy"
               "   * -----------------------------------------------------------------"
               "   * Usage : DenseCopy(A, B);"
               "   * -----------------------------------------------------------------"
               "   * DenseCopy copies the contents of the M by N matrix A into the"
               "   * M by N matrix B."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void DenseCopy(DenseMat A, DenseMat B);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function: DenseScale"
               "   * -----------------------------------------------------------------"
               "   * Usage : DenseScale(c, A);"
               "   * -----------------------------------------------------------------"
               "   * DenseScale scales the elements of the M by N matrix A by the"
               "   * constant c and stores the result back in A."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void DenseScale(realtype c, DenseMat A);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : DenseAddI"
               "   * -----------------------------------------------------------------"
               "   * Usage : DenseAddI(A);"
               "   * -----------------------------------------------------------------"
               "   * DenseAddI adds 1.0 to the main diagonal (A_ii, i=1,2,...,N-1) of"
               "   * the M by N matrix A (M >= N) and stores the result back in A."
               "   * DenseAddI is typically used with square matrices."
               "   * DenseAddI does not check for M >= N and therefore a segmentation"
               "   * fault will occur if M < N!"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void DenseAddI(DenseMat A);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : DenseFreeMat"
               "   * -----------------------------------------------------------------"
               "   * Usage : DenseFreeMat(A);"
               "   * -----------------------------------------------------------------"
               "   * DenseFreeMat frees the memory allocated by DenseAllocMat for"
               "   * the M by N matrix A."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void DenseFreeMat(DenseMat A);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : DenseFreePiv"
               "   * -----------------------------------------------------------------"
               "   * Usage : DenseFreePiv(p);"
               "   * -----------------------------------------------------------------"
               "   * DenseFreePiv frees the memory allocated by DenseAllocPiv for"
               "   * the pivot information array p."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void DenseFreePiv(long int *p);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : DensePrint"
               "   * -----------------------------------------------------------------"
               "   * Usage : DensePrint(A);"
               "   * -----------------------------------------------------------------"
               "   * This routine prints the M by N dense matrix A to standard output"
               "   * as it would normally appear on paper. It is intended as a "
               "   * debugging tool with small values of M and N. The elements are"
               "   * printed using the %g/%lg/%Lg option. A blank line is printed"
               "   * before and after the matrix."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void DensePrint(DenseMat A);"
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'sundials_math.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * -----------------------------------------------------------------"
               " * Programmer(s): Scott D. Cohen, Alan C. Hindmarsh and"
               " *                Aaron Collier @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * This is the header file for a simple C-language math library. The"
               " * routines listed here work with the type realtype as defined in"
               " * the header file sundials_types.h."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _SUNDIALSMATH_H"
               "#define _SUNDIALSMATH_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include ""sundials_types.h"""
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Macros : MIN and MAX"
               " * -----------------------------------------------------------------"
               " * MIN(A,B) returns the minimum of A and B"
               " *"
               " * MAX(A,B) returns the maximum of A and B"
               " *"
               " * SQR(A) returns A^2"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef MIN"
               "#define MIN(A, B) ((A) < (B) ? (A) : (B))"
               "#endif"
               ""
               "#ifndef MAX"
               "#define MAX(A, B) ((A) > (B) ? (A) : (B))"
               "#endif"
               ""
               "#ifndef SQR"
               "#define SQR(A) ((A)*(A))"
               "#endif"
               ""
               "#ifndef ABS"
               "#define ABS RAbs"
               "#endif"
               ""
               "#ifndef SQRT"
               "#define SQRT RSqrt"
               "#endif"
               ""
               "#ifndef EXP"
               "#define EXP RExp"
               "#endif"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : RPowerI"
               " * -----------------------------------------------------------------"
               " * Usage : int exponent;"
               " *         realtype base, ans;"
               " *         ans = RPowerI(base,exponent);"
               " * -----------------------------------------------------------------"
               " * RPowerI returns the value of base^exponent, where base is of type"
               " * realtype and exponent is of type int."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "realtype RPowerI(realtype base, int exponent);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : RPowerR"
               " * -----------------------------------------------------------------"
               " * Usage : realtype base, exponent, ans;"
               " *         ans = RPowerR(base,exponent);"
               " * -----------------------------------------------------------------"
               " * RPowerR returns the value of base^exponent, where both base and"
               " * exponent are of type realtype. If base < ZERO, then RPowerR"
               " * returns ZERO."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "realtype RPowerR(realtype base, realtype exponent);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : RSqrt"
               " * -----------------------------------------------------------------"
               " * Usage : realtype sqrt_x;"
               " *         sqrt_x = RSqrt(x);"
               " * -----------------------------------------------------------------"
               " * RSqrt(x) returns the square root of x. If x < ZERO, then RSqrt"
               " * returns ZERO."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "realtype RSqrt(realtype x);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : RAbs (a.k.a. ABS)"
               " * -----------------------------------------------------------------"
               " * Usage : realtype abs_x;"
               " *         abs_x = RAbs(x);"
               " * -----------------------------------------------------------------"
               " * RAbs(x) returns the absolute value of x."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "realtype RAbs(realtype x);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Function : RExp (a.k.a. EXP)"
               " * -----------------------------------------------------------------"
               " * Usage : realtype exp_x;"
               " *         exp_x = RExp(x);"
               " * -----------------------------------------------------------------"
               " * RExp(x) returns e^x (base-e exponential function)."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "realtype RExp(realtype x);"
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'sundials_nvector.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * ----------------------------------------------------------------- "
               " * Programmer(s): Radu Serban and Aaron Collier @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * This is the header file for a generic NVECTOR package."
               " * It defines the N_Vector structure (_generic_N_Vector) which"
               " * contains the following fields:"
               " *   - an implementation-dependent ''content'' field which contains"
               " *     the description and actual data of the vector"
               " *   - an ''ops'' filed which contains a structure listing operations"
               " *     acting on such vectors"
               " *"
               " * Part I of this file contains type declarations for the"
               " * _generic_N_Vector and _generic_N_Vector_Ops structures, as well"
               " * as references to pointers to such structures (N_Vector)."
               " *"
               " * Part II of this file contains the prototypes for the vector"
               " * functions which operate on N_Vector."
               " *"
               " * At a minimum, a particular implementation of an NVECTOR must"
               " * do the following:"
               " *  - specify the ''content'' field of N_Vector,"
               " *  - implement the operations on those N_Vectors,"
               " *  - provide a constructor routine for new vectors"
               " *"
               " * Additionally, an NVECTOR implementation may provide the following:"
               " *  - macros to access the underlying N_Vector data"
               " *  - a constructor for an array of N_Vectors"
               " *  - a constructor for an empty N_Vector (i.e., a new N_Vector with"
               " *    a NULL data pointer)."
               " *  - a routine to print the content of an N_Vector"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _NVECTOR_H"
               "#define _NVECTOR_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include ""sundials_types.h"""
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Generic definition of N_Vector"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "/* Forward reference for pointer to N_Vector_Ops object */"
               "typedef struct _generic_N_Vector_Ops *N_Vector_Ops;"
               ""
               "/* Forward reference for pointer to N_Vector object */"
               "typedef struct _generic_N_Vector *N_Vector;"
               ""
               "/* Define array of N_Vectors */"
               "typedef N_Vector *N_Vector_S;"
               ""
               "/* Structure containing function pointers to vector operations  */  "
               "struct _generic_N_Vector_Ops {"
               "  N_Vector    (*nvclone)(N_Vector);"
               "  N_Vector    (*nvcloneempty)(N_Vector);"
               "  void        (*nvdestroy)(N_Vector);"
               "  void        (*nvspace)(N_Vector, long int *, long int *);"
               "  realtype*   (*nvgetarraypointer)(N_Vector);"
               "  void        (*nvsetarraypointer)(realtype *, N_Vector);"
               "  void        (*nvlinearsum)(realtype, N_Vector, realtype, N_Vector, N_Vector); "
               "  void        (*nvconst)(realtype, N_Vector);"
               "  void        (*nvprod)(N_Vector, N_Vector, N_Vector);"
               "  void        (*nvdiv)(N_Vector, N_Vector, N_Vector);"
               "  void        (*nvscale)(realtype, N_Vector, N_Vector);"
               "  void        (*nvabs)(N_Vector, N_Vector);"
               "  void        (*nvinv)(N_Vector, N_Vector);"
               "  void        (*nvaddconst)(N_Vector, realtype, N_Vector);"
               "  realtype    (*nvdotprod)(N_Vector, N_Vector);"
               "  realtype    (*nvmaxnorm)(N_Vector);"
               "  realtype    (*nvwrmsnorm)(N_Vector, N_Vector);"
               "  realtype    (*nvwrmsnormmask)(N_Vector, N_Vector, N_Vector);"
               "  realtype    (*nvmin)(N_Vector);"
               "  realtype    (*nvwl2norm)(N_Vector, N_Vector);"
               "  realtype    (*nvl1norm)(N_Vector);"
               "  void        (*nvcompare)(realtype, N_Vector, N_Vector);"
               "  booleantype (*nvinvtest)(N_Vector, N_Vector);"
               "  booleantype (*nvconstrmask)(N_Vector, N_Vector, N_Vector);"
               "  realtype    (*nvminquotient)(N_Vector, N_Vector);"
               "};"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * A vector is a structure with an implementation-dependent"
               " * ''content'' field, and a pointer to a structure of vector"
               " * operations corresponding to that implementation."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "struct _generic_N_Vector {"
               "  void *content;"
               "  struct _generic_N_Vector_Ops *ops;"
               "};"
               "  "
               "/*"
               " * -----------------------------------------------------------------"
               " * Functions exported by NVECTOR module"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * N_VClone"
               " *   Creates a new vector of the same type as an existing vector."
               " *   It does not copy the vector, but rather allocates storage for"
               " *   the new vector."
               " *"
               " * N_VCloneEmpty"
               " *   Creates a new vector of the same type as an existing vector,"
               " *   but does not allocate storage."
               " *"
               " * N_VDestroy"
               " *   Destroys a vector created with N_VClone."
               " *"
               " * N_VSpace"
               " *   Returns space requirements for one N_Vector (type ''realtype'' in"
               " *   lrw and type ''long int'' in liw)."
               " *"
               " * N_VGetArrayPointer"
               " *   Returns a pointer to the data component of the given N_Vector."
               " *   NOTE: This function assumes that the internal data is stored"
               " *   as a contiguous ''realtype'' array. This routine is only used in"
               " *   the solver-specific interfaces to the dense and banded linear"
               " *   solvers, as well as the interfaces to  the banded preconditioners"
               " *   distributed with SUNDIALS."
               " *   "
               " * N_VSetArrayPointer"
               " *   Overwrites the data field in the given N_Vector with a user-supplied"
               " *   array of type ''realtype''."
               " *   NOTE: This function assumes that the internal data is stored"
               " *   as a contiguous ''realtype'' array. This routine is only used in"
               " *   the interfaces to the dense linear solver."
               " *"
               " * N_VLinearSum"
               " *   Performs the operation z = a*x + b*y"
               " *"
               " * N_VConst"
               " *   Performs the operation z[i] = c for i = 0, 1, ..., N-1"
               " *"
               " * N_VProd"
               " *   Performs the operation z[i] = x[i]*y[i] for i = 0, 1, ..., N-1"
               " *"
               " * N_VDiv"
               " *   Performs the operation z[i] = x[i]/y[i] for i = 0, 1, ..., N-1"
               " *"
               " * N_VScale"
               " *   Performs the operation z = c*x"
               " *"
               " * N_VAbs"
               " *   Performs the operation z[i] = |x[i]| for i = 0, 1, ..., N-1"
               " *"
               " * N_VInv"
               " *   Performs the operation z[i] = 1/x[i] for i = 0, 1, ..., N-1"
               " *   This routine does not check for division by 0. It should be"
               " *   called only with an N_Vector x which is guaranteed to have"
               " *   all non-zero components."
               " *"
               " * N_VAddConst"
               " *   Performs the operation z[i] = x[i] + b   for i = 0, 1, ..., N-1"
               " *"
               " * N_VDotProd"
               " *   Returns the dot product of two vectors:"
               " *         sum (i = 0 to N-1) {x[i]*y[i]}"
               " *"
               " * N_VMaxNorm"
               " *   Returns the maximum norm of x:"
               " *         max (i = 0 to N-1) ABS(x[i])"
               " *"
               " * N_VWrmsNorm"
               " *   Returns the weighted root mean square norm of x with weight "
               " *   vector w:"
               " *         sqrt [(sum (i = 0 to N-1) {(x[i]*w[i])^2})/N]"
               " *"
               " * N_VWrmsNormMask"
               " *   Returns the weighted root mean square norm of x with weight"
               " *   vector w, masked by the elements of id:"
               " *         sqrt [(sum (i = 0 to N-1) {(x[i]*w[i]*msk[i])^2})/N]"
               " *   where msk[i] = 1.0 if id[i] > 0 and"
               " *         msk[i] = 0.0 if id[i] < 0"
               " *"
               " * N_VMin"
               " *   Returns the smallest element of x:"
               " *         min (i = 0 to N-1) x[i]"
               " *"
               " * N_VWL2Norm"
               " *   Returns the weighted Euclidean L2 norm of x with weight "
               " *   vector w:"
               " *         sqrt [(sum (i = 0 to N-1) {(x[i]*w[i])^2})]"
               " *"
               " * N_VL1Norm"
               " *   Returns the L1 norm of x:"
               " *         sum (i = 0 to N-1) {ABS(x[i])}"
               " *"
               " * N_VCompare"
               " *   Performs the operation"
               " *          z[i] = 1.0 if ABS(x[i]) >= c   i = 0, 1, ..., N-1"
               " *                 0.0 otherwise"
               " *"
               " * N_VInvTest"
               " *   Performs the operation z[i] = 1/x[i] with a test for "
               " *   x[i] == 0.0 before inverting x[i]."
               " *   This routine returns TRUE if all components of x are non-zero "
               " *   (successful inversion) and returns FALSE otherwise."
               " *"
               " * N_VConstrMask"
               " *   Performs the operation : "
               " *       m[i] = 1.0 if constraint test fails for x[i]"
               " *       m[i] = 0.0 if constraint test passes for x[i]"
               " *   where the constraint tests are as follows:"
               " *      If c[i] = +2.0, then x[i] must be >  0.0."
               " *      If c[i] = +1.0, then x[i] must be >= 0.0."
               " *      If c[i] = -1.0, then x[i] must be <= 0.0."
               " *      If c[i] = -2.0, then x[i] must be <  0.0."
               " *   This routine returns a boolean FALSE if any element failed"
               " *   the constraint test, TRUE if all passed. It also sets a"
               " *   mask vector m, with elements equal to 1.0 where the"
               " *   corresponding constraint test failed, and equal to 0.0"
               " *   where the constraint test passed."
               " *   This routine is specialized in that it is used only for"
               " *   constraint checking."
               " *"
               " * N_VMinQuotient"
               " *   Performs the operation : "
               " *       minq  = min ( num[i]/denom[i]) over all i such that   "
               " *       denom[i] != 0."
               " *   This routine returns the minimum of the quotients obtained"
               " *   by term-wise dividing num[i] by denom[i]. A zero element"
               " *   in denom will be skipped. If no such quotients are found,"
               " *   then the large value BIG_REAL is returned."
               " *"
               " * -----------------------------------------------------------------"
               " *"
               " * The following table lists the vector functions used by"
               " * different modules in SUNDIALS. The symbols in the table"
               " * have the following meaning:"
               " * S    -  called by the solver;"
               " * D    -  called by the dense linear solver module"
               " * B    -  called by the band linear solver module"
               " * Di   -  called by the diagonal linear solver module"
               " * I    -  called by the iterative linear solver module"
               " * BP   -  called by the band preconditioner module"
               " * BBDP -  called by the band-block diagonal preconditioner module"
               " * F    -  called by the Fortran-to-C interface"
               " *"
               " *                  ------------------------------------------------"
               " *                                         MODULES                  "
               " * NVECTOR          ------------------------------------------------"
               " * FUNCTIONS          CVODE/CVODES          IDA             KINSOL    "
               " * -----------------------------------------------------------------"
               " * N_VClone           S Di I                S I BBDP        S I BBDP"
               " * -----------------------------------------------------------------"
               " * N_VCloneEmpty      F                     F               F"
               " * -----------------------------------------------------------------"
               " * N_VDestroy         S Di I                S I BBDP        S I BBDP"
               " * -----------------------------------------------------------------"
               " * N_VSpace           S                     S               S         "
               " * -----------------------------------------------------------------"
               " * N_VGetArrayPointer D B BP BBDP F         D B BBDP        BBDP F     "
               " * -----------------------------------------------------------------"
               " * N_VSetArrayPointer D F                   D               F"
               " * -----------------------------------------------------------------"
               " * N_VLinearSum       S D Di I              S D I           S I       "
               " * -----------------------------------------------------------------"
               " * N_VConst           S I                   S I             I       "
               " * -----------------------------------------------------------------"
               " * N_VProd            S Di I                S I             S I       "
               " * -----------------------------------------------------------------"
               " * N_VDiv             S Di I                S I             S I"
               " * -----------------------------------------------------------------"
               " * N_VScale           S D B Di I BP BBDP    S D B I BBDP    S I BBDP  "
               " * -----------------------------------------------------------------"
               " * N_VAbs             S                     S               S         "
               " * -----------------------------------------------------------------"
               " * N_VInv             S Di                  S               S         "
               " * -----------------------------------------------------------------"
               " * N_VAddConst        S Di                  S                        "
               " * -----------------------------------------------------------------"
               " * N_VDotProd         I                     I               I         "
               " * -----------------------------------------------------------------"
               " * N_VMaxNorm         S                     S               S         "
               " * -----------------------------------------------------------------"
               " * N_VWrmsNorm        S D B I BP BBDP       S                         "
               " * -----------------------------------------------------------------"
               " * N_VWrmsNormMask                          S                         "
               " * -----------------------------------------------------------------"
               " * N_VMin             S                     S               S         "
               " * -----------------------------------------------------------------"
               " * N_VWL2Norm                                               S I       "
               " * -----------------------------------------------------------------"
               " * N_VL1Norm                                                I"
               " * -----------------------------------------------------------------"
               " * N_VCompare         Di                    S                         "
               " * -----------------------------------------------------------------"
               " * N_VInvTest         Di                                              "
               " * -----------------------------------------------------------------"
               " * N_VConstrMask                            S               S         "
               " * -----------------------------------------------------------------"
               " * N_VMinQuotient                           S               S         "
               " * -----------------------------------------------------------------"
               " */"
               "  "
               "N_Vector N_VClone(N_Vector w);"
               "N_Vector N_VCloneEmpty(N_Vector w);"
               "void N_VDestroy(N_Vector v);"
               "void N_VSpace(N_Vector v, long int *lrw, long int *liw);"
               "realtype *N_VGetArrayPointer(N_Vector v);"
               "void N_VSetArrayPointer(realtype *v_data, N_Vector v);"
               "void N_VLinearSum(realtype a, N_Vector x, realtype b, N_Vector y, N_Vector z);"
               "void N_VConst(realtype c, N_Vector z);"
               "void N_VProd(N_Vector x, N_Vector y, N_Vector z);"
               "void N_VDiv(N_Vector x, N_Vector y, N_Vector z);"
               "void N_VScale(realtype c, N_Vector x, N_Vector z);"
               "void N_VAbs(N_Vector x, N_Vector z);"
               "void N_VInv(N_Vector x, N_Vector z);"
               "void N_VAddConst(N_Vector x, realtype b, N_Vector z);"
               "realtype N_VDotProd(N_Vector x, N_Vector y);"
               "realtype N_VMaxNorm(N_Vector x);"
               "realtype N_VWrmsNorm(N_Vector x, N_Vector w);"
               "realtype N_VWrmsNormMask(N_Vector x, N_Vector w, N_Vector id);"
               "realtype N_VMin(N_Vector x);"
               "realtype N_VWL2Norm(N_Vector x, N_Vector w);"
               "realtype N_VL1Norm(N_Vector x);"
               "void N_VCompare(realtype c, N_Vector x, N_Vector z);"
               "booleantype N_VInvTest(N_Vector x, N_Vector z);"
               "booleantype N_VConstrMask(N_Vector c, N_Vector x, N_Vector m);"
               "realtype N_VMinQuotient(N_Vector num, N_Vector denom);"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * Additional functions exported by NVECTOR module"
               " * -----------------------------------------------------------------"
               " */"
               ""
               "/*"
               " * -----------------------------------------------------------------"
               " * N_VCloneEmptyVectorArray"
               " *   Creates (by cloning ''w'') an array of ''count'' empty N_Vectors "
               " *"
               " * N_VCloneVectorArray"
               " *   Creates (by cloning ''w'') an array of ''count'' N_Vectors "
               " *"
               " * N_VDestroyVectorArray"
               " *   Frees memory for an array of ''count'' N_Vectors that was"
               " *   created by a call to N_VCloneVectorArray"
               " *"
               " * These functions are used by the SPGMR iterative linear solver "
               " * module and by the CVODES and IDAS solvers."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "N_Vector *N_VCloneEmptyVectorArray(int count, N_Vector w);"
               "N_Vector *N_VCloneVectorArray(int count, N_Vector w);"
               "void N_VDestroyVectorArray(N_Vector *vs, int count);"
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'sundials_smalldense.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * -----------------------------------------------------------------"
               " * Programmer: Radu Serban @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2006, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " * -----------------------------------------------------------------"
               " * This is the header file for a generic DENSE linear solver"
               " * package, intended for small m by n dense matrices, with m<=n."
               " * These routines use the type realtype** for dense matrix arguments."
               " * -----------------------------------------------------------------"
               " */"
               ""
               "#ifndef _SMALLDENSE_H"
               "#define _SMALLDENSE_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#include ""sundials_types.h"""
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : denalloc"
               "   * -----------------------------------------------------------------"
               "   * Usage : realtype **a;"
               "   *         a = denalloc(m, n);"
               "   *         if (a == NULL) ... memory request failed"
               "   * -----------------------------------------------------------------"
               "   * denalloc(m, n) allocates storage for an m by n dense matrix."
               "   * It returns a pointer to the newly allocated storage if successful. "
               "   * If the memory request cannot be satisfied, then denalloc returns "
               "   * NULL. The underlying type of the dense matrix returned is a double"
               "   * pointer to realtype. If we allocate a dense matrix a by "
               "   * a = denalloc(m, n), then a[j][i] references the (i,j)-th element "
               "   * of the matrix a, 0 <= i < m, 0 <= j < n,  and a[j] is a pointer "
               "   * to the first element in the jth column of a. The location a[0] "
               "   * contains a pointer to m*n contiguous locations which contain the "
               "   * elements of a."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  realtype **denalloc(long int m, long int n);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : denallocpiv"
               "   * -----------------------------------------------------------------"
               "   * Usage : long int *pivot;"
               "   *         pivot = denallocpiv(n);"
               "   *         if (pivot == NULL) ... memory request failed"
               "   * -----------------------------------------------------------------"
               "   * denallocpiv(n) allocates an array of n long int. It returns"
               "   * a pointer to the first element in the array if successful."
               "   * It returns NULL if the memory request could not be satisfied."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  long int *denallocpiv(long int n);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : denGETRF"
               "   * -----------------------------------------------------------------"
               "   * Usage : long int ier;"
               "   *         ier = denGETRF(a,m,n,p);"
               "   *         if (ier > 0) ... zero element encountered during"
               "   *                          the factorization"
               "   * -----------------------------------------------------------------"
               "   * denGETRF(a,m,n,p) factors the m by n dense matrix a, m>=n."
               "   * It overwrites the elements of a with its LU factors and keeps "
               "   * track of the pivot rows chosen in the pivot array p."
               "   *"
               "   * A successful LU factorization leaves the matrix a and the"
               "   * pivot array p with the following information:"
               "   *"
               "   * (1) p[k] contains the row number of the pivot element chosen"
               "   *     at the beginning of elimination step k, k=0, 1, ..., n-1."
               "   *"
               "   * (2) If the unique LU factorization of a is given by Pa = LU,"
               "   *     where P is a permutation matrix, L is a lower trapezoidal"
               "   *     matrix with all 1.0 on the diagonal, and U is an upper"
               "   *     triangular matrix, then the upper triangular part of a"
               "   *     (including its diagonal) contains U and the strictly lower"
               "   *     trapezoidal part of a contains the multipliers, I-L."
               "   *"
               "   * Note that for square matrices (m=n), L is unit lower triangular."
               "   *"
               "   * denGETRF returns 0 if successful. Otherwise it encountered a"
               "   * zero diagonal element during the factorization. In this case"
               "   * it returns the column index (numbered from one) at which it"
               "   * encountered the zero."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  long int denGETRF(realtype **a, long int m, long int n, long int *p);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : denGETRS"
               "   * -----------------------------------------------------------------"
               "   * Usage : realtype *b;"
               "   *         ier = denGETRF(a,n,n,p);"
               "   *         if (ier == 0) denGETRS(a,n,p,b);"
               "   * -----------------------------------------------------------------"
               "   * denGETRS(a,n,p,b) solves the n by n linear system a*x = b."
               "   * It assumes that a has been LU factored and the pivot array p has"
               "   * been set by a successful call to denGETRF(a,n,n,p). "
               "   * denGETRS does not check whether a is square!"
               "   * The solution x is written into the b array."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void denGETRS(realtype **a, long int n, long int *p, realtype *b);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : denzero"
               "   * -----------------------------------------------------------------"
               "   * Usage : denzero(a,m,n);"
               "   * -----------------------------------------------------------------"
               "   * denzero(a,m,n) sets all the elements of the m by n dense matrix"
               "   * a to be 0.0."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void denzero(realtype **a, long int m, long int n);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : dencopy"
               "   * -----------------------------------------------------------------"
               "   * Usage : dencopy(a,b,m,n);"
               "   * -----------------------------------------------------------------"
               "   * dencopy(a,b,n) copies the m by n dense matrix a into the"
               "   * m by n dense matrix b."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void dencopy(realtype **a, realtype **b, long int m, long int n);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : denscale"
               "   * -----------------------------------------------------------------"
               "   * Usage : denscale(c,a,m,n);"
               "   * -----------------------------------------------------------------"
               "   * denscale(c,a,m,n) scales every element in the m by n dense"
               "   * matrix a by c."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void denscale(realtype c, realtype **a, long int m, long int n);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : denaddI"
               "   * -----------------------------------------------------------------"
               "   * Usage : denaddI(a,n);"
               "   * -----------------------------------------------------------------"
               "   * denaddI(a,n) increments the diagonal elements of the dense "
               "   * m by n matrix a by 1.0. (a_ii <= a_ii + 1, i=1,2,..n-1.)"
               "   * denaddI is typically used with square matrices."
               "   * denaddI does NOT check for m >= n! Therefore, a segmentation "
               "   * fault will occur if m<n!"
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void denaddI(realtype **a, long int n);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : denfreepiv"
               "   * -----------------------------------------------------------------"
               "   * Usage : denfreepiv(p);"
               "   * -----------------------------------------------------------------"
               "   * denfreepiv(p) frees the pivot array p allocated by"
               "   * denallocpiv."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void denfreepiv(long int *p);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : denfree"
               "   * -----------------------------------------------------------------"
               "   * Usage : denfree(a);"
               "   * -----------------------------------------------------------------"
               "   * denfree(a) frees the dense matrix a allocated by denalloc."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void denfree(realtype **a);"
               ""
               "  /*"
               "   * -----------------------------------------------------------------"
               "   * Function : denprint"
               "   * -----------------------------------------------------------------"
               "   * Usage : denprint(a,m,n);"
               "   * -----------------------------------------------------------------"
               "   * denprint(a,m,n) prints the m by n dense matrix a to standard"
               "   * output as it would normally appear on paper. It is intended as"
               "   * a debugging tool with small values of m and n. The elements are"
               "   * printed using the %g/%lg/%Lg option. A blank line is printed"
               "   * before and after the matrix."
               "   * -----------------------------------------------------------------"
               "   */"
               ""
               "  void denprint(realtype **a, long int m, long int n);"
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'sundials_types.h' then
        txt = ["/*"
               " * -----------------------------------------------------------------"
               " * ----------------------------------------------------------------- "
               " * Programmer(s): Scott Cohen, Alan Hindmarsh, Radu Serban, and"
               " *                Aaron Collier @ LLNL"
               " * -----------------------------------------------------------------"
               " * Copyright (c) 2002, The Regents of the University of California."
               " * Produced at the Lawrence Livermore National Laboratory."
               " * All rights reserved."
               " * For details, see the LICENSE file."
               " *------------------------------------------------------------------"
               " * This header file exports two types: realtype and booleantype,"
               " * as well as the constants TRUE and FALSE."
               " *"
               " * Users should include the header file sundials_types.h in every"
               " * program file and use the exported name realtype instead of"
               " * float, double or long double."
               " *"
               " * The constants SUNDIALS_SINGLE_PRECISION, SUNDIALS_DOUBLE_PRECISION"
               " * and SUNDIALS_LONG_DOUBLE_PRECISION indicate the underlying data"
               " * type of realtype. It is set at the configuration stage."
               " *"
               " * The legal types for realtype are float, double and long double."
               " *"
               " * The macro RCONST gives the user a convenient way to define"
               " * real-valued constants. To use the constant 1.0, for example,"
               " * the user should write the following:"
               " *"
               " *   #define ONE RCONST(1.0)"
               " *"
               " * If realtype is defined as a double, then RCONST(1.0) expands"
               " * to 1.0. If realtype is defined as a float, then RCONST(1.0)"
               " * expands to 1.0F. If realtype is defined as a long double,"
               " * then RCONST(1.0) expands to 1.0L. There is never a need to"
               " * explicitly cast 1.0 to (realtype)."
               " *------------------------------------------------------------------"
               " */"
               "  "
               "#ifndef _SUNDIALSTYPES_H"
               "#define _SUNDIALSTYPES_H"
               ""
               "#ifdef __cplusplus  /* wrapper to enable C++ usage */"
               "extern ""C"" {"
               "#endif"
               ""
               "#ifndef _SUNDIALS_CONFIG_H"
               "#define _SUNDIALS_CONFIG_H"
               "#include ""sundials_config.h"""
               "#endif"
               ""
               "#include <float.h>"
               "  "
               "#if defined(SUNDIALS_SINGLE_PRECISION)"
               ""
               "typedef float realtype;"
               "#define RCONST(x) x##F"
               "#define BIG_REAL FLT_MAX"
               "#define SMALL_REAL FLT_MIN"
               "#define UNIT_ROUNDOFF FLT_EPSILON"
               ""
               "#elif defined(SUNDIALS_DOUBLE_PRECISION)"
               ""
               "typedef double realtype;"
               "#define RCONST(x) x"
               "#define BIG_REAL DBL_MAX"
               "#define SMALL_REAL DBL_MIN"
               "#define UNIT_ROUNDOFF DBL_EPSILON"
               ""
               "#elif defined(SUNDIALS_EXTENDED_PRECISION)"
               ""
               "typedef long double realtype;"
               "#define RCONST(x) x##L"
               "#define BIG_REAL LDBL_MAX"
               "#define SMALL_REAL LDBL_MIN"
               "#define UNIT_ROUNDOFF LDBL_EPSILON"
               ""
               "#endif"
               ""
               "/*"
               " *------------------------------------------------------------------"
               " * Type : booleantype"
               " *------------------------------------------------------------------"
               " * Constants : FALSE and TRUE"
               " *------------------------------------------------------------------"
               " * ANSI C does not have a built-in boolean data type. Below is the"
               " * definition for a new type called booleantype. The advantage of"
               " * using the name booleantype (instead of int) is an increase in"
               " * code readability. It also allows the programmer to make a"
               " * distinction between int and boolean data. Variables of type"
               " * booleantype are intended to have only the two values FALSE and"
               " * TRUE which are defined below to be equal to 0 and 1,"
               " * respectively."
               " *------------------------------------------------------------------"
               " */"
               ""
               "#ifndef booleantype"
               "#define booleantype int"
               "#endif"
               ""
               "#ifndef FALSE"
               "#define FALSE 0"
               "#endif"
               ""
               "#ifndef TRUE"
               "#define TRUE 1"
               "#endif"
               ""
               "#ifdef __cplusplus"
               "}"
               "#endif"
               ""
               "#endif"]

      case 'LICENSE' then
        txt = ["Copyright (c) 2002, The Regents of the University of California. "
               "Produced at the Lawrence Livermore National Laboratory."
               "Written by S.D. Cohen, A.C. Hindmarsh, R. Serban, "
               "           D. Shumaker, and A.G. Taylor."
               "UCRL-CODE-155951    (CVODE)"
               "UCRL-CODE-155950    (CVODES)"
               "UCRL-CODE-155952    (IDA)"
               "UCRL-CODE-155953    (KINSOL)"
               "All rights reserved. "
               ""
               "This file is part of SUNDIALS."
               ""
               "Redistribution and use in source and binary forms, with or without"
               "modification, are permitted provided that the following conditions"
               "are met:"
               ""
               "1. Redistributions of source code must retain the above copyright"
               "notice, this list of conditions and the disclaimer below."
               ""
               "2. Redistributions in binary form must reproduce the above copyright"
               "notice, this list of conditions and the disclaimer (as noted below)"
               "in the documentation and/or other materials provided with the"
               "distribution."
               ""
               "3. Neither the name of the UC/LLNL nor the names of its contributors"
               "may be used to endorse or promote products derived from this software"
               "without specific prior written permission."
               ""
               "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS"
               """AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT"
               "LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS"
               "FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE"
               "REGENTS OF THE UNIVERSITY OF CALIFORNIA, THE U.S. DEPARTMENT OF ENERGY"
               "OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,"
               "SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT"
               "LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,"
               "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY"
               "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT"
               "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE"
               "OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
               ""
               "Additional BSD Notice"
               "---------------------"
               "1. This notice is required to be provided under our contract with"
               "the U.S. Department of Energy (DOE). This work was produced at the"
               "University of California, Lawrence Livermore National Laboratory"
               "under Contract No. W-7405-ENG-48 with the DOE."
               ""
               "2. Neither the United States Government nor the University of"
               "California nor any of their employees, makes any warranty, express"
               "or implied, or assumes any liability or responsibility for the"
               "accuracy, completeness, or usefulness of any information, apparatus,"
               "product, or process disclosed, or represents that its use would not"
               "infringe privately-owned rights."
               ""
               "3. Also, reference herein to any specific commercial products,"
               "process, or services by trade name, trademark, manufacturer or"
               "otherwise does not necessarily constitute or imply its endorsement,"
               "recommendation, or favoring by the United States Government or the"
               "University of California. The views and opinions of authors expressed"
               "herein do not necessarily state or reflect those of the United States"
               "Government or the University of California, and shall not be used for"
               "advertising or product endorsement purposes."]

  end
endfunction

